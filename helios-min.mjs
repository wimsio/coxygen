/*
//////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////      Helios      /////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// Author:        Christian Schmitz
// Email:         cschmitz398@gmail.com
// Website:       https://www.hyperion-bt.org
// Repository:    https://github.com/hyperion-bt/helios
// Version:       0.16.7
// Last update:   January 2024
// License type:  BSD-3-Clause
//
//
// About: Helios is a smart contract DSL for Cardano.
//     This Javascript library contains functions to compile Helios sources into Plutus-core.
//     Transactions can also be built using Helios.
//
//
// Dependencies: none
//
//
// Disclaimer: I made Helios available as FOSS so that the Cardano community can test it 
//     extensively. I don't guarantee the library is bug-free, nor do I guarantee
//     backward compatibility with future versions.
//
//
// Example usage:
//     > import * as helios from "helios.js";
//     > console.log(helios.Program.new("spending my_validator ...").compile().serialize());
//     
//
// Documentation: https://www.hyperion-bt.org/helios-book
//
//
// Note: I recommend keeping the Helios library as a single unminified file for optimal 
//     auditability.
//
// 
// License text:
//     Copyright 2023 Christian Schmitz
//     
//     Redistribution and use in source and binary forms, with or without 
//     modification, are permitted provided that the following conditions are met:
//     
//     1. Redistributions of source code must retain the above copyright notice, this 
//     list of conditions and the following disclaimer.
//     
//     2. Redistributions in binary form must reproduce the above copyright notice, 
//     this list of conditions and the following disclaimer in the documentation 
//     and/or other materials provided with the distribution.
//     
//     3. Neither the name of the copyright holder nor the names of its contributors 
//     may be used to endorse or promote products derived from this software without 
//     specific prior written permission.
//     
//     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” 
//     AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
//     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
//     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
//     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
//     DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
//     SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
//     CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
//     OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
//     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//     reduced sized
*/
export const VERSION="0.16.7";export const TAB="  ";export const REAL_PRECISION=6;export const config={set:t=>{Object.keys(t).forEach((e=>{config[e]=t[e]}))},DEBUG:!1,STRICT_BABBAGE:!1,IS_TESTNET:!0,N_DUMMY_INPUTS:2,AUTO_SET_VALIDITY_RANGE:!1,VALIDITY_RANGE_START_OFFSET:90,VALIDITY_RANGE_END_OFFSET:300,IGNORE_UNEVALUATED_CONSTANTS:!1,CHECK_CASTS:!1,MAX_ASSETS_PER_CHANGE_OUTPUT:void 0};export function assert(t,e="unexpected"){if(!t)throw new Error(e)}export function assertDefined(t,e="unexpected undefined value"){if(null==t)throw new Error(e);return t}export function assertClass(t,e,n="unexpected class"){if(t instanceof e)return t;throw new Error(n)}export function assertNonEmpty(t,e="empty string"){if(0==t.length)throw new Error(e);return t}export function assertNumber(t,e="expected a number"){if(null==t)throw new Error(e);if("number"==typeof t)return t;throw new Error(e)}export function reduceNull(t){const e=[];let n=!1;return t.forEach((t=>{null===t||n?n=!0:e.push(t)})),n?null:e}export function reduceNullPairs(t){const e=[];let n=!1;return t.forEach((([t,r])=>{null===t||null===r?n=!0:n||e.push([t,r])})),n?null:e}export function eq(t,e){if(void 0===t||void 0===e)throw new Error("one of the args is undefined");if("string"==typeof t)return t===e;if("number"==typeof t)return t===e;if("boolean"==typeof t)return t===e;if("bigint"==typeof t)return t===e;if(t instanceof Array&&e instanceof Array){if(t.length!=e.length)return!1;for(let n=0;n<t.length;n++)if(!eq(t[n],e[n]))return!1;return!0}throw new Error(`eq not yet implemented for these types: ${typeof t} and ${typeof e}`)}export function assertEq(t,e,n){if(!eq(t,e))throw console.log("lhs:",t),console.log("rhs:",e),console.log("..."),new Error(n)}export function idiv(t,e){return Math.floor(t/e)}export function ipow2(t){return t<=0n?1n:2n<<t-1n}export function imask(t,e,n){assert(e<n);return(t&[255,127,63,31,15,7,3,1][e])>>8-n}export function imod8(t){return 255&t}export function bigIntToBytes(t){if(0n==t)return[0];{const e=[];for(;t>0n;)e.unshift(Number(t%256n)),t/=256n;return e}}export function bytesToBigInt(t){let e=1n,n=0n;for(;t.length>0;)n+=BigInt(assertDefined(t.pop()))*e,e*=256n;return n}export function leBytesToBigInt(t){return bytesToBigInt(t.slice().reverse())}export function bigIntToLe32Bytes(t){const e=bigIntToBytes(t).reverse();for(;e.length<32;)e.push(0);return e}export function padZeroes(t,e){if(t.length%e!=0){const n=e-t.length%e;t=new Array(n).fill("0").join("")+t}return t}export function byteToBitString(t,e=8,n=!0){const r=padZeroes(t.toString(2),e);return n?"0b"+r:r}export function hexToBytes(t){t=t.trim();const e=[];for(let n=0;n<t.length;n+=2){const r=parseInt(t.slice(n,n+2),16);assert(!Number.isNaN(r),`invalid hexstring "${t}"`),e.push(parseInt(t.slice(n,n+2),16))}return e}export function bytesToHex(t){const e=[];for(let n of t)e.push(padZeroes(n.toString(16),2));return e.join("")}export function textToBytes(t){return Array.from((new TextEncoder).encode(t))}export function bytesToText(t){return new TextDecoder("utf-8",{fatal:!0}).decode(new Uint8Array(t).buffer)}export function replaceTabs(t){return t.replace(new RegExp("\t","g"),TAB)}export class BitReader{#t;#e;#n;constructor(t,e=!0){this.#t=new Uint8Array(t),this.#e=0,this.#n=e}eof(){return idiv(this.#e,8)>=this.#t.length}readBits(t){assert(t<=8,"reading more than 1 byte");let e=0;if(this.#e+t>8*this.#t.length){const n=8*this.#t.length-this.#e;this.#n||(e=t-n),t=n}assert(t>0,"eof");let n=0,r=this.#e;for(let e=this.#e+1;e<=this.#e+t;e++)if(e%8==0){const s=e-r;n+=imask(this.#t[idiv(e,8)-1],r%8,8)<<t-s,r=e}else e==this.#e+t&&(n+=imask(this.#t[idiv(e,8)],r%8,e%8));return this.#e+=t,n<<e}moveToByteBoundary(t=!1){if(this.#e%8!=0){let t=8-this.#e%8;this.readBits(t)}else t&&this.readBits(8)}readByte(){return this.readBits(8)}dumpRemainingBits(){if(this.eof())console.log("eof");else{console.log("remaining bytes:");for(let t=!0,e=idiv(this.#e,8);e<this.#t.length;t=!1,e++)t&&this.#e%8!=0?console.log(byteToBitString(imask(this.#t[e],this.#e%8,8)<<8-this.#e%7)):console.log(byteToBitString(this.#t[e]))}}}export class BitWriter{#r;#s;constructor(){this.#r=[],this.#s=0}get length(){return this.#s}write(t){for(let e of t)if("0"!=e&&"1"!=e)throw new Error("bit string contains invalid chars: "+t);this.#r.push(t),this.#s+=t.length}writeByte(t){this.write(padZeroes(t.toString(2),8))}padToByteBoundary(t=!1){let e=0;if(this.#s%8!=0?e=8-this.#s%8:t&&(e=8),0!=e){let t=new Array(e).fill("0");t[e-1]="1",this.#r.push(t.join("")),this.#s+=e}}pop(t){assert(t<=this.#s,`too many bits to pop, only have ${this.#s} bits, but want ${t}`);const e=t,n=[];for(;t>0;){const e=assertDefined(this.#r.pop());0!=e.length&&(e.length<=t?(n.unshift(e),t-=e.length):(n.unshift(e.slice(e.length-t)),this.#r.push(e.slice(0,e.length-t)),t=0))}this.#s-=e;const r=n.join("");return assert(r.length==e),r}finalize(t=!0){this.padToByteBoundary(t);let e=this.#r.join(""),n=[];for(let t=0;t<e.length;t+=8){let r=e.slice(t,t+8),s=parseInt(r,2);n.push(s)}return n}}export class Source{#a;#i;#o;constructor(t,e){this.#a=assertDefined(t),this.#i=e,this.#o=[]}transfer(t){return t.transferSource(this.#a,this.#i)}get raw(){return this.#a}get name(){return this.#i}get errors(){return this.#o}throwErrors(){if(this.#o.length>0)throw this.#o[0]}getChar(t){return this.#a[t]}getWord(t){const e=[];function n(t){return void 0!==t&&("_"==t||t>="0"&&t<="9"||t>="A"&&t<="Z"||t>="a"&&t<="z")}let r=this.#a[t];for(;n(r);)e.push(r),t+=1,r=this.#a[t];return 0==e.length?null:e.join("")}get length(){return this.#a.length}posToLine(t){let e=0;for(let n=0;n<t;n++)"\n"==this.#a[n]&&(e+=1);return e}posToLineAndCol(t){let e=0,n=0;for(let r=0;r<t;r++)"\n"==this.#a[r]?(e=0,n+=1):e+=1;return[n,e]}pretty(){const t=this.#a.split("\n"),e=t.length,n=Math.max(Math.ceil(Math.log10(e)),2);for(let r=0;r<e;r++)t[r]=String(r+1).padStart(n,"0")+"  "+t[r];return t.join("\n")}}export function hl(t,...e){return t.map(((t,n)=>n<e.length?t+e[n].toString():t)).join("")}export function deprecationWarning(t,e,n,r=""){let s=`${t} is DEPRECATED, and will be removed from version ${e} onwards!\n${n}`;""!=r&&(s+=`\n(for more information: ${r})`),console.warn(s)}export class Site{#_;#l;#u;#c;#p;constructor(t,e,n=e+1,r=null){this.#_=t,this.#l=e,this.#u=n,this.#c=null,this.#p=r}transfer(t){return t.transferSite(this.#_.transfer(t),this.#l,this.#u,this.#p?.transfer(t)??null)}static dummy(){return new Site(new Source("",""),0)}get src(){return this.#_}get startPos(){return this.#l}get endPos(){return this.#u}get endSite(){return this.#c}merge(t){return new Site(this.#_,this.#l,t.#u,this.#p??t.#p)}setEndSite(t){this.#c=t}get codeMapSite(){return this.#p}setCodeMapSite(t){this.#p=t}syntaxError(t=""){return UserError.syntaxError(this.#_,this.#l,this.#u,t)}typeError(t=""){return UserError.typeError(this.#_,this.#l,this.#u,t)}referenceError(t=""){return UserError.referenceError(this.#_,this.#l,this.#u,t)}getFilePos(){const[t,e]=this.#_.posToLineAndCol(this.#l),[n,r]=this.#_.posToLineAndCol(this.#u);return[t,e,n,r]}toString(){const[t,e]=this.#_.posToLineAndCol(this.#l);return`${this.src.name}:${t+1}:${e+1}`}}export class UserError extends Error{#_;#l;#u;#h;constructor(t,e,n,r=n+1){super(t),this.#_=e,this.#l=n,this.#u=r,this.#h={}}static new(t,e,n,r,s=""){let[a,i]=e.posToLineAndCol(n),o=`(${e.name}:${a+1}:${i+1}) ${t}`;return""!=s&&(o+=`: ${s}`),new UserError(o,e,n,r)}get src(){return this.#_}get context(){return this.#h}static syntaxError(t,e,n,r=""){const s=UserError.new("SyntaxError",t,e,n,r);return t.errors.push(s),s}static typeError(t,e,n,r=""){const s=UserError.new("TypeError",t,e,n,r);return t.errors.push(s),s}static isTypeError(t){return t instanceof UserError&&t.message.startsWith("TypeError")}static referenceError(t,e,n,r=""){const s=UserError.new("ReferenceError",t,e,n,r);return t.errors.push(s),s}static isReferenceError(t){return t instanceof UserError&&t.message.startsWith("ReferenceError")}get data(){throw new Error("is error")}get startPos(){return this.#l}getFilePos(){const[t,e]=this.#_.posToLineAndCol(this.#l),[n,r]=this.#_.posToLineAndCol(this.#u);return[t,e,n,r]}dump(t=!1){t&&console.error(this.#_.pretty()),console.error("\n"+this.message)}toString(){return this.message}static catch(t,e=!1){try{return t()}catch(t){if(!(t instanceof UserError))throw t;t.dump(e)}}}export class RuntimeError extends Error{#h;constructor(t){super(t),this.#h={}}get context(){return this.#h}}export class Token{#d;constructor(t){this.#d=assertDefined(t)}get site(){return this.#d}toString(){throw new Error("not yet implemented")}isLiteral(){return!1}isWord(t=null){return!1}isKeyword(){return!1}isSymbol(t=null){return!1}isGroup(t,e=null){return!1}syntaxError(t){return this.#d.syntaxError(t)}typeError(t){return this.#d.typeError(t)}referenceError(t){return this.#d.referenceError(t)}assertWord(t=null){return null!==t?this.syntaxError(`expected '${t}', got '${this.toString()}'`):this.syntaxError(`expected word, got ${this.toString()}`),null}assertSymbol(t=null){return null!==t?this.syntaxError(`expected '${t}', got '${this.toString()}'`):this.syntaxError(`expected symbol, got '${this.toString()}'`),null}assertGroup(t=null,e=null){return null!==t?this.syntaxError(`invalid syntax: expected '${t}...${Group.matchSymbol(t)}'`):this.syntaxError("invalid syntax: expected group"),null}}export function assertToken(t,e,n="expected token"){return t||(e.syntaxError(n),null)}export class Word extends Token{#m;constructor(t,e){super(t),this.#m=e}static new(t){return new Word(Site.dummy(),t)}get value(){return this.#m}isWord(t=null){return null===t||(t instanceof Array?-1!=t.lastIndexOf(this.#m):t==this.#m)}assertWord(t=null){return this.isWord(t)||super.assertWord(t),this}assertNotInternal(){if("_"==this.#m)throw this.syntaxError("_ is reserved");if(this.#m.startsWith("__"))throw this.syntaxError("__ prefix is reserved");if(this.#m.endsWith("__"))throw this.syntaxError("__ suffix is reserved");return this}isKeyword(){switch(this.#m){case"const":case"func":case"struct":case"enum":case"import":case"if":case"else":case"switch":case"self":return!0;default:return!1}}assertNotKeyword(){return this.assertNotInternal(),this.isKeyword()?(this.syntaxError(`'${this.#m}' is a reserved word`),null):this}toString(){return this.#m}static find(t,e){return t.findIndex((t=>t.isWord(e)))}}export class SymbolToken extends Token{#m;constructor(t,e){super(t),this.#m=e}get value(){return this.#m}isSymbol(t=null){return null===t||(t instanceof Array?-1!=t.lastIndexOf(this.#m):t==this.#m)}assertSymbol(t){return this.isSymbol(t)||super.assertSymbol(t),this}toString(){return this.#m}static find(t,e){return t.findIndex((t=>t.isSymbol(e)))}static findLast(t,e){for(let n=t.length-1;n>=0;n--)if(t[n].isSymbol(e))return n;return-1}}export class Group extends Token{#f;#y;#g;constructor(t,e,n,r=null){super(t),this.#f=e,this.#y=n,this.#g=r,assert(n.length<2||null!==r)}get fields(){return this.#y.slice()}isGroup(t=null,e=null){const n=null===e||e==this.#y.length;return null!==t?this.#f==t&&n:n}assertGroup(t=null,e=null){return null!==t&&this.#f!=t?(this.syntaxError(`invalid syntax: expected '${t}...${Group.matchSymbol(t)}', got '${this.#f}...${Group.matchSymbol(this.#f)}'`),null):null!==t&&null!==e&&e!=this.#y.length?(this.#y.length>1&&e<=1&&null!==this.#g?this.#g.syntaxError("invalid syntax, unexpected ','"):this.syntaxError(`invalid syntax: expected '${t}...${Group.matchSymbol(t)}' with ${e} field(s), got '${t}...${Group.matchSymbol(t)}' with ${this.#y.length} fields`),null):this}toString(){let t=this.#f,e=[];for(let t of this.#y)e.push(t.map((t=>t.toString())).join(" "));return t+=e.join(", ")+Group.matchSymbol(this.#f),t}static isOpenSymbol(t){return t.isSymbol("{")||t.isSymbol("[")||t.isSymbol("(")}static isCloseSymbol(t){return t.isSymbol("}")||t.isSymbol("]")||t.isSymbol(")")}static matchSymbol(t){if(t instanceof SymbolToken&&(t=t.value),"{"==t)return"}";if("["==t)return"]";if("("==t)return")";if("}"==t)return"{";if("]"==t)return"[";if(")"==t)return"(";throw new Error("not a group symbol")}static find(t,e){return t.findIndex((t=>t.isGroup(e)))}}export class PrimitiveLiteral extends Token{constructor(t){super(t)}isLiteral(){return!0}}export class IntLiteral extends PrimitiveLiteral{#m;constructor(t,e){super(t),this.#m=e}get value(){return this.#m}toString(){return this.#m.toString()}}export class RealLiteral extends PrimitiveLiteral{#m;constructor(t,e){super(t),this.#m=e}get value(){return this.#m}toString(){return this.#m.toString()}}export class BoolLiteral extends PrimitiveLiteral{#m;constructor(t,e){super(t),this.#m=e}get value(){return this.#m}toString(){return this.#m?"true":"false"}}export class ByteArrayLiteral extends PrimitiveLiteral{#w;constructor(t,e){super(t),this.#w=e}get bytes(){return this.#w}toString(){return`#${bytesToHex(this.#w)}`}}export class StringLiteral extends PrimitiveLiteral{#m;constructor(t,e){super(t),this.#m=e}get value(){return this.#m}toString(){return`"${this.#m.toString()}"`}}export class IR{#T;#d;constructor(t,e=null){assert(!(Array.isArray(t)&&t.some((t=>null==t))),"some items undefined"),this.#T=t,this.#d=e}get content(){return this.#T}get site(){return this.#d}static new(t,...e){if("string"==typeof t){if(0==e.length)return new IR(t);if(1==e.length&&e[0]instanceof Site){const n=e[0];if(n instanceof Site)return new IR(t,n);throw new Error("unexpected second argument")}throw new Error("unexpected second argument")}if("raw"in t){const n=t.raw.slice();let r=[],s=null;n.length>0&&""==n[n.length-1]&&e.length>0&&e[e.length-1]instanceof Site&&(n.pop(),s=assertClass(e.pop(),Site));let a="";for(let t of n){a+=t;const n=e.shift();if(n instanceof Site)r.push(new IR(a,n)),a="";else if(n instanceof IR)""!=a&&(r.push(new IR(a)),a=""),r.push(n);else if(Array.isArray(n))""!=a&&(r.push(new IR(a)),a=""),n.forEach((t=>r.push(t)));else if("string"==typeof n||"number"==typeof n)a+=n.toString();else{if(null!=n)throw new Error("unexpected second argument");""!=a&&(r.push(new IR(a)),a="")}}return assert(0==e.length),""!=a&&r.push(new IR(a)),new IR(r,s)}if(Array.isArray(t)){let n=[];for(let e of t)n.push(e);if(0==e.length)return new IR(n);if(1==e.length){const t=e[0];if(t instanceof Site)return new IR(n,t);throw new Error("unexpected second argument")}throw new Error("unexpected second argument")}throw new Error("unexpected first argument")}dump(){return"string"==typeof this.#T?this.#T:this.#T.map((t=>t.dump()))}flatten(){if("string"==typeof this.#T)return[this];{let t=[];for(let e of this.#T)t=t.concat(e.flatten());return t}}join(t){if("string"==typeof this.#T)return this;{const e=[];for(let n=0;n<this.#T.length;n++)e.push(this.#T[n]),n<this.#T.length-1&&e.push(new IR(t));return new IR(e)}}toString(){return this.flatten().map((t=>"string"==typeof t.content?t.content:"")).join("")}generateSource(){const t=this.flatten(),e=[],n=[];let r=0;for(let s of t){const t=s.content;if("string"!=typeof t)throw new Error("expected IR to contain only strings after flatten");{const a=s.site;if(null!==a){const t=[r,a];n.push(t)}const i=replaceTabs(t);r+=i.length,e.push(i)}}return[e.join(""),n]}pretty(){const[t,e]=this.generateSource();return new Source(t,"").pretty()}includes(t){return"string"==typeof this.#T?this.#T.includes(t):this.#T.some((e=>e.includes(t)))}replace(t,e){return"string"==typeof this.#T?new IR(this.#T.replace(t,e),this.#d):new IR(this.#T.map((n=>n.replace(t,e)),this.#d))}search(t,e){if("string"==typeof this.#T){const n=this.#T.match(t);if(n)for(let t of n)e(t)}else this.#T.forEach((n=>n.search(t,e)))}static wrapWithDefinitions(t,e){const n=Array.from(e.keys()).reverse();let r=t;for(let t of n){const n=e.get(t);if(void 0===n)throw new Error("unexpected");r=new IR([new IR("("),new IR(t),new IR(") -> {\n"),r,new IR(`\n}(\n${TAB}\n${TAB}`),n,new IR("\n)")])}return r}}export const RE_IR_PARAMETRIC_NAME=/[a-zA-Z_][a-zA-Z_0-9]*[[][a-zA-Z_0-9@[\]]*/g;export const TTPP="__T";export const FTPP="__F";const RE_TEMPLATE_NAME=new RegExp(`\\b(${TTPP}|${FTPP})[0-9]*\\b`);export class IRParametricName{#b;#x;#I;#E;constructor(t,e,n="",r=[]){this.#b=t,this.#x=e,this.#I=n,this.#E=r}static newTemplate(t,e,n="",r=0){return new IRParametricName(t,new Array(e).map(((t,e)=>`${TTPP}${e}`)),n,new Array(r).map(((t,e)=>`${FTPP}${e}`)))}get ttp(){return this.#x}get ftp(){return this.#E}get base(){return this.#b}get fn(){return this.#I}toImplementation(t,e=[]){return assert(t.length==this.#x.length,`expected ${this.#x.length} type parameters, got ${t.length} (in ${this.toString()})`),assert(e.length==this.#E.length,`expected ${this.#E.length} function type parameters, got ${e.length} (in ${this.toString()})`),new IRParametricName(this.#b,t,this.#I,e)}toString(){return`${this.#b}${this.#x.length>0?`[${this.#x.join("@")}]`:""}${this.#I}${this.#E.length>0?`[${this.#E.join("@")}]`:""}`}toTemplate(t=!1){return t?`${this.#b}${this.#x.length>0?"[]":""}${this.#I}${this.#E.length>0?"[]":""}`:`${this.#b}${this.#x.length>0?`[${this.#x.map(((t,e)=>`${TTPP}${e}`)).join("@")}]`:""}${this.#I}${this.#E.length>0?`[${this.#E.map(((t,e)=>`${FTPP}${e}`)).join("@")}]`:""}`}replaceTemplateNames(t){return this.#x.forEach(((e,n)=>{t=t.replace(new RegExp(`\\b${TTPP}${n}`,"gm"),e)})),this.#E.forEach(((e,n)=>{t=t.replace(new RegExp(`\\b${FTPP}${n}`,"gm"),e)})),t}static matches(t){return!!t.match(RE_IR_PARAMETRIC_NAME)}static isTemplate(t){return!!t.match(RE_TEMPLATE_NAME)}static parse(t,e=!1){let n=0;const r=()=>{let e=t.charAt(n);const r=[];for(;e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"==e||e>="0"&&e<="9";)r.push(e),n++,e=t.charAt(n);return r.join("")},s=()=>{if(n>=t.length)return[];let e=t.charAt(n);assert("["==e,`expected [, got ${e} (in ${t})`);const r=[];let s=[],a=1;for(;a>0;)if(n++,e=t.charAt(n),"["==e)s.push(e),a++;else if("]"==e)a>1?s.push(e):(s.length>0&&r.push(s),s=[]),a--;else if("@"==e)a>1?s.push(e):(assert(s.length>0,"zero chars in group before @"),r.push(s),s=[]);else{if(!(e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"==e||e>="0"&&e<="9"))throw new Error(`unexpected char '${e}' in parametric name '${t}'`);s.push(e)}return n++,r.map((t=>t.join("")))};let a=r(),i=s(),o="",_=[];return n>=t.length?e||([a,o]=(t=>{let e=t.length-1,n=t.charAt(e);assert("_"!=n,"unexpected underscore");let r=0;for(;e>0;)if(e--,n=t.charAt(e),r>=2){if("_"!=n)return[t.slice(0,e+1),t.slice(e+1)];r++}else"_"==n?r++:r=0;throw new Error("bad name format")})(a),_=i,i=[]):(o=r(),n<t.length&&(_=s())),new IRParametricName(a,i,o,_)}}var BLAKE2B_DIGEST_SIZE=32;export function setBlake2bDigestSize(t){BLAKE2B_DIGEST_SIZE=t}function imod32(t){return t>>>0}function irotr(t,e){return imod32(t>>>e|t<<32-e)}function posMod(t,e){const n=t%e;return n<0n?n+e:n}export function randomBytes(t,e){const n=[];for(let r=0;r<e;r++)n.push(Math.floor(256*t())%256);return n}const UINT64_ZERO=[0,0];function uint64FromBytes(t,e=!0){let n,r;return e?(n=t[0]|t[1]<<8|t[2]<<16|t[3]<<24,r=t[4]|t[5]<<8|t[6]<<16|t[7]<<24):(r=t[0]<<24|t[1]<<16|t[2]<<8|t[3],n=t[4]<<24|t[5]<<16|t[6]<<8|t[7]),[imod32(r),imod32(n)]}function uint64FromString(t){const e=parseInt(t.slice(0,8),16),n=parseInt(t.slice(8,16),16);return[imod32(e),imod32(n)]}function uint64ToBytes([t,e],n=!0){const r=[255&e,(65280&e)>>>8,(16711680&e)>>>16,(4278190080&e)>>>24,255&t,(65280&t)>>>8,(16711680&t)>>>16,(4278190080&t)>>>24];return n||r.reverse(),r}function uint64Eq([t,e],[n,r]){return t==n&&e==r}function uint64Not([t,e]){return[imod32(~t),imod32(~e)]}function uint64And([t,e],[n,r]){return[imod32(t&n),imod32(e&r)]}function uint64Xor([t,e],[n,r]){return[imod32(t^n),imod32(e^r)]}function uint64Add([t,e],[n,r]){const s=e+r;let a=t+n;return s>=4294967296&&(a+=1),[imod32(a),imod32(s)]}function uint64Rotr([t,e],n){return 32==n?[e,t]:(n>32&&(n-=32,[t,e]=[e,t]),[imod32(t>>>n|e<<32-n),imod32(e>>>n|t<<32-n)])}function uint64Shiftr([t,e],n){return n>=32?[0,imod32(t>>>n-32)]:[imod32(t>>>n),imod32(e>>>n|t<<32-n)]}class UInt64{high;low;constructor(t,e){this.high=t,this.low=e}static zero(){return new UInt64(0,0)}static fromBytes(t,e=!0){let n,r;return e?(n=t[0]|t[1]<<8|t[2]<<16|t[3]<<24,r=t[4]|t[5]<<8|t[6]<<16|t[7]<<24):(r=t[0]<<24|t[1]<<16|t[2]<<8|t[3],n=t[4]<<24|t[5]<<16|t[6]<<8|t[7]),new UInt64(imod32(r),imod32(n))}static fromString(t){const e=parseInt(t.slice(0,8),16),n=parseInt(t.slice(8,16),16);return new UInt64(imod32(e),imod32(n))}toBytes(t=!0){const e=[255&this.low,(65280&this.low)>>>8,(16711680&this.low)>>>16,(4278190080&this.low)>>>24,255&this.high,(65280&this.high)>>>8,(16711680&this.high)>>>16,(4278190080&this.high)>>>24];return t||e.reverse(),e}eq(t){return this.high==t.high&&this.low==t.low}not(){return new UInt64(~this.high,~this.low)}and(t){return new UInt64(this.high&t.high,this.low&t.low)}xor(t){return new UInt64(imod32(this.high^t.high),imod32(this.low^t.low))}add(t){const e=this.low+t.low;let n=this.high+t.high;return e>=4294967296&&(n+=1),new UInt64(imod32(n),imod32(e))}rotr(t){let e=this.high,n=this.low;return 32==t?new UInt64(n,e):(t>32&&(t-=32,[e,n]=[n,e]),new UInt64(imod32(e>>>t|n<<32-t),imod32(n>>>t|e<<32-t)))}shiftr(t){return t>=32?new UInt64(0,this.high>>>t-32):new UInt64(this.high>>>t,imod32(this.low>>>t|this.high<<32-t))}}function encodeBase32Bytes(t){const e=[],n=new BitReader(t,!1);for(;!n.eof();)e.push(n.readBits(5));return e}function expandBech32HumanReadablePart(t){const e=[];for(let n of t)e.push(n.charCodeAt(0)>>5);e.push(0);for(let n of t)e.push(31&n.charCodeAt(0));return e}function calcBech32Checksum(t,e){const n=1^calcBech32Polymod(expandBech32HumanReadablePart(t).concat(e).concat([0,0,0,0,0,0])),r=[];for(let t=0;t<6;t++)r.push(n>>5*(5-t)&31);return r}function calcBech32Polymod(t){const e=[996825010,642813549,513874426,1027748829,705979059];let n=1;for(let r of t){const t=n>>25;n=(536870911&n)<<5^r;for(let r=0;r<5;r++)t>>r&1&&(n^=e[r])}return n}function hmac(t,e,n,r){for(n=n.length>e?t(n):n.slice();n.length<e;)n.push(0);const s=n.map((t=>54^t));return t(n.map((t=>92^t)).concat(t(s.concat(r))))}const DEFAULT_BASE32_ALPHABET="abcdefghijklmnopqrstuvwxyz234567",BECH32_BASE32_ALPHABET="qpzry9x8gf2tvdw0s3jn54khce6mua7l";export const Crypto={mulberry32:t=>function(){let e=t+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296},rand:t=>Crypto.mulberry32(t),encodeBase32:(t,e=DEFAULT_BASE32_ALPHABET)=>encodeBase32Bytes(t).map((t=>e[t])).join(""),decodeBase32:(t,e=DEFAULT_BASE32_ALPHABET)=>{const n=new BitWriter,r=t.length;for(let s=0;s<r;s++){const a=t[s],i=e.indexOf(a.toLowerCase());if(s==r-1){const t=5*r-8*Math.floor(5*r/8),e=padZeroes(i.toString(2),5);n.write(e.slice(0,5-t))}else{const t=padZeroes(i.toString(2),5);n.write(t)}}return n.finalize(!1)},encodeBech32:(t,e)=>{assert(t.length>0,"human-readable-part must have non-zero length");const n=calcBech32Checksum(t,e=encodeBase32Bytes(e));return t+"1"+e.concat(n).map((t=>BECH32_BASE32_ALPHABET[t])).join("")},decodeBech32:t=>{assert(Crypto.verifyBech32(t),"invalid bech32 addr");const e=t.indexOf("1");assert(-1!=e);const n=t.slice(0,e);t=t.slice(e+1);return[n,Crypto.decodeBase32(t.slice(0,t.length-6),BECH32_BASE32_ALPHABET)]},verifyBech32:t=>{const e=[],n=t.indexOf("1");if(-1==n||0==n)return!1;const r=t.slice(0,n);t=t.slice(n+1);for(let n of t){const t=BECH32_BASE32_ALPHABET.indexOf(n);if(-1==t)return!1;e.push(t)}const s=e.slice(e.length-6),a=calcBech32Checksum(r,e.slice(0,e.length-6));for(let t=0;t<6;t++)if(s[t]!=a[t])return!1;return!0},sha2_256:t=>{const e=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],n=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];function r(t){return irotr(t,17)^irotr(t,19)^t>>>10}t=function(t){const e=8*t.length;let n=t.slice();if(n.push(128),(n.length+8)%64!=0){let t=64-n.length%64-8;t<0&&(t+=64);for(let e=0;e<t;e++)n.push(0)}assert((n.length+8)%64==0,"bad padding");const r=bigIntToBytes(BigInt(e));for(assert(r.length<=8,"input data too big");r.length<8;)r.unshift(0);return n=n.concat(r),n}(t);for(let a=0;a<t.length;a+=64){const i=t.slice(a,a+64),o=new Array(64).fill(0);for(let t=0;t<16;t++)o[t]=i[4*t+0]<<24|i[4*t+1]<<16|i[4*t+2]<<8|i[4*t+3];for(let t=16;t<64;t++)o[t]=imod32(o[t-16]+(irotr(s=o[t-15],7)^irotr(s,18)^s>>>3)+o[t-7]+r(o[t-2]));let _=n[0],l=n[1],u=n[2],c=n[3],p=n[4],h=n[5],d=n[6],m=n[7];for(let t=0;t<64;t++){const n=imod32(m+(irotr(p,6)^irotr(p,11)^irotr(p,25))+(p&h^~p&d)+e[t]+o[t]),r=imod32((irotr(_,2)^irotr(_,13)^irotr(_,22))+(_&l^_&u^l&u));m=d,d=h,h=p,p=imod32(c+n),c=u,u=l,l=_,_=imod32(n+r)}n[0]=imod32(n[0]+_),n[1]=imod32(n[1]+l),n[2]=imod32(n[2]+u),n[3]=imod32(n[3]+c),n[4]=imod32(n[4]+p),n[5]=imod32(n[5]+h),n[6]=imod32(n[6]+d),n[7]=imod32(n[7]+m)}var s;const a=[];for(let t=0;t<8;t++){const e=n[t];a.push(imod8(e>>24)),a.push(imod8(e>>16)),a.push(imod8(e>>8)),a.push(imod8(e|0))}return a},sha2_512:t=>{const e=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],n=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209];function r(t,e,n,r){r=t[e+1]+r,t[e]=t[e]+n+Math.floor(r/4294967296)>>>0,t[e+1]=r>>>0}t=function(t){const e=8*t.length;let n=t.slice();if(n.push(128),(n.length+16)%128!=0){let t=128-n.length%128-16;t<0&&(t+=128);for(let e=0;e<t;e++)n.push(0)}assert((n.length+16)%128==0,"bad padding");const r=bigIntToBytes(BigInt(e));for(assert(r.length<=16,"input data too big");r.length<16;)r.unshift(0);return n=n.concat(r),assert(n.length%128==0,"bad length padding"),n}(t);for(let s=0;s<t.length;s+=128){const a=t.slice(s,s+128),i=new Array(160).fill(0);for(let t=0;t<32;t+=2){const e=a.slice(4*t,4*t+8);i[t+0]=(e[0]<<24|e[1]<<16|e[2]<<8|e[3])>>>0,i[t+1]=(e[4]<<24|e[5]<<16|e[6]<<8|e[7])>>>0}for(let t=32;t<160;t+=2){let e=i[t-30],n=i[t-29];const r=((e>>>1|n<<31)^(e>>>8|n<<24)^e>>>7)>>>0,s=((n>>>1|e<<31)^(n>>>8|e<<24)^(n>>>7|e<<25))>>>0;e=i[t-4],n=i[t-3];const a=((n>>>19|e<<13)^(e>>>29|n<<3)^(n>>>6|e<<26))>>>0;e=(((e>>>19|n<<13)^(n>>>29|e<<3)^e>>>6)>>>0)+i[t-14]+r+i[t-32],n=a+i[t-13]+s+i[t-31],i[t]=e+Math.floor(n/4294967296)>>>0,i[t+1]=n>>>0}let o=n[0],_=n[1],l=n[2],u=n[3],c=n[4],p=n[5],h=n[6],d=n[7],m=n[8],f=n[9],y=n[10],g=n[11],w=n[12],T=n[13],b=n[14],x=n[15];for(let t=0;t<160;t+=2){const n=((o>>>28|_<<4)^(_>>>2|o<<30)^(_>>>7|o<<25))>>>0,r=((_>>>28|o<<4)^(o>>>2|_<<30)^(o>>>7|_<<25))>>>0,s=((m>>>14|f<<18)^(m>>>18|f<<14)^(f>>>9|m<<23))>>>0,a=(o&l^o&c^l&c)>>>0,I=(_&u^_&p^u&p)>>>0,E=(m&y^~m&w)>>>0;let C=x+(((f>>>14|m<<18)^(f>>>18|m<<14)^(m>>>9|f<<23))>>>0)+((f&g^~f&T)>>>0)+e[t+1]+i[t+1],S=b+s+E+e[t]+i[t]+Math.floor(C/4294967296)>>>0;C>>>=0;let v=r+I;const R=n+a+Math.floor(v/4294967296)>>>0;v>>>=0,b=w,x=T,w=y,T=g,y=m,g=f,f=d+C,m=h+S+Math.floor(f/4294967296)>>>0,f>>>=0,h=c,d=p,c=l,p=u,l=o,u=_,_=C+v,o=S+R+Math.floor(_/4294967296)>>>0,_>>>=0}r(n,0,o,_),r(n,2,l,u),r(n,4,c,p),r(n,6,h,d),r(n,8,m,f),r(n,10,y,g),r(n,12,w,T),r(n,14,b,x)}let s=[];for(let t=0;t<16;t+=2){const e=n[t],r=n[t+1],a=[(4278190080&e)>>>24,(16711680&e)>>>16,(65280&e)>>>8,255&e,(4278190080&r)>>>24,(16711680&r)>>>16,(65280&r)>>>8,255&r];s=s.concat(a)}return s},sha3:t=>{const e=136;const n=[6,12,18,24,3,9,10,16,22,1,7,13,19,20,4,5,11,17,23,2,8,14,15,21],r=[-12,-11,21,14,28,20,3,-13,-29,1,6,25,8,18,27,-4,10,15,-24,-30,-23,-7,-9,2],s=[new UInt64(0,1),new UInt64(0,32898),new UInt64(2147483648,32906),new UInt64(2147483648,2147516416),new UInt64(0,32907),new UInt64(0,2147483649),new UInt64(2147483648,2147516545),new UInt64(2147483648,32777),new UInt64(0,138),new UInt64(0,136),new UInt64(0,2147516425),new UInt64(0,2147483658),new UInt64(0,2147516555),new UInt64(2147483648,139),new UInt64(2147483648,32905),new UInt64(2147483648,32771),new UInt64(2147483648,32770),new UInt64(2147483648,128),new UInt64(0,32778),new UInt64(2147483648,2147483658),new UInt64(2147483648,2147516545),new UInt64(2147483648,32896),new UInt64(0,2147483649),new UInt64(2147483648,2147516424)];function a(t){const e=new Array(5),a=new Array(25);for(let i=0;i<24;i++){for(let n=0;n<5;n++)e[n]=t[n].xor(t[n+5]).xor(t[n+10]).xor(t[n+15]).xor(t[n+20]);for(let n=0;n<5;n++){const r=(n+1)%5,s=e[(n+4)%5].xor(e[r].rotr(63));for(let e=0;e<5;e++)t[n+5*e]=t[n+5*e].xor(s)}a[0]=t[0];for(let e=1;e<25;e++){const s=n[e-1],i=32-Math.abs(r[e-1]);a[e]=r[e-1]<0?t[s].rotr(i):t[s].rotr(i+32)}for(let e=0;e<5;e++)for(let n=0;n<5;n++)t[5*e+n]=a[5*e+n].xor(a[5*e+(n+1)%5].not().and(a[5*e+(n+2)%5]));t[0]=t[0].xor(s[i])}}t=function(t){const n=t.slice();let r=134-n.length%e;if(r<-1&&(r+=134),-1==r)n.push(134);else{n.push(6);for(let t=0;t<r;t++)n.push(0);n.push(128)}return assert(n.length%e==0),n}(t);const i=new Array(25).fill(UInt64.zero());for(let n=0;n<t.length;n+=e){const r=t.slice(n,n+e).concat(new Array(64).fill(0));for(let t=0;t<200;t+=8)i[t/8]=i[t/8].xor(UInt64.fromBytes(r.slice(t,t+8)));a(i)}let o=[];for(let t=0;t<4;t++)o=o.concat(i[t].toBytes());return o},blake2b:(t,e=BLAKE2B_DIGEST_SIZE)=>{const n=128,r=[new UInt64(1779033703,4089235720),new UInt64(3144134277,2227873595),new UInt64(1013904242,4271175723),new UInt64(2773480762,1595750129),new UInt64(1359893119,2917565137),new UInt64(2600822924,725511199),new UInt64(528734635,4215389547),new UInt64(1541459225,327033209)],s=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],[14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3],[11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4],[7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8],[9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13],[2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9],[12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11],[13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10],[6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5],[10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0]];function a(t,e,n,r,s,a,i,o){const _=e[i],l=e[o];t[n]=t[n].add(t[r]).add(_),t[a]=t[a].xor(t[n]).rotr(32),t[s]=t[s].add(t[a]),t[r]=t[r].xor(t[s]).rotr(24),t[n]=t[n].add(t[r]).add(l),t[a]=t[a].xor(t[n]).rotr(16),t[s]=t[s].add(t[a]),t[r]=t[r].xor(t[s]).rotr(63)}function i(t,e,n,i){const o=t.slice().concat(r.slice());o[12]=o[12].xor(new UInt64(0,imod32(n))),i&&(o[14]=o[14].xor(new UInt64(4294967295,4294967295)));for(let t=0;t<12;t++){const n=s[t%10];for(let t=0;t<4;t++)a(o,e,t,t+4,t+8,t+12,n[2*t],n[2*t+1]);for(let t=0;t<4;t++)a(o,e,t,(t+1)%4+4,(t+2)%4+8,(t+3)%4+12,n[8+2*t],n[8+2*t+1])}for(let e=0;e<8;e++)t[e]=t[e].xor(o[e].xor(o[e+8]))}const o=t.length;t=function(t){const e=t.slice(),r=0==e.length?n:(n-e.length%n)%n;for(let t=0;t<r;t++)e.push(0);return e}(t);const _=r.slice(),l=new Uint8Array(64);l[0]=e,l[1]=0,l[2]=1,l[3]=1;const u=new DataView(l.buffer);for(let t=0;t<8;t++)_[t]=_[t].xor(new UInt64(u.getUint32(8*t+4,!0),u.getUint32(8*t,!0)));for(let e=0;e<t.length;e+=n){const r=e+n,s=t.slice(e,e+n),a=new Array(16);for(let t=0;t<n;t+=8)a[t/8]=UInt64.fromBytes(s.slice(t,t+8));e==t.length-n?i(_,a,o,!0):i(_,a,r,!1)}let c=[];for(let t=0;t<e/8;t++)c=c.concat(_[t].toBytes());return c.slice(0,e)},hmacSha2_256:(t,e)=>hmac((t=>Crypto.sha2_256(t)),64,t,e),hmacSha2_512:(t,e)=>hmac((t=>Crypto.sha2_512(t)),128,t,e),pbkdf2:(t,e,n,r,s)=>{const a=(t,e)=>{const n=new Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n};let i=[],o=1n;for(;i.length<s;){const s=bigIntToBytes(o);for(;s.length<4;)s.unshift(0);let _=t(e,n.slice().concat(s)),l=_;for(let n=1;n<r;n++)_=t(e,_),l=a(l,_);i=i.concat(l),o+=1n}return i.length>s&&(i=i.slice(0,s)),i}};const ED25519_Q=57896044618658097711785492504343953926634992332820282019728792003956564819949n,ED25519_Q38=7237005577332262213973186563042994240829374041602535252466099000494570602494n,ED25519_CURVE_ORDER=7237005577332262213973186563042994240857116359379907606001950938285454250989n,ED25519_D=-4513249062541557337682894930092624173785641285191125241628941591882900924598840740n,ED25519_I=19681161376707505956807079304988542015446066515923890162744021073123829784752n;function expMod(t,e,n){if(0n==e)return 1n;{let r=expMod(t,e/2n,n);return r=r*r%n,e%2n!=0n&&(r=posMod(r*t,n)),r}}function curveMod(t){return posMod(t,ED25519_Q)}function curveInvert(t){let e=curveMod(t),n=ED25519_Q,r=0n,s=1n,a=1n,i=0n;for(;0n!==e;){const t=n/e,o=n%e,_=r-a*t,l=s-i*t;n=e,e=o,r=a,s=i,a=_,i=l}return curveMod(r)}function recoverX(t){const e=t*t,n=(e-1n)*curveInvert(ED25519_D*e+1n);let r=expMod(n,ED25519_Q38,ED25519_Q);return(r*r-n)%ED25519_Q!=0n&&(r=r*ED25519_I%ED25519_Q),r%2n!=0n&&(r=ED25519_Q-r),r}function encodeCurveInt(t){return bigIntToLe32Bytes(t)}function decodeCurveInt(t){return leBytesToBigInt(t)}function getBit(t,e){return t[Math.floor(e/8)]>>e%8&1}class AffinePoint{#C;#S;constructor(t,e){this.#C=t,this.#S=e}static get BASE(){return new AffinePoint(15112221349535400772501151409588531511454012693041857206046113283949847762202n,46316835694926478169428394003475163141307993866256225615783033603165251855960n)}static get ZERO(){return new AffinePoint(0n,1n)}static decode(t){assert(32==t.length);const e=t.slice();e[31]=127&e[31];const n=decodeCurveInt(e);let r=recoverX(n);Number(1n&r)!=getBit(t,255)&&(r=ED25519_Q-r);const s=new AffinePoint(r,n);return assert(s.isOnCurve(),"point isn't on curve"),s}get x(){return this.#C}get y(){return this.#S}add(t){const e=this.#C,n=this.#S,r=t.#C,s=t.#S,a=ED25519_D*e*r*n*s,i=(e*s+r*n)*curveInvert(1n+a),o=(n*s+e*r)*curveInvert(1n-a);return new AffinePoint(curveMod(i),curveMod(o))}equals(t){return this.x==t.x&&this.y==t.y}isOnCurve(){const t=this.#C,e=this.#S,n=t*t,r=e*e;return(-n+r-1n-ED25519_D*n*r)%ED25519_Q==0n}mul(t){if(0n==t)return AffinePoint.ZERO;{let e=this.mul(t/2n);return e=e.add(e),t%2n!=0n&&(e=e.add(this)),e}}encode(){const t=encodeCurveInt(this.#S);return t[31]=255&t[31]|128*Number(1n&this.#C),t}}class ExtendedPoint{#C;#S;#v;#R;constructor(t,e,n,r){this.#C=t,this.#S=e,this.#v=n,this.#R=r}static get BASE(){return new ExtendedPoint(AffinePoint.BASE.x,AffinePoint.BASE.y,1n,curveMod(AffinePoint.BASE.x*AffinePoint.BASE.y))}static get ZERO(){return new ExtendedPoint(0n,1n,1n,0n)}static decode(t){return ExtendedPoint.fromAffine(AffinePoint.decode(t))}static fromAffine(t){return new ExtendedPoint(t.x,t.y,1n,curveMod(t.x*t.y))}add(t){const e=this.#C,n=this.#S,r=this.#v,s=this.#R,a=t.#C,i=t.#S,o=t.#v,_=t.#R,l=curveMod(e*a),u=curveMod(n*i),c=curveMod(ED25519_D*s*_),p=curveMod(r*o),h=curveMod((e+n)*(a+i)-l-u),d=curveMod(p-c),m=curveMod(p+c),f=curveMod(l+u),y=curveMod(h*d),g=curveMod(m*f),w=curveMod(d*m),T=curveMod(h*f);return new ExtendedPoint(y,g,w,T)}encode(){return this.toAffine().encode()}equals(t){return curveMod(this.#C*t.#v)==curveMod(t.#C*this.#v)&&curveMod(this.#S*t.#v)==curveMod(t.#S*this.#v)}isBase(){return this.equals(ExtendedPoint.BASE)}isZero(){return this.equals(ExtendedPoint.ZERO)}mul(t){if(0n==t)return ExtendedPoint.ZERO;{let e=this.mul(t/2n);return e=e.add(e),t%2n!=0n&&(e=e.add(this)),e}}toAffine(){if(this.isZero())return AffinePoint.ZERO;{const t=curveInvert(this.#v);return new AffinePoint(curveMod(this.#C*t),curveMod(this.#S*t))}}}function clamp(t){const e=t.slice(0,32);return e[0]&=248,e[31]&=63,e[31]|=64,decodeCurveInt(e)}function nonce(t){return decodeCurveInt(Crypto.sha2_512(t))}const CurvePointImpl=ExtendedPoint;export const Ed25519={deriveBip32PublicKey:t=>{const e=clamp(t);return CurvePointImpl.BASE.mul(e).encode()},derivePublicKey:t=>Ed25519.deriveBip32PublicKey(Crypto.sha2_512(t)),signBip32:(t,e)=>{const n=clamp(e),r=CurvePointImpl.BASE.mul(n).encode(),s=nonce(e.slice(32,64).concat(t)),a=CurvePointImpl.BASE.mul(s).encode(),i=posMod(s+nonce(a.concat(r).concat(t))*n,ED25519_CURVE_ORDER);return a.concat(encodeCurveInt(i))},sign:(t,e)=>Ed25519.signBip32(t,Crypto.sha2_512(e)),verify:(t,e,n)=>{if(64!=t.length)throw new Error(`unexpected signature length ${t.length}`);if(32!=n.length)throw new Error(`unexpected publickey length ${n.length}`);const r=CurvePointImpl.decode(t.slice(0,32)),s=CurvePointImpl.decode(n),a=decodeCurveInt(t.slice(32,64)),i=nonce(t.slice(0,32).concat(n).concat(e)),o=CurvePointImpl.BASE.mul(a),_=r.add(s.mul(i));return o.equals(_)}};export const BIP39_DICT_EN=["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"];export class CborData{constructor(){}toCbor(){throw new Error("not yet implemented")}toCborHex(){return bytesToHex(this.toCbor())}}export const Cbor={encodeHead:(t,e)=>{if(e<=23n)return[32*t+Number(e)];if(e>=24n&&e<=255n)return[32*t+24,Number(e)];if(e>=256n&&e<=65535n)return[32*t+25,Number(e/256n%256n),Number(e%256n)];if(e>=65536n&&e<=4294967295n){const n=bigIntToBytes(e);for(;n.length<4;)n.unshift(0);return[32*t+26].concat(n)}if(e>=4294967296n&&e<=18446744073709551615n){const n=bigIntToBytes(e);for(;n.length<8;)n.unshift(0);return[32*t+27].concat(n)}throw new Error("n out of range")},decodeHead:t=>{if(0==t.length)throw new Error("empty cbor head");const e=assertDefined(t.shift());if(e%32<=23)return[idiv(e,32),BigInt(e%32)];if(e%32==24)return[idiv(e,32),bytesToBigInt(t.splice(0,1))];if(e%32==25)return[idiv(e,32),bytesToBigInt(t.splice(0,2))];if(e%32==26)return[idiv(e,32),bytesToBigInt(t.splice(0,4))];if(e%32==27)return[idiv(e,32),bytesToBigInt(t.splice(0,8))];throw new Error("bad header")},encodeIndefHead:t=>[32*t+31],decodeIndefHead:t=>idiv(assertDefined(t.shift())-31,32),isNull:t=>246==t[0],encodeNull:()=>[246],decodeNull:t=>{if(246!=assertDefined(t.shift()))throw new Error("not null")},encodeBool:t=>t?[245]:[244],decodeBool:t=>{const e=assertDefined(t.shift());if(245==e)return!0;if(244==e)return!1;throw new Error("unexpected non-boolean cbor object")},isBytes:t=>Cbor.isDefBytes(t)||Cbor.isIndefBytes(t),isDefBytes:t=>{if(0==t.length)throw new Error("empty cbor bytes");const[e,n]=Cbor.decodeHead(t.slice(0,9));return 2==e},isIndefBytes:t=>{if(0==t.length)throw new Error("empty cbor bytes");return 95==t[0]},encodeBytes:(t,e=!1)=>{if((t=t.slice()).length<=64||!e){return Cbor.encodeHead(2,BigInt(t.length)).concat(t)}{let e=Cbor.encodeIndefHead(2);for(;t.length>0;){const n=t.splice(0,64);e=e.concat(Cbor.encodeHead(2,BigInt(n.length))).concat(n)}return e.push(255),e}},decodeBytes:t=>{if(assert(t.length>0),Cbor.isIndefBytes(t)){t.shift();let e=[];for(;255!=t[0];){const[n,r]=Cbor.decodeHead(t);if(r>64n)throw new Error("bytearray chunk too large");e=e.concat(t.splice(0,Number(r)))}return assert(255==t.shift()),e}{const[e,n]=Cbor.decodeHead(t);return t.splice(0,Number(n))}},isUtf8:t=>{const[e,n]=Cbor.decodeHead(t.slice());return 3==e},encodeUtf8:(t,e=!1)=>{const n=textToBytes(t);if(e&&n.length>64){const t=[];let e=0;for(;e<n.length;){let r,s=64;for(;;)try{r=n.slice(e,e+s),bytesToText(r);break}catch(t){s--}t.push(Cbor.encodeHead(3,BigInt(r.length)).concat(r)),e+=r.length}return Cbor.encodeDefList(t)}return Cbor.encodeHead(3,BigInt(n.length)).concat(n)},decodeUtf8Internal:t=>{const[e,n]=Cbor.decodeHead(t);return assert(3===e),bytesToText(t.splice(0,Number(n)))},decodeUtf8:t=>{if(assert(t.length>0),Cbor.isDefList(t)){let e="";return Cbor.decodeList(t,((t,n)=>{e+=Cbor.decodeUtf8Internal(n)})),e}return Cbor.decodeUtf8Internal(t)},encodeInteger:t=>t>=0n&&t<=(2n<<63n)-1n?Cbor.encodeHead(0,t):t>=2n<<63n?Cbor.encodeHead(6,2n).concat(Cbor.encodeBytes(bigIntToBytes(t))):t<=-1n&&t>=-(2n<<63n)?Cbor.encodeHead(1,-t-1n):Cbor.encodeHead(6,3n).concat(Cbor.encodeBytes(bigIntToBytes(-t-1n))),decodeInteger:t=>{const[e,n]=Cbor.decodeHead(t);if(0==e)return n;if(1==e)return-n-1n;if(6==e){if(2n==n){return bytesToBigInt(Cbor.decodeBytes(t))}if(3n==n){return-bytesToBigInt(Cbor.decodeBytes(t))-1n}throw new Error(`unexpected tag n:${n}`)}throw new Error(`unexpected tag m:${e}`)},isIndefList:t=>{if(0==t.length)throw new Error("empty cbor bytes");return 159==t[0]},encodeIndefListStart:()=>Cbor.encodeIndefHead(4),encodeListInternal:t=>{let e=[];for(let n of t)e=n instanceof CborData?e.concat(n.toCbor()):e.concat(n);return e},encodeIndefListEnd:()=>[255],encodeList:t=>t.length?Cbor.encodeIndefList(t):Cbor.encodeDefList(t),encodeIndefList:t=>Cbor.encodeIndefListStart().concat(Cbor.encodeListInternal(t)).concat(Cbor.encodeIndefListEnd()),isDefList:t=>{try{const[e,n]=Cbor.decodeHead(t.slice(0,9));return 4==e}catch(t){if(t.message.includes("bad header"))return!1;throw t}},encodeDefListStart:t=>Cbor.encodeHead(4,t),encodeDefList:t=>Cbor.encodeDefListStart(BigInt(t.length)).concat(Cbor.encodeListInternal(t)),isList:t=>Cbor.isIndefList(t)||Cbor.isDefList(t),decodeList:(t,e)=>{if(Cbor.isIndefList(t)){assert(4==Cbor.decodeIndefHead(t));let n=0;for(;255!=t[0];)e(n,t),n++;assert(255==t.shift())}else{const[n,r]=Cbor.decodeHead(t);assert(4==n);for(let n=0;n<Number(r);n++)e(n,t)}},isTuple:t=>Cbor.isIndefList(t)||Cbor.isDefList(t),encodeTuple:t=>Cbor.encodeDefList(t),decodeTuple:(t,e)=>{let n=0;return Cbor.decodeList(t,((t,r)=>{e(n,r),n++})),n},isMap:t=>{const[e,n]=Cbor.decodeHead(t.slice(0,9));return 5==e},encodeMapInternal:t=>{let e=[];for(let n of t){const t=n[0],r=n[1];e=t instanceof CborData?e.concat(t.toCbor()):e.concat(t),e=r instanceof CborData?e.concat(r.toCbor()):e.concat(r)}return e},encodeMap:t=>Cbor.encodeHead(5,BigInt(t.length)).concat(Cbor.encodeMapInternal(t)),decodeMap:(t,e)=>{const[n,r]=Cbor.decodeHead(t);assert(5==n);for(let n=0;n<r;n++)e(n,t)},isObject:t=>Cbor.isMap(t),encodeObject:t=>Cbor.encodeMap(Array.from(t.entries()).map((t=>[Cbor.encodeInteger(BigInt(t[0])),t[1]]))),decodeObject:(t,e)=>{const n=new Set;return Cbor.decodeMap(t,((t,r)=>{let s=Number(Cbor.decodeInteger(r));e(s,r),n.add(s)})),n},encodeTag:t=>Cbor.encodeHead(6,t),decodeTag:t=>{const[e,n]=Cbor.decodeHead(t);return assert(6==e),n},isConstr:t=>{if(0==t.length)throw new Error("empty cbor bytes");const[e,n]=Cbor.decodeHead(t.slice(0,9));return 6==e},encodeConstrTag:t=>t>=0&&t<=6?Cbor.encodeHead(6,121n+BigInt(t)):t>=7&&t<=127?Cbor.encodeHead(6,1280n+BigInt(t-7)):Cbor.encodeHead(6,102n).concat(Cbor.encodeHead(4,2n)).concat(Cbor.encodeInteger(BigInt(t))),encodeConstr:(t,e)=>Cbor.encodeConstrTag(t).concat(Cbor.encodeList(e)),decodeConstrTag:t=>{const[e,n]=Cbor.decodeHead(t);if(assert(6==e),n<127n)return Number(n-121n);if(102n==n){const[e,n]=Cbor.decodeHead(t);return assert(4==e&&2n==n),Number(Cbor.decodeInteger(t))}return Number(n-1280n+7n)},decodeConstr:(t,e)=>{const n=Cbor.decodeConstrTag(t);return Cbor.decodeList(t,e),n}};const UPLC_DATA_NODE_MEM_SIZE=4;export class UplcData extends CborData{constructor(){super()}transfer(t){throw new Error("not yet implemented")}get memSize(){throw new Error("not yet implemented")}isSame(t){return this.toSchemaJson()==t.toSchemaJson()}get bytes(){throw new Error("not a bytearray")}get int(){throw new Error("not an int")}get index(){throw new Error("not a constr")}get fields(){throw new Error("not a constr")}get list(){throw new Error("not a list")}get map(){throw new Error("not a map")}toString(){throw new Error("not yet implemented")}toIR(){throw new Error("not yet implemented")}toSchemaJson(){throw new Error("not yet implemented")}static fromCbor(t){return"string"==typeof t?UplcData.fromCbor(hexToBytes(t)):Cbor.isList(t)?ListData.fromCbor(t):Cbor.isIndefBytes(t)||Cbor.isDefBytes(t)?ByteArrayData.fromCbor(t):Cbor.isMap(t)?MapData.fromCbor(t):Cbor.isConstr(t)?ConstrData.fromCbor(t):IntData.fromCbor(t)}}export class IntData extends UplcData{#m;constructor(t){super(),this.#m=t}transfer(t){return t.transferIntData(this.#m)}get value(){return this.#m}get int(){return this.#m}static memSizeInternal(t){if(0n==t)return 1;{const e=t>0n?t:-t;return Math.floor(Math.floor(Math.log2(Number(e)))/64)+1}}get memSize(){return 4+IntData.memSizeInternal(this.#m)}toString(){return this.#m.toString()}toIR(){return new IR(`__core__iData(${this.#m.toString()})`)}toSchemaJson(){return`{"int": ${this.#m.toString()}}`}toCbor(){return Cbor.encodeInteger(this.#m)}static fromCbor(t){return new IntData(Cbor.decodeInteger(t))}}export class ByteArrayData extends UplcData{#w;constructor(t){super(),this.#w=t}static fromString(t){let e=textToBytes(t);return new ByteArrayData(e)}transfer(t){return t.transferByteArrayData(this.#w)}get bytes(){return this.#w.slice()}static memSizeInternal(t){const e=t.length;return 0===e?1:Math.floor((e-1)/8)+1}get memSize(){return 4+ByteArrayData.memSizeInternal(this.#w)}toHex(){return bytesToHex(this.#w)}get hex(){return this.toHex()}toString(){return`#${this.toHex()}`}toIR(){return new IR(`__core__bData(#${this.toHex()})`)}toSchemaJson(){return`{"bytes": "${this.toHex()}"}`}toCbor(){return Cbor.encodeBytes(this.#w,!0)}static fromCbor(t){return new ByteArrayData(Cbor.decodeBytes(t))}static comp(t,e){function n(){return function(){for(let n=0;n<Math.min(t.length,e.length);n++)if(t[n]!=e[n])return t[n]<e[n];return t.length<e.length}()?-1:1}if(t.length!=e.length)return n();for(let r=0;r<t.length;r++)if(t[r]!=e[r])return n();return 0}static compLengthFirst(t,e){if(t.length!=e.length)return t.length<e.length?-1:1;for(let n=0;n<t.length;n++)if(t[n]!=e[n])return t[n]<e[n]?-1:1;return 0}}export class ListData extends UplcData{#P;constructor(t){super(),assert(t.every((t=>t instanceof UplcData)),"expected exclusively UplcData items"),this.#P=t}transfer(t){return t.transferListData(this.#P.map((e=>e.transfer(t))))}get list(){return this.#P.slice()}get memSize(){let t=4;for(let e of this.#P)t+=e.memSize;return t}toString(){return`[${this.#P.map((t=>t.toString())).join(", ")}]`}toIR(){let t=new IR("__core__mkNilData(())");for(let e=this.#P.length-1;e>=0;e--)t=new IR([new IR("__core__mkCons("),this.#P[e].toIR(),new IR(", "),t,new IR(")")]);return new IR([new IR("__core__listData("),t,new IR(")")])}toSchemaJson(){return`{"list":[${this.#P.map((t=>t.toSchemaJson())).join(", ")}]}`}toCbor(){return Cbor.encodeList(this.#P)}static fromCbor(t){let e=[];return Cbor.decodeList(t,((t,n)=>{e.push(UplcData.fromCbor(n))})),new ListData(e)}}export class MapData extends UplcData{#D;constructor(t){super(),this.#D=t}transfer(t){return t.transferMapData(this.#D.map((([e,n])=>[e.transfer(t),n.transfer(t)])))}get map(){return this.#D.slice()}get memSize(){let t=4;for(let[e,n]of this.#D)t+=e.memSize+n.memSize;return t}toString(){return`{${this.#D.map((([t,e])=>`${t.toString()}: ${e.toString()}`)).join(", ")}}`}toIR(){let t=new IR("__core__mkNilPairData(())");for(let e=this.#D.length-1;e>=0;e--){const n=this.#D[e][0].toIR(),r=this.#D[e][1].toIR();t=new IR([new IR("__core__mkCons(__core__mkPairData("),n,new IR(", "),r,new IR(", "),new IR(")"),new IR(", "),t,new IR(")")])}return new IR([new IR("__core__mapData("),t,new IR(")")])}toSchemaJson(){return`{"map": [${this.#D.map((t=>'{"k": '+t[0].toSchemaJson()+', "v": '+t[1].toSchemaJson()+"}")).join(", ")}]}`}toCbor(){return Cbor.encodeMap(this.#D)}static fromCbor(t){let e=[];return Cbor.decodeMap(t,((t,n)=>{e.push([UplcData.fromCbor(n),UplcData.fromCbor(n)])})),new MapData(e)}}export class ConstrData extends UplcData{#F;#y;constructor(t,e){super(),assert(e.every((t=>t instanceof UplcData)),"expected exclusively UplcData fields"),this.#F=t,this.#y=e}transfer(t){return t.transferConstrData(this.#F,this.#y.map((e=>e.transfer(t))))}get index(){return this.#F}get fields(){return this.#y.slice()}get memSize(){let t=4;for(let e of this.#y)t+=e.memSize;return t}toString(){let t=this.#y.map((t=>t.toString()));return`${this.#F.toString()}{${t.join(", ")}}`}toIR(){let t=new IR("__core__mkNilData(())");for(let e=this.#y.length-1;e>=0;e--)t=new IR([new IR("__core__mkCons("),this.#y[e].toIR(),new IR(", "),t,new IR(")")]);return new IR([new IR("__core__constrData("),new IR(this.#F.toString()),new IR(", "),t,new IR(")")])}toSchemaJson(){return`{"constructor": ${this.#F.toString()}, "fields": [${this.#y.map((t=>t.toSchemaJson())).join(", ")}]}`}toCbor(){return Cbor.encodeConstr(this.#F,this.#y)}static fromCbor(t){let e=[],n=Cbor.decodeConstr(t,((t,n)=>{e.push(UplcData.fromCbor(n))}));return new ConstrData(n,e)}}export class HeliosData extends CborData{constructor(){super()}_toUplcData(){throw new Error("not yet implemented")}toSchemaJson(){return this._toUplcData().toSchemaJson()}toCbor(){return this._toUplcData().toCbor()}static isBuiltin(){return!0}}export class HInt extends HeliosData{#m;static cleanConstructorArg(t){const e=BigInt(t);if(e.toString()!=t.toString())throw new Error("not a valid integer");return e}constructor(t){super(),this.#m=HInt.cleanConstructorArg(t)}toString(){return this.#m.toString()}static fromProps(t){return t instanceof HInt?t:new HInt(t)}get value(){return this.#m}_toUplcData(){return new IntData(this.#m)}static fromUplcData(t){return new HInt(t.int)}static fromUplcCbor(t){return HInt.fromUplcData(UplcData.fromCbor(t))}static fromCbor(t){return new HInt(Cbor.decodeInteger(t))}toCbor(){return Cbor.encodeInteger(this.value)}dump(){return this.#m.toString()}eq(t){return this.#m==HInt.fromProps(t).#m}neq(t){return this.#m!=HInt.fromProps(t).value}ge(t){return this.#m>=HInt.fromProps(t).#m}gt(t){return this.#m>HInt.fromProps(t).#m}le(t){return this.#m<=HInt.fromProps(t).#m}lt(t){return this.#m<HInt.fromProps(t).#m}add(t){return new HInt(this.#m+HInt.fromProps(t).#m)}sub(t){return new HInt(this.#m-HInt.fromProps(t).#m)}mul(t){return new HInt(this.#m*HInt.fromProps(t).#m)}}export class Time extends HInt{static cleanConstructorArg(t){if(t instanceof Date)return BigInt(t.getTime());if("string"==typeof t)return BigInt(Date.parse(t));{const e=BigInt(t);if(e.toString()!=t.toString())throw new Error("not a valid integer");return e}}constructor(t){super(Time.cleanConstructorArg(t))}static fromProps(t){return t instanceof Time?t:new Time(t)}static fromUplcData(t){return new Time(t.int)}static fromUplcCbor(t){return Time.fromUplcData(UplcData.fromCbor(t))}}export class Duration extends HInt{static fromProps(t){return t instanceof Duration?t:new Duration(t)}static fromUplcData(t){return new Duration(t.int)}static fromUplcCbor(t){return Duration.fromUplcData(UplcData.fromCbor(t))}}export class Bool extends HeliosData{#m;static cleanConstructorArg(t){if("string"==typeof t){if("false"==t)return!1;if("true"==t)return!0;throw new Error("not a valid string representation of a Bool")}if("boolean"==typeof t)return t;throw new Error("can't convert to boolean")}constructor(t){super(),this.#m=Bool.cleanConstructorArg(t)}static fromProps(t){return t instanceof Bool?t:new Bool(t)}get bool(){return this.#m}_toUplcData(){return new ConstrData(this.#m?1:0,[])}static fromUplcData(t){if(assert(0==t.fields.length,"bool data can't have fields"),0==t.index)return new Bool(!1);if(1==t.index)return new Bool(!0);throw new Error("expected 0 or 1 for ConstrData representing Bool")}static fromUplcCbor(t){return Bool.fromUplcData(UplcData.fromCbor(t))}}export class HString extends HeliosData{#m;constructor(t){super(),this.#m=t}static fromProps(t){return t instanceof HString?t:new HString(t)}get string(){return this.#m}_toUplcData(){return new ByteArrayData(textToBytes(this.#m))}static fromUplcData(t){return new HString(bytesToText(t.bytes))}static fromUplcCbor(t){return HString.fromUplcData(UplcData.fromCbor(t))}}export class ByteArray extends HeliosData{#w;static cleanConstructorArg(t){if(Array.isArray(t))return t;if("string"==typeof t)return t.startsWith("#")&&(t=t.slice(1)),hexToBytes(t);throw new Error("unexpected bytes type")}constructor(t){super(),this.#w=ByteArray.cleanConstructorArg(t)}static fromProps(t){return t instanceof ByteArray?t:new ByteArray(t)}get bytes(){return this.#w}get hex(){return bytesToHex(this.#w)}_toUplcData(){return new ByteArrayData(this.#w)}toCbor(){return Cbor.encodeBytes(this.#w)}static fromUplcData(t){return new ByteArray(t.bytes)}static fromUplcCbor(t){return ByteArray.fromUplcData(UplcData.fromCbor(t))}static fromCbor(t){return new ByteArray(Cbor.decodeBytes(t))}eq(t){return eq(this.#w,ByteArray.fromProps(t).#w)}}export function HList(t){assert(!new.target,"List can't be called with new"),assert(t.prototype instanceof HeliosData);const e=`[]${t.name}`;class n extends HeliosData{#P;constructor(e){super(),this.#P=e.map((e=>e instanceof t?e:new t(e)))}get _listTypeName(){return e}static[Symbol.hasInstance](t){return t._listTypeName===e&&t instanceof HeliosData}get items(){return this.#P}_toUplcData(){return new ListData(this.#P.map((t=>t._toUplcData())))}static fromUplcData(e){return new n(e.list.map((e=>t.fromUplcData(e))))}static fromUplcCbor(t){return n.fromUplcData(UplcData.fromCbor(t))}}return Object.defineProperty(n,"name",{value:e,writable:!1}),n}export function HMap(t,e){assert(!new.target,"HMap can't be called with new"),assert(t.prototype instanceof HeliosData),assert(e.prototype instanceof HeliosData);const n=`Map[${t.name}]${e.name}`;class r extends HeliosData{#D;static cleanConstructorArgs(...t){let e=[];if(1==t.length){const n=t[0];if(n instanceof Map)return r.cleanConstructorArgs(Array.from(n.entries()));if(!Array.isArray(n))throw new Error("expected array or Map arg");e=n.map((t=>{if(Array.isArray(t)){if(2!=t.length)throw new Error("expected array item of length 2 (pair)");return[t[0],t[1]]}throw new Error("expected array item (pair)")}))}else{if(2!=t.length)throw new Error("unexpected number of args");{const[n,r]=t;if(!Array.isArray(n))throw new Error("expected keys array arg");if(!Array.isArray(r))throw new Error("expected values array arg");if(n.length!=r.length)throw new Error("keys and values list don't have same length");e=n.map(((t,e)=>[t,r[e]]))}}return e}constructor(...n){const s=r.cleanConstructorArgs(...n).map((([n,r])=>[n instanceof t?n:new t(n),r instanceof e?r:new e(r)]));super(),this.#D=s}get _mapTypeName(){return n}static[Symbol.hasInstance](t){return t._mapTypeName===n&&t instanceof HeliosData}get pairs(){return this.#D}_toUplcData(){return new MapData(this.#D.map((([t,e])=>[t._toUplcData(),e._toUplcData()])))}static fromUplcData(n){return new r(n.map.map((([n,r])=>[t.fromUplcData(n),e.fromUplcData(r)])))}static fromUplcCbor(t){return r.fromUplcData(UplcData.fromCbor(t))}}return Object.defineProperty(r,"name",{value:n,writable:!1}),r}export function Option(t){assert(!new.target,"Option can't be called with new"),assert(t.prototype instanceof HeliosData);const e=`Option[${t.name}]`;class n extends HeliosData{#m;static cleanConstructorArg(e){return null==e?null:e instanceof t?e:new t(e)}constructor(t=null){super(),this.#m=n.cleanConstructorArg(t)}get _optionTypeName(){return e}static[Symbol.hasInstance](t){return t._optionTypeName===e&&t instanceof HeliosData}get some(){return this.#m}_toUplcData(){return new ConstrData(null===this.#m?1:0,null===this.#m?[]:[this.#m._toUplcData()])}static fromUplcData(e){if(1==e.index)return assert(0==e.fields.length),new n(null);if(0==e.index)return assert(1==e.fields.length),new n(t.fromUplcData(e.fields[0]));throw new Error("unexpected option constr index")}static fromUplcCbor(t){return n.fromUplcData(UplcData.fromCbor(t))}}return Object.defineProperty(HList,"name",{value:e,writable:!1}),n}export class Hash extends HeliosData{bytes;static cleanConstructorArg(t){return"string"==typeof t?hexToBytes(t):t}constructor(t){super(),this.bytes=Hash.cleanConstructorArg(t)}static fromProps(t){return t instanceof Hash?t:new Hash(t)}get hex(){return bytesToHex(this.bytes)}toString(){return this.hex}toCbor(){return Cbor.encodeBytes(this.bytes)}_toUplcData(){return new ByteArrayData(this.bytes)}static fromCbor(t){return new Hash(Cbor.decodeBytes(t))}static fromHex(t){return new Hash(hexToBytes(t))}dump(){return bytesToHex(this.bytes)}eq(t){return eq(this.bytes,t.bytes)}static compare(t,e){return ByteArrayData.comp(t.bytes,e.bytes)}}export class DatumHash extends Hash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(32==e.length),super(e)}static fromProps(t){return t instanceof DatumHash?t:new DatumHash(t)}static fromCbor(t){return new DatumHash(Cbor.decodeBytes(t))}static fromUplcData(t){return new DatumHash(t.bytes)}static fromUplcCbor(t){return DatumHash.fromUplcData(UplcData.fromCbor(t))}static fromHex(t){return new DatumHash(hexToBytes(t))}}export class PubKey extends HeliosData{#w;constructor(t){super();const e="string"==typeof t?hexToBytes(t):t;assert(32==e.length,`expected 32 for PubKey, got ${e.length}`),this.#w=e}static fromProps(t){return t instanceof PubKey?t:new PubKey(t)}static dummy(){return new PubKey(new Array(32).fill(0))}get bytes(){return this.#w}get hex(){return bytesToHex(this.#w)}get pubKeyHash(){return new PubKeyHash(this.hash())}static fromUplcData(t){return new PubKey(t.bytes)}static fromUplcCbor(t){return PubKey.fromUplcData(UplcData.fromCbor(t))}static fromCbor(t){return new PubKey(Cbor.decodeBytes(t))}isDummy(){return this.#w.every((t=>0==t))}toCbor(){return Cbor.encodeBytes(this.#w)}_toUplcData(){return new ByteArrayData(this.#w)}hash(){return Crypto.blake2b(this.#w,28)}dump(){return this.hex}}export class PubKeyHash extends Hash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(28==e.length,`expected 28 bytes for PubKeyHash, got ${e.length}`),super(e)}static dummy(){const t=new Array(28).fill(0);return new PubKeyHash(t)}static fromProps(t){return t instanceof PubKeyHash?t:new PubKeyHash(t)}static fromCbor(t){return new PubKeyHash(Cbor.decodeBytes(t))}static fromUplcData(t){return new PubKeyHash(t.bytes)}static fromUplcCbor(t){return PubKeyHash.fromUplcData(UplcData.fromCbor(t))}static fromHex(t){return new PubKeyHash(hexToBytes(t))}}export class ScriptHash extends Hash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(28==e.length||0==e.length,`expected 0 or 28 bytes for ScriptHash, got ${e.length}`),super(e)}static fromProps(t){return t instanceof ScriptHash?t:new ScriptHash(t)}}export class MintingPolicyHash extends ScriptHash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(28==e.length||0==e.length,`expected 0 or 28 bytes for MintingPolicyHash, got ${e.length}`),super(e)}static fromProps(t){return t instanceof MintingPolicyHash?t:new MintingPolicyHash(t)}static fromCbor(t){return new MintingPolicyHash(Cbor.decodeBytes(t))}static fromUplcData(t){return new MintingPolicyHash(t.bytes)}static fromUplcCbor(t){return MintingPolicyHash.fromUplcData(UplcData.fromCbor(t))}static fromHex(t){return new MintingPolicyHash(hexToBytes(t))}toBech32(){return Crypto.encodeBech32("asset",Crypto.blake2b(this.bytes,20))}}export class StakingValidatorHash extends ScriptHash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(28==e.length,`expected 28 bytes for StakingValidatorHash, got ${e.length}`),super(e)}static fromProps(t){return t instanceof StakingValidatorHash?t:new StakingValidatorHash(t)}static fromCbor(t){return new StakingValidatorHash(Cbor.decodeBytes(t))}static fromUplcData(t){return new StakingValidatorHash(t.bytes)}static fromUplcCbor(t){return StakingValidatorHash.fromUplcData(UplcData.fromCbor(t))}static fromHex(t){return new StakingValidatorHash(hexToBytes(t))}}export class ValidatorHash extends ScriptHash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(28==e.length,`expected 28 bytes for ValidatorHash, got ${e.length}`),super(e)}static fromProps(t){return t instanceof ValidatorHash?t:new ValidatorHash(t)}static fromCbor(t){return new ValidatorHash(Cbor.decodeBytes(t))}static fromUplcData(t){return new ValidatorHash(t.bytes)}static fromUplcCbor(t){return ValidatorHash.fromUplcData(UplcData.fromCbor(t))}static fromHex(t){return new ValidatorHash(hexToBytes(t))}}export class TxId extends Hash{constructor(t){const e=Hash.cleanConstructorArg(t);assert(32==e.length,`expected 32 bytes for TxId, got ${e.length}`),super(e)}static fromProps(t){return t instanceof TxId?t:new TxId(t)}_toUplcData(){return new ConstrData(0,[new ByteArrayData(this.bytes)])}static fromCbor(t){return new TxId(Cbor.decodeBytes(t))}static fromUplcData(t){return assert(0==t.index),assert(1==t.fields.length),new TxId(t.fields[0].bytes)}static fromUplcCbor(t){return TxId.fromUplcData(UplcData.fromCbor(t))}static fromHex(t){return new TxId(hexToBytes(t))}static dummy(t=255){return new TxId(new Array(32).fill(t))}}export class TxOutputId extends HeliosData{#$;#k;static cleanConstructorArgs(t){if("string"==typeof t){const e=t.trim().split("#");assert(2==e.length);const n=parseInt(e[1]);return assert(n.toString()==e[1]),[e[0],n]}if(Array.isArray(t)&&2==t.length)return[t[0],t[1]];if("object"==typeof t)return[assertDefined(t.txId),assertDefined(t.utxoId)];throw new Error("unexpected number of args")}constructor(...t){const[e,n]=1==t.length?TxOutputId.cleanConstructorArgs(t[0]):[t[0],t[1]];super(),this.#$=TxId.fromProps(e),this.#k=HInt.fromProps(n)}static dummy(){return new TxOutputId(TxId.dummy(),0)}static fromProps(t){return t instanceof TxOutputId?t:new TxOutputId(t)}get txId(){return this.#$}get utxoIdx(){return Number(this.#k.value)}eq(t){return this.#$.eq(t.#$)&&this.#k.value==t.#k.value}_toUplcData(){return new ConstrData(0,[this.#$._toUplcData(),this.#k._toUplcData()])}static fromUplcData(t){return assert(0==t.index,`TxOutputId.fromUplcData: expected constructor index 0, got ${t.index}`),assert(2==t.fields.length,"TxOutputId.fromUplcData: expected 2 fields"),new TxOutputId(TxId.fromUplcData(t.fields[0]),HInt.fromUplcData(t.fields[1]).value)}static fromUplcCbor(t){return TxOutputId.fromUplcData(UplcData.fromCbor(t))}static fromCbor(t){const e=Array.isArray(t)?t:hexToBytes(t);let n=null,r=null;if(Cbor.decodeTuple(e,((t,e)=>{switch(t){case 0:n=TxId.fromCbor(e);break;case 1:r=Cbor.decodeInteger(e);break;default:throw new Error("unrecognized field")}})),null===n||null===r)throw new Error("unexpected");return new TxOutputId(n,r)}toCbor(){return Cbor.encodeTuple([this.#$.toCbor(),Cbor.encodeInteger(this.#k.value)])}toString(){return`${this.#$.hex}#${this.#k.value.toString()}`}static comp(t,e){let n=ByteArrayData.comp(t.#$.bytes,e.#$.bytes);return 0==n?Number(t.#k.value-e.#k.value):n}}export class Address extends HeliosData{#w;static cleanConstructorArg(t){return"string"==typeof t?t.startsWith("addr")?Address.fromBech32(t).bytes:(t.startsWith("#")&&(t=t.slice(1)),hexToBytes(t)):t}constructor(t){super(),this.#w=Address.cleanConstructorArg(t),assert(29==this.#w.length||57==this.#w.length,`expected 29 or 57 bytes for Address, got ${this.#w.length}`)}static fromProps(t){return t instanceof Address?t:new Address(t)}static dummy(){return Address.fromPubKeyHash(PubKeyHash.dummy())}get bytes(){return this.#w.slice()}toCbor(){return Cbor.encodeBytes(this.#w)}static fromCbor(t){return new Address(Cbor.decodeBytes(t))}static fromBech32(t){let[e,n]=Crypto.decodeBech32(t),r=new Address(n);return assert(e==(Address.isForTestnet(r)?"addr_test":"addr"),"invalid Address prefix"),r}static fromHex(t){return new Address(hexToBytes(t))}toHex(){return bytesToHex(this.#w)}get hex(){return this.toHex()}static fromHash(t,e=config.IS_TESTNET){return Address.fromHashes(t,null,e)}static fromHashes(t,e=null,n=config.IS_TESTNET){if(t instanceof PubKeyHash)return Address.fromPubKeyHash(t,e,n);if(t instanceof ValidatorHash)return Address.fromValidatorHash(t,e,n);throw new Error("unexpected")}static fromPubKeyHash(t,e=null,n=config.IS_TESTNET){return null!==e?e instanceof PubKeyHash?new Address([n?0:1].concat(t.bytes).concat(e.bytes)):(assert(e instanceof StakingValidatorHash),new Address([n?32:33].concat(t.bytes).concat(e.bytes))):new Address([n?96:97].concat(t.bytes))}static fromValidatorHash(t,e=null,n=config.IS_TESTNET){return null!==e?e instanceof PubKeyHash?new Address([n?16:17].concat(t.bytes).concat(e.bytes)):(assert(e instanceof StakingValidatorHash),new Address([n?48:49].concat(t.bytes).concat(e.bytes))):new Address([n?112:113].concat(t.bytes))}toBech32(){return Crypto.encodeBech32(Address.isForTestnet(this)?"addr_test":"addr",this.#w)}eq(t){return 0==ByteArrayData.comp(this.#w,t.bytes)}dump(){return{hex:bytesToHex(this.#w),bech32:this.toBech32()}}static isForTestnet(t){return 0==(15&t.bytes[0])}toCredentialData(){let t=this.validatorHash;if(null!==t)return new ConstrData(1,[new ByteArrayData(t.bytes)]);{let t=this.pubKeyHash;if(null===t)throw new Error("unexpected");return new ConstrData(0,[new ByteArrayData(t.bytes)])}}toStakingData(){const t=this.#w[0]>>4,e=this.stakingHash;if(null==e)return new ConstrData(1,[]);if(4==t||5==t)throw new Error("not yet implemented");if(3==t||2==t)return new ConstrData(0,[new ConstrData(0,[new ConstrData(1,[new ByteArrayData(e.bytes)])])]);if(0==t||1==t)return new ConstrData(0,[new ConstrData(0,[new ConstrData(0,[new ByteArrayData(e.bytes)])])]);throw new Error("unexpected")}_toUplcData(){return new ConstrData(0,[this.toCredentialData(),this.toStakingData()])}static fromUplcData(t,e=config.IS_TESTNET){assert(0==t.index),assert(2==t.fields.length);const n=t.fields[0],r=t.fields[1];let s;if(assert(1==n.fields.length),1==r.index)s=null;else{if(0!=r.index)throw new Error("unexpected");{assert(1==r.fields.length);const t=r.fields[0];if(assert(1==t.fields.length),0!=t.index)throw 1==t.index?new Error("staking pointer not yet handled"):new Error("unexpected");{const e=t.fields[0];if(assert(1==e.fields.length),0==e.index)s=new PubKeyHash(e.fields[0].bytes);else{if(1!=e.index)throw new Error("unexpected");s=new StakingValidatorHash(e.fields[0].bytes)}}}}if(0==n.index)return Address.fromPubKeyHash(new PubKeyHash(n.fields[0].bytes),s,e);if(1==n.index)return Address.fromValidatorHash(new ValidatorHash(n.fields[0].bytes),s,e);throw new Error("unexpected")}static fromUplcCbor(t,e=config.IS_TESTNET){return Address.fromUplcData(UplcData.fromCbor(t),e)}get pubKeyHash(){return(this.#w[0]>>4)%2==0?new PubKeyHash(this.#w.slice(1,29)):null}get validatorHash(){return(this.#w[0]>>4)%2==1?new ValidatorHash(this.#w.slice(1,29)):null}get stakingHash(){let t=this.#w[0]>>4,e=this.#w.slice(29);if(0==t||1==t)return assert(28==e.length),new PubKeyHash(e);if(2==t||3==t)return assert(28==e.length),new StakingValidatorHash(e);if(4==t||5==t)throw new Error("staking pointer not yet supported");return null}static compStakingHashes(t,e){return Hash.compare(assertDefined(t.stakingHash),assertDefined(e.stakingHash))}}export class AssetClass extends HeliosData{#B;#A;static cleanConstructorArgs(t){if("string"==typeof t){const e=t.split(".");return assert(2==e.length,"expected '.' in hex encoded AssetClass"),[e[0],hexToBytes(e[1])]}if(Array.isArray(t)&&2==t.length)return[t[0],t[1]];if("object"==typeof t)return[assertDefined(t.mph),assertDefined(t.tokenName)];throw new Error("unexpected number of AssetClass args")}constructor(t){super();const[e,n]=AssetClass.cleanConstructorArgs(t);this.#B=MintingPolicyHash.fromProps(e),this.#A=ByteArray.fromProps(n)}static fromProps(t){return t instanceof AssetClass?t:new AssetClass(t)}get mintingPolicyHash(){return this.#B}get tokenName(){return this.#A}_toUplcData(){return new ConstrData(0,[this.#B._toUplcData(),this.#A._toUplcData()])}static fromUplcData(t){assert(0==t.index),assert(2==t.fields.length);const e=MintingPolicyHash.fromUplcData(t.fields[0]),n=ByteArray.fromUplcData(t.fields[1]);return new AssetClass([e,n])}toFingerprint(){return Crypto.encodeBech32("asset",Crypto.blake2b(this.#B.bytes.concat(this.#A.bytes),20))}toString(){return`${this.#B.hex}.${bytesToHex(this.#A.bytes)}`}toCbor(){return Cbor.encodeConstr(0,[this.#B.toCbor(),this.#A.toCbor()])}static fromCbor(t){let e=null,n=null;if(assert(0==Cbor.decodeConstr(t,((t,r)=>{switch(t){case 0:e=MintingPolicyHash.fromCbor(r);break;case 1:n=ByteArray.fromCbor(r);break;default:throw new Error("unexpected field")}}))),null==e||null==n)throw new Error("insufficient fields");return new AssetClass([e,n])}static fromUplcCbor(t){return AssetClass.fromUplcData(UplcData.fromCbor(t))}static get ADA(){return new AssetClass(["",""])}}export class Assets extends CborData{assets;constructor(t=[]){super(),this.assets=t.map((t=>{if(Array.isArray(t[1])){return[MintingPolicyHash.fromProps(t[0]),t[1].map((t=>[ByteArray.fromProps(t[0]),HInt.fromProps(t[1])]))]}{const e=AssetClass.fromProps(t[0]),n=HInt.fromProps(t[1]);return[e.mintingPolicyHash,[[e.tokenName,n]]]}})),this.normalize()}static fromProps(t){return t instanceof Assets?t:new Assets(t)}get mintingPolicies(){return this.assets.map((([t,e])=>t))}get nTokenTypes(){let t=0;return this.assets.forEach((([e,n])=>{n.forEach((([e,n])=>{t+=1}))})),t}getTokens(t){const e=this.assets.findIndex((e=>e[0].eq(t)));return-1!=e?this.assets[e][1]:[]}isZero(){return 0==this.assets.length}has(t,e){const n=MintingPolicyHash.fromProps(t),r=ByteArray.fromProps(e),s=this.assets.find((t=>n.eq(t[0])));return void 0!==s&&-1!=s[1].findIndex((t=>t[0].eq(r)))}get(t,e){const n=MintingPolicyHash.fromProps(t),r=ByteArray.fromProps(e),s=this.assets.find((t=>n.eq(t[0])));if(void 0!==s){const t=s[1].find((t=>t[0].eq(r)));return void 0!==t?t[1].value:0n}return 0n}removeZeroes(){for(let t of this.assets)t[1]=t[1].filter((t=>!t[1].eq(0n)));this.assets=this.assets.filter((t=>0!=t[1].length))}normalize(){const t=new Map;for(let[e,n]of this.assets){let r=t.get(e.hex);r||(r=new Map);for(let[t,e]of n){let n=r.get(t.hex);n||(n=0n),n+=e.value,r.set(t.hex,n)}t.set(e.hex,r)}const e=Array.from(t.entries());this.assets=e.map((([t,e])=>{const n=Array.from(e.entries());return[MintingPolicyHash.fromProps(t),n.map((([t,e])=>[ByteArray.fromProps(t),HInt.fromProps(e)]))]}))}addComponent(t,e,n){const r=MintingPolicyHash.fromProps(t),s=ByteArray.fromProps(e),a=HInt.fromProps(n);if(a.eq(0n))return;const i=this.assets.find((t=>r.eq(t[0])));if(void 0===i)this.assets.push([r,[[s,a]]]);else{const t=i[1].find((t=>t[0].eq(s)));void 0===t?i[1].push([s,a]):t[1]=t[1].add(a)}this.removeZeroes()}applyBinOp(t,e){let n=new Assets;for(let[t,r]of this.assets)for(let[s,a]of r)n.addComponent(t,s,new HInt(e(a.value,0n)));for(let[r,s]of t.assets)for(let[t,a]of s)n.addComponent(r,t,new HInt(e(0n,a.value)));return n}add(t){return this.applyBinOp(t,((t,e)=>t+e))}sub(t){return this.applyBinOp(t,((t,e)=>t-e))}mul(t){const e=HInt.fromProps(t);return new Assets(this.assets.map((([t,n])=>[t,n.map((([t,n])=>[t,n.mul(e)]))])))}addTokens(t,e){const n=MintingPolicyHash.fromProps(t);for(let t of this.assets)if(t[0].eq(n))throw new Error(`MultiAsset already contains ${n.hex}`);const r=e.map((([t,e])=>[ByteArray.fromProps(t),HInt.fromProps(e)]));this.assets.push([n,r]),this.sort()}getTokenNames(t){const e=MintingPolicyHash.fromProps(t);for(let[t,n]of this.assets)if(t.eq(e))return n.map((([t,e])=>t));return[]}eq(t){for(let e of this.assets)for(let n of e[1])if(n[1].neq(t.get(e[0],n[0])))return!1;for(let e of t.assets)for(let t of e[1])if(t[1].neq(this.get(e[0],t[0])))return!1;return!0}gt(t){if(this.isZero())return!1;for(let e of this.assets)for(let n of e[1])if(n[1].le(t.get(e[0],n[0])))return!1;for(let e of t.assets)for(let t of e[1])if(!this.has(e[0],t[0]))return!1;return!0}ge(t){if(this.isZero())return t.isZero();for(let e of this.assets)for(let n of e[1])if(n[1].lt(t.get(e[0],n[0])))return!1;for(let e of t.assets)for(let t of e[1])if(!this.has(e[0],t[0]))return!1;return!0}allPositive(){for(let t of this.assets)for(let e of t[1]){if(e[1].lt(0n))return!1;if(e[1].eq(0n))throw new Error("unexpected")}return!0}assertAllPositive(){assert(this.allPositive(),"non-positive token amounts detected")}toCbor(){return Cbor.encodeMap(this.assets.map((t=>[t[0].toCbor(),Cbor.encodeMap(t[1].map((t=>[t[0].toCbor(),t[1].toCbor()])))])))}static fromCbor(t){let e=new Assets;return Cbor.decodeMap(t,((t,n)=>{let r=MintingPolicyHash.fromCbor(n),s=[];Cbor.decodeMap(n,((t,e)=>{s.push([ByteArray.fromCbor(e),HInt.fromCbor(e)])})),e.assets.push([r,s])})),e}dump(){let t={};for(let[e,n]of this.assets){let r={};for(let[t,e]of n)r[t.hex]=e.toString();t[e.hex]=r}return t}_toUplcData(){const t=[];for(let e of this.assets){const n=[];for(let t of e[1])n.push([t[0]._toUplcData(),t[1]._toUplcData()]);t.push([new ByteArrayData(e[0].bytes),new MapData(n)])}return new MapData(t)}sort(){this.assets.sort(((t,e)=>Hash.compare(t[0],e[0]))),this.assets.forEach((([t,e])=>{e.sort(((t,e)=>ByteArrayData.compLengthFirst(t[0].bytes,e[0].bytes)))}))}assertSorted(){this.assets.forEach(((t,e)=>{if(e>0){const n=this.assets[e-1];assert(-1==Hash.compare(n[0],t[0]),`assets not sorted (${n[0].hex} vs ${t[0].hex})`),t[1].forEach(((e,n)=>{if(n>0){const r=t[1][n-1];assert(ByteArrayData.compLengthFirst(r[0].bytes,e[0].bytes)<0,"tokens not sorted")}}))}}))}}export class Value extends HeliosData{#M;#U;static cleanConstructorArgs(t,e){if(Array.isArray(t)){if(assert(2==t.length,"expected two entries for AssetsProps"),e)throw new Error("can't combine assets arg with ValueProps that also contains assets");return[t[0],t[1]]}if(t instanceof HInt)return[t,e||new Assets];if("object"==typeof t){if(e)throw new Error("can't combine assets arg with ValueProps that also contains assets");return[t.lovelace,t.assets??new Assets]}return[t,e||new Assets]}constructor(t=0n,e=null){super();const[n,r]=Value.cleanConstructorArgs(t,e);this.#M=HInt.fromProps(n),this.#U=Assets.fromProps(r)}static fromProps(t){return t instanceof Value?t:new Value(t)}static asset(t,e,n){const r=MintingPolicyHash.fromProps(t),s=ByteArray.fromProps(e),a=HInt.fromProps(n);return new Value({lovelace:0n,assets:new Assets([[r,[[s,a]]]])})}get assets(){return this.#U}get lovelace(){return this.#M.value}setLovelace(t){this.#M=HInt.fromProps(t)}toCbor(){return this.#U.isZero()?this.#M.toCbor():Cbor.encodeTuple([this.#M.toCbor(),this.#U.toCbor()])}static fromCbor(t){let e=new Value;return Cbor.isTuple(t)?Cbor.decodeTuple(t,((t,n)=>{switch(t){case 0:e.#M=HInt.fromCbor(n);break;case 1:e.#U=Assets.fromCbor(n);break;default:throw new Error("unrecognized field")}})):e.#M=HInt.fromCbor(t),e}static sum(t){let e=new Value(0n);return t.forEach((t=>{e=e.add(t)})),e}add(t){return new Value({lovelace:this.#M.add(t.lovelace),assets:this.#U.add(t.assets)})}sub(t){return new Value({lovelace:this.#M.sub(t.lovelace),assets:this.#U.sub(t.assets)})}mul(t){return new Value({lovelace:this.#M.mul(t),assets:this.#U.mul(t)})}eq(t){return this.#M.eq(t.lovelace)&&this.#U.eq(t.assets)}gt(t){return this.#M.gt(t.lovelace)&&this.#U.gt(t.assets)}ge(t){return this.#M.ge(t.lovelace)&&this.#U.ge(t.assets)}assertAllPositive(){return assert(this.#M.ge(0n)),this.#U.assertAllPositive(),this}dump(){return{lovelace:this.#M.dump(),assets:this.#U.dump()}}_toUplcData(t=!1){let e=this.#U._toUplcData();if(this.#M.neq(0n)||t){const t=e.map;t.unshift([new ByteArrayData([]),new MapData([[new ByteArrayData([]),this.#M._toUplcData()]])]),e=new MapData(t)}return e}static fromUplcData(t){let e=new Value,n=t.map;for(let[t,r]of n){let n=t.bytes,s=r.map;if(0==n.length)assert(1==s.length&&0==s[0][0].bytes.length,"bad ada token map"),e=e.add(new Value({lovelace:s[0][1].int}));else{let t=new MintingPolicyHash(n);for(let[n,r]of s){let s=n.bytes,a=r.int;e=e.add(Value.asset(t,s,a))}}}return e}static fromUplcCbor(t){return Value.fromUplcData(UplcData.fromCbor(t))}}export class NetworkParams{#a;#N;constructor(t,e=null){if("object"!=typeof t)throw new Error("raw param must be of type object");this.#a=t,this.#N=e}get raw(){return this.#a}get liveSlot(){return this.#N?this.#N():null}get costModel(){return assertDefined(this.#a?.latestParams?.costModels?.PlutusScriptV2,"'obj.latestParams.costModels.PlutusScriptV2' undefined")}getCostModelParameter(t){return assertNumber(this.costModel[t],`'obj.${t}' undefined`)}getTermCost(t){let e=`cek${t}Cost-exBudgetMemory`,n=`cek${t}Cost-exBudgetCPU`;return{mem:BigInt(assertNumber(this.costModel[e],`'obj.${e}' undefined`)),cpu:BigInt(assertNumber(this.costModel[n],`'obj.${n}' undefined`))}}get plutusCoreStartupCost(){return this.getTermCost("Startup")}get plutusCoreVariableCost(){return this.getTermCost("Var")}get plutusCoreLambdaCost(){return this.getTermCost("Lam")}get plutusCoreDelayCost(){return this.getTermCost("Delay")}get plutusCoreCallCost(){return this.getTermCost("Apply")}get plutusCoreConstCost(){return this.getTermCost("Const")}get plutusCoreForceCost(){return this.getTermCost("Force")}get plutusCoreBuiltinCost(){return this.getTermCost("Builtin")}get txFeeParams(){return[assertNumber(this.#a?.latestParams?.txFeeFixed),assertNumber(this.#a?.latestParams?.txFeePerByte)]}get exFeeParams(){return[assertNumber(this.#a?.latestParams?.executionUnitPrices?.priceMemory),assertNumber(this.#a?.latestParams?.executionUnitPrices?.priceSteps)]}get sortedCostParams(){let t=this.#a?.latestParams?.costModels?.PlutusScriptV2,e=Object.keys(t);return e.sort(),e.map((e=>assertNumber(t[e])))}get lovelacePerUTXOByte(){return assertNumber(this.#a?.latestParams?.utxoCostPerByte)}get minCollateralPct(){return assertNumber(this.#a?.latestParams?.collateralPercentage)}get maxCollateralInputs(){return assertNumber(this.#a?.latestParams?.maxCollateralInputs)}get maxTxExecutionBudget(){return[assertNumber(this.#a?.latestParams?.maxTxExecutionUnits?.memory),assertNumber(this.#a?.latestParams?.maxTxExecutionUnits?.steps)]}get maxTxSize(){return assertNumber(this.#a?.latestParams?.maxTxSize)}get stakeAddressDeposit(){return BigInt(assertNumber(this.#a?.latestParams?.stakeAddressDeposit))}get maxTxFee(){const[t,e]=this.txFeeParams,[n,r]=this.exFeeParams,[s,a]=this.maxTxExecutionBudget;return BigInt(t)+BigInt(Math.ceil(e*this.maxTxSize))+BigInt(Math.ceil(n*s))+BigInt(Math.ceil(r*a))}slotToTime(t){let e=assertNumber(this.#a?.shelleyGenesis?.slotLength),n=BigInt(assertNumber(this.#a?.latestTip?.slot));return BigInt(assertNumber(this.#a?.latestTip?.time))+(t-n)*BigInt(1e3*e)}timeToSlot(t){let e=assertNumber(this.#a?.shelleyGenesis?.slotLength),n=BigInt(assertNumber(this.#a?.latestTip?.slot)),r=t-BigInt(assertNumber(this.#a?.latestTip?.time));return n+BigInt(Math.round(Number(r)/(1e3*e)))}}export class CostModel{constructor(){}static fromParams(t,e){throw new Error("not yet implemented")}calc(t){throw new Error("not yet implemented")}dump(){throw new Error("not yet implemented")}}export class ConstCost extends CostModel{#L;constructor(t){super(),this.#L=t}static fromParams(t,e){let n=t.getCostModelParameter(`${e}`);return new ConstCost(BigInt(n))}calc(t){return this.#L}dump(){return`const: ${this.#L.toString()}`}}export class LinearCost extends CostModel{#V;#O;constructor(t,e){super(),this.#V=t,this.#O=e}static getParams(t,e){let n=t.getCostModelParameter(`${e}-intercept`),r=t.getCostModelParameter(`${e}-slope`);return[BigInt(n),BigInt(r)]}calcInternal(t){return this.#V+this.#O*BigInt(t)}dump(){return`intercept: ${this.#V.toString()}, slope: ${this.#O.toString()}`}}export class ArgSizeCost extends LinearCost{#H;constructor(t,e,n){super(t,e),this.#H=n}calc(t){return assert(this.#H<t.length&&this.#H>=0),this.calcInternal(t[this.#H])}}export class Arg0SizeCost extends ArgSizeCost{constructor(t,e){super(t,e,0)}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e);return new Arg0SizeCost(n,r)}}export class Arg1SizeCost extends ArgSizeCost{constructor(t,e){super(t,e,1)}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e);return new Arg1SizeCost(n,r)}}export class Arg2SizeCost extends ArgSizeCost{constructor(t,e){super(t,e,2)}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e);return new Arg2SizeCost(n,r)}}export class MinArgSizeCost extends LinearCost{constructor(t,e){super(t,e)}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e);return new MinArgSizeCost(n,r)}calc(t){return this.calcInternal(Math.min(...t))}}export class MaxArgSizeCost extends LinearCost{constructor(t,e){super(t,e)}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e);return new MaxArgSizeCost(n,r)}calc(t){return this.calcInternal(Math.max(...t))}}export class SumArgSizesCost extends LinearCost{constructor(t,e){super(t,e)}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e);return new SumArgSizesCost(n,r)}calc(t){let e=0;for(let n of t)e+=n;return this.calcInternal(e)}}export class ArgSizeDiffCost extends LinearCost{#q;constructor(t,e,n){super(t,e),this.#q=n}static fromParams(t,e){let[n,r]=LinearCost.getParams(t,e),s=t.getCostModelParameter(`${e}-minimum`);return new ArgSizeDiffCost(n,r,s)}calc(t){assert(2==t.length);let[e,n]=t;return this.calcInternal(Math.max(e-n,this.#q))}dump(){return super.dump()+`, minimum: ${this.#q.toString()}`}}export class ArgSizeProdCost extends LinearCost{#L;constructor(t,e,n){super(t,e),this.#L=n}static fromParams(t,e){const[n,r]=LinearCost.getParams(t,`${e}-model-arguments`),s=t.getCostModelParameter(`${e}-constant`);return new ArgSizeProdCost(n,r,BigInt(s))}calc(t){assert(2==t.length);const[e,n]=t;return e<n?this.#L:this.calcInternal(e*n)}dump(){return super.dump()+`, constant: ${this.#L.toString()}`}}export class ArgSizeDiagCost extends LinearCost{#L;constructor(t,e,n){super(t,e),this.#L=n}static fromParams(t,e){const[n,r]=LinearCost.getParams(t,e),s=t.getCostModelParameter(`${e}-constant`);return new ArgSizeDiagCost(n,r,BigInt(s))}calc(t){return assert(2==t.length),t[0]==t[1]?this.calcInternal(t[0]):this.#L}dump(){return super.dump()+`, constant: ${this.#L.toString()}`}}export const BUILTIN_PREFIX="__core__";export const SAFE_BUILTIN_SUFFIX="__safe";export const MACRO_BUILTIN_PREFIX="__core__macro";export class UplcBuiltinConfig{#i;#z;#j;#W;#G;#K;constructor(t,e,n,r,s,a){this.#i=t,this.#z=e,this.#j=n,this.#W=r,this.#G=s,this.#K=a}get name(){return this.#i}get forceCount(){return this.#z}get nArgs(){return this.#j}get allowAny(){return this.#W}instantiateCostModels(t){if(null!==this.#G&&null!==this.#K){return[this.#G.fromParams(t,`${this.#i}-memory-arguments`),this.#K.fromParams(t,`${this.#i}-cpu-arguments`)]}throw new Error(`cost model not yet implemented for builtin ${this.#i}`)}calcCost(t,e){const[n,r]=this.instantiateCostModels(t);return{mem:n.calc(e),cpu:r.calc(e)}}dumpCostModel(t){const[e,n]=this.instantiateCostModels(t);console.log(`${this.name}-memory-arguments={${e.dump()},\n${this.name}-cpu-arguments={${n.dump()}}`)}}export const UPLC_BUILTINS=function(){function t(t,e,n,r,s,a){return new UplcBuiltinConfig(t,e,n,r,s,a)}return[t("addInteger",0,2,!1,MaxArgSizeCost,MaxArgSizeCost),t("subtractInteger",0,2,!1,MaxArgSizeCost,MaxArgSizeCost),t("multiplyInteger",0,2,!1,SumArgSizesCost,SumArgSizesCost),t("divideInteger",0,2,!1,ArgSizeDiffCost,ArgSizeProdCost),t("quotientInteger",0,2,!1,ArgSizeDiffCost,ArgSizeProdCost),t("remainderInteger",0,2,!1,ArgSizeDiffCost,ArgSizeProdCost),t("modInteger",0,2,!1,ArgSizeDiffCost,ArgSizeProdCost),t("equalsInteger",0,2,!1,ConstCost,MinArgSizeCost),t("lessThanInteger",0,2,!1,ConstCost,MinArgSizeCost),t("lessThanEqualsInteger",0,2,!1,ConstCost,MinArgSizeCost),t("appendByteString",0,2,!1,SumArgSizesCost,SumArgSizesCost),t("consByteString",0,2,!1,SumArgSizesCost,Arg1SizeCost),t("sliceByteString",0,3,!1,Arg2SizeCost,Arg2SizeCost),t("lengthOfByteString",0,1,!1,ConstCost,ConstCost),t("indexByteString",0,2,!1,ConstCost,ConstCost),t("equalsByteString",0,2,!1,ConstCost,ArgSizeDiagCost),t("lessThanByteString",0,2,!1,ConstCost,MinArgSizeCost),t("lessThanEqualsByteString",0,2,!1,ConstCost,MinArgSizeCost),t("sha2_256",0,1,!1,ConstCost,Arg0SizeCost),t("sha3_256",0,1,!1,ConstCost,Arg0SizeCost),t("blake2b_256",0,1,!1,ConstCost,Arg0SizeCost),t("verifyEd25519Signature",0,3,!1,ConstCost,Arg2SizeCost),t("appendString",0,2,!1,SumArgSizesCost,SumArgSizesCost),t("equalsString",0,2,!1,ConstCost,ArgSizeDiagCost),t("encodeUtf8",0,1,!1,Arg0SizeCost,Arg0SizeCost),t("decodeUtf8",0,1,!1,Arg0SizeCost,Arg0SizeCost),t("ifThenElse",1,3,!0,ConstCost,ConstCost),t("chooseUnit",1,2,!1,ConstCost,ConstCost),t("trace",1,2,!0,ConstCost,ConstCost),t("fstPair",2,1,!1,ConstCost,ConstCost),t("sndPair",2,1,!1,ConstCost,ConstCost),t("chooseList",2,3,!0,ConstCost,ConstCost),t("mkCons",1,2,!1,ConstCost,ConstCost),t("headList",1,1,!1,ConstCost,ConstCost),t("tailList",1,1,!1,ConstCost,ConstCost),t("nullList",1,1,!1,ConstCost,ConstCost),t("chooseData",1,6,!0,ConstCost,ConstCost),t("constrData",0,2,!1,ConstCost,ConstCost),t("mapData",0,1,!1,ConstCost,ConstCost),t("listData",0,1,!1,ConstCost,ConstCost),t("iData",0,1,!1,ConstCost,ConstCost),t("bData",0,1,!1,ConstCost,ConstCost),t("unConstrData",0,1,!1,ConstCost,ConstCost),t("unMapData",0,1,!1,ConstCost,ConstCost),t("unListData",0,1,!1,ConstCost,ConstCost),t("unIData",0,1,!1,ConstCost,ConstCost),t("unBData",0,1,!1,ConstCost,ConstCost),t("equalsData",0,2,!1,ConstCost,MinArgSizeCost),t("mkPairData",0,2,!1,ConstCost,ConstCost),t("mkNilData",0,1,!1,ConstCost,ConstCost),t("mkNilPairData",0,1,!1,ConstCost,ConstCost),t("serialiseData",0,1,!1,Arg0SizeCost,Arg0SizeCost),t("verifyEcdsaSecp256k1Signature",0,3,!1,ConstCost,ConstCost),t("verifySchnorrSecp256k1Signature",0,3,!1,ConstCost,Arg1SizeCost)]}();export const UPLC_MACROS_OFFSET=UPLC_BUILTINS.length;export const UPLC_MACROS=["compile","finalize","get_utxo","now","pick","utxos_at"];export function dumpCostModels(t){for(let e of UPLC_BUILTINS)e.dumpCostModel(t)}export function findUplcBuiltin(t){let e=UPLC_BUILTINS.findIndex((e=>"__core__"+e.name==t));return assert(-1!=e,`${t} is not a real builtin`),e}export function isUplcBuiltin(t,e=!1){return!!t.startsWith("__core__")&&(e&&this.findBuiltin(t),!0)}export class UplcValueImpl{#d;constructor(t){assert(null!=t&&t instanceof Site),this.#d=t}get site(){return this.#d}get length(){throw new Error("not a list nor a map")}isAny(){return!1}get int(){throw this.site.typeError(`expected a Plutus-core int, got '${this.toString()}'`)}get bytes(){throw this.site.typeError(`expected a Plutus-core bytearray, got '${this.toString()}'`)}get string(){throw this.site.typeError(`expected a Plutus-core string, got '${this.toString()}'`)}get bool(){throw this.site.typeError(`expected a Plutus-core bool, got '${this.toString()}'`)}isPair(){return!1}get first(){throw this.site.typeError(`expected a Plutus-core pair, got '${this.toString()}'`)}get second(){throw this.site.typeError(`expected a Plutus-core pair, got '${this.toString()}'`)}isList(){return!1}get itemType(){throw this.site.typeError("not a list")}get list(){throw this.site.typeError(`expected a Plutus-core list, got '${this.toString()}'`)}isData(){return!1}get data(){throw this.site.typeError(`expected Plutus-core data, got '${this.toString()}'`)}assertUnit(){throw this.site.typeError(`expected Plutus-core unit, got '${this.toString}'`)}typeBits(){throw new Error("not yet implemented")}toFlatValueInternal(t){throw new Error("not yet implemented")}toFlatValue(t){t.write("1"+this.typeBits()+"0"),this.toFlatValueInternal(t)}}export class UplcType{#J;constructor(t){this.#J=t}transfer(t){return t.transferUplcType(this.#J)}typeBits(){return this.#J}isSameType(t){return this.#J==t.typeBits()}isData(){return this.#J==UplcType.newDataType().#J}isDataPair(){return this.#J==UplcType.newDataPairType().#J}static newDataType(){return new UplcType("1000")}static newDataPairType(){return new UplcType(["0111","0111","0110","1000","1000"].join("1"))}static fromNumbers(t){return new UplcType(t.map((t=>byteToBitString(t,4,!1))).join("1"))}}export const DEFAULT_UPLC_RTE_CALLBACKS={onPrint:async t=>{console.log(t)},onStartCall:async(t,e)=>!1,onEndCall:async(t,e)=>{},onIncrCost:(t,e,n)=>{}};export class UplcRte{#Z;#Y;#X;#Q;#tt;#et;#nt;#rt;#st;#at;#it;#ot;#_t;#lt;constructor(t=DEFAULT_UPLC_RTE_CALLBACKS,e=null){assertDefined(t),this.#Z=t,this.#Y=e,this.#X=!0,this.#Q=null,this.#tt=[],this.#et="",this.#nt=e?.plutusCoreStartupCost??{mem:0n,cpu:0n},this.#rt=e?.plutusCoreVariableCost??{mem:0n,cpu:0n},this.#st=e?.plutusCoreLambdaCost??{mem:0n,cpu:0n},this.#at=e?.plutusCoreDelayCost??{mem:0n,cpu:0n},this.#it=e?.plutusCoreCallCost??{mem:0n,cpu:0n},this.#ot=e?.plutusCoreConstCost??{mem:0n,cpu:0n},this.#_t=e?.plutusCoreForceCost??{mem:0n,cpu:0n},this.#lt=e?.plutusCoreBuiltinCost??{mem:0n,cpu:0n}}get messages(){return this.#tt}popLastMessage(){return this.#tt.pop()??""}hasError(){return""!=this.#et}getError(){return this.#et}error(t){return this.#et=t,new UplcAny(Site.dummy())}throwError(){if(this.#et instanceof RuntimeError)throw this.#et;if(""!=this.#et)throw new RuntimeError(this.#et)}incrCost(t,e,n){if(n.mem<=0n||n.cpu<=0n)throw new Error("cost not increasing");void 0!==this.#Z.onIncrCost&&this.#Z.onIncrCost(t,e,n)}incrStartupCost(){null!==this.#Y&&this.incrCost("startup",!0,this.#nt)}incrVariableCost(){null!==this.#Y&&this.incrCost("variable",!0,this.#rt)}incrLambdaCost(){null!==this.#Y&&this.incrCost("lambda",!0,this.#st)}incrDelayCost(){null!==this.#Y&&this.incrCost("delay",!0,this.#at)}incrCallCost(){null!==this.#Y&&this.incrCost("call",!0,this.#it)}incrConstCost(){null!==this.#Y&&this.incrCost("const",!0,this.#ot)}incrForceCost(){null!==this.#Y&&this.incrCost("force",!0,this.#_t)}incrBuiltinCost(){null!==this.#Y&&this.incrCost("builtin",!0,this.#lt)}calcAndIncrCost(t,...e){if(null!==this.#Y){let n=t.calcCost(this.#Y,...e);this.incrCost(t.name,!1,n)}}callMacro(t,e){const n=this.#Z.macros;if(!n)throw new RuntimeError("macros not avaiable");const r=n[t];if(!r)throw new Error(`macro ${t} not found`);return r(this,e)}get(t){throw new Error("variable index out of range")}push(t,e=null){return new UplcStack(this,t,e)}async print(t){const e=Array.isArray(t)?t:[t];if(null!=this.#Z.onPrint)for(let t of e)this.#Z.onPrint(t);this.#tt=this.#tt.concat(e)}async startCall(t,e){if(this.#X&&null!=this.#Z.onStartCall){await this.#Z.onStartCall(t,e)&&(this.#X=!1,this.#Q=e)}}async endCall(t,e,n){this.#X||this.#Q!=e||(this.#X=!0,this.#Q=null),this.#X&&null!=this.#Z.onEndCall&&((e=e.slice()).push(["__result",n]),await this.#Z.onEndCall(t,e))}toList(){return[]}}class UplcStack{#ut;#m;#ct;constructor(t,e=null,n=null){this.#ut=t,this.#m=e,this.#ct=n}incrStartupCost(){null!==this.#ut&&this.#ut.incrStartupCost()}incrVariableCost(){null!==this.#ut&&this.#ut.incrVariableCost()}incrLambdaCost(){null!==this.#ut&&this.#ut.incrLambdaCost()}incrDelayCost(){null!==this.#ut&&this.#ut.incrDelayCost()}incrCallCost(){null!==this.#ut&&this.#ut.incrCallCost()}incrConstCost(){null!==this.#ut&&this.#ut.incrConstCost()}incrForceCost(){null!==this.#ut&&this.#ut.incrForceCost()}incrBuiltinCost(){null!==this.#ut&&this.#ut.incrBuiltinCost()}calcAndIncrCost(t,...e){null!==this.#ut&&this.#ut.calcAndIncrCost(t,...e)}get(t){if(0==(t-=1)){if(null===this.#m)throw new Error("Plutus-core stack value not set");return this.#m}if(assert(t>0),null===this.#ut)throw new Error("variable index out of range");return this.#ut.get(t)}async callMacro(t,e){if(this.#ut)return await this.#ut.callMacro(t,e);throw new Error("parent not set, can't call macro")}push(t,e=null){return new UplcStack(this,t,e)}async print(t){null!==this.#ut&&await this.#ut.print(t)}async startCall(t,e){null!==this.#ut&&await this.#ut.startCall(t,e)}async endCall(t,e,n){null!==this.#ut&&await this.#ut.endCall(t,e,n)}toList(){let t=null!==this.#ut?this.#ut.toList():[];return null!==this.#m&&t.push([this.#ct,this.#m]),t}}export class UplcAny extends UplcValueImpl{constructor(t){super(t)}transfer(t){throw new Error("not expected to be part of Uplc ast")}get memSize(){return 1}get flatSize(){throw new Error("UplcAny shouldn't be part of Ast")}copy(t){return new UplcAny(t)}isAny(){return!0}get first(){return this}get second(){return this}assertUnit(){return new UplcUnit(this.site)}toString(){return"Any"}}export class UplcInt extends UplcValueImpl{value;signed;constructor(t,e,n=!0){super(t),assert("bigint"==typeof e,"not a bigint"),this.value=e,this.signed=n}static new(t){return"number"==typeof t?(assert(t%1==0,"must be whole number"),new UplcInt(Site.dummy(),BigInt(t))):new UplcInt(Site.dummy(),t)}transfer(t){return t.transferUplcInt(this.site.transfer(t),this.value,this.signed)}static newSignedTerm(t,e){return new UplcConst(new UplcInt(t,e,!0))}get memSize(){return IntData.memSizeInternal(this.value)}get flatSize(){const t=this.toUnsigned().value.toString(2).length;return 4+(t<=7?7:8*Math.ceil(t/7))}copy(t){return new UplcInt(t,this.value,this.signed)}get int(){return this.value}static parseRawByte(t){return 127&t}static rawByteIsLast(t){return!(128&t)}static bytesToBigInt(t){let e=BigInt(0),n=t.length;for(let r=0;r<n;r++){let n=t[r];e+=BigInt(n)*ipow2(7n*BigInt(r))}return e}toUnsigned(){return this.signed?this.value<0n?new UplcInt(this.site,2n*-this.value-1n,!1):new UplcInt(this.site,2n*this.value,!1):this}toSigned(){return this.signed?this:this.value%2n==0n?new UplcInt(this.site,this.value/2n,!0):new UplcInt(this.site,-(this.value+1n)/2n,!0)}toString(){return this.value.toString()}toFlatInternal(t){let e=padZeroes(this.toUnsigned().value.toString(2),7),n=[];for(let t=0;t<e.length;t+=7)n.push(e.slice(t,t+7));n.reverse();for(let e=0;e<n.length;e++)e==n.length-1?t.write("0"+n[e]):t.write("1"+n[e])}toFlatUnsigned(t){assert(!this.signed),this.toFlatInternal(t)}typeBits(){return"0000"}toFlatValueInternal(t){assert(this.signed),this.toFlatInternal(t)}}export class UplcByteArray extends UplcValueImpl{#w;constructor(t,e){super(t),this.#w=e}static new(t){return new UplcByteArray(Site.dummy(),t)}static newTerm(t,e){return new UplcConst(new UplcByteArray(t,e))}transfer(t){return t.transferUplcByteArray(this.site.transfer(t),this.#w)}get memSize(){return ByteArrayData.memSizeInternal(this.#w)}get flatSize(){const t=this.#w.length;return 4+8*t+8*Math.ceil(t/256)+8}copy(t){return new UplcByteArray(t,this.#w)}get bytes(){return this.#w.slice()}toString(){return`#${bytesToHex(this.#w)}`}typeBits(){return"0001"}toFlatValueInternal(t){UplcByteArray.writeBytes(t,this.#w)}static writeBytes(t,e,n=!0){n&&t.padToByteBoundary(!0);let r=e.length,s=0;for(;s<r;){let n=Math.min(r-s,255);t.write(padZeroes(n.toString(2),8));for(let r=s;r<s+n;r++){let n=e[r];t.write(padZeroes(n.toString(2),8))}s+=n}n&&t.write("00000000")}}export class UplcString extends UplcValueImpl{#m;constructor(t,e){super(t),this.#m=e}static new(t){return new UplcString(Site.dummy(),t)}static newTerm(t,e){return new UplcConst(new UplcString(t,e))}transfer(t){return t.transferUplcString(this.site.transfer(t),this.#m)}get memSize(){return this.#m.length}get flatSize(){const t=Array.from((new TextEncoder).encode(this.#m));return new UplcByteArray(Site.dummy(),t).flatSize}copy(t){return new UplcString(t,this.#m)}get string(){return this.#m}toString(){return`"${this.#m}"`}typeBits(){return"0010"}toFlatValueInternal(t){let e=Array.from((new TextEncoder).encode(this.#m));UplcByteArray.writeBytes(t,e)}}export class UplcUnit extends UplcValueImpl{constructor(t){super(t)}static new(){return new UplcUnit(Site.dummy())}static newTerm(t){return new UplcConst(new UplcUnit(t))}transfer(t){return t.transferUplcUnit(this.site.transfer(t))}get memSize(){return 1}get flatSize(){return 4}copy(t){return new UplcUnit(t)}toString(){return"()"}typeBits(){return"0011"}toFlatValueInternal(t){}assertUnit(){return this}}export class UplcBool extends UplcValueImpl{#m;constructor(t,e){super(t),this.#m=e}static new(t){return new UplcBool(Site.dummy(),t)}static newTerm(t,e){return new UplcConst(new UplcBool(t,e))}transfer(t){return t.transferUplcBool(this.site.transfer(t),this.#m)}get memSize(){return 1}get flatSize(){return 5}copy(t){return new UplcBool(t,this.#m)}get bool(){return this.#m}get data(){return new ConstrData(this.#m?1:0,[])}toString(){return this.#m?"true":"false"}typeBits(){return"0100"}toFlatValueInternal(t){this.#m?t.write("1"):t.write("0")}}export class UplcPair extends UplcValueImpl{#pt;#ht;constructor(t,e,n){super(t),this.#pt=e,this.#ht=n}static new(t,e){return new UplcPair(Site.dummy(),t,e)}static newTerm(t,e,n){return new UplcConst(new UplcPair(t,e,n))}transfer(t){return t.transferUplcPair(this.site.transfer(t),this.#pt.transfer(t),this.#ht.transfer(t))}get memSize(){return this.#pt.memSize+this.#ht.memSize}get flatSize(){return 16+this.#pt.flatSize+this.#ht.flatSize}copy(t){return new UplcPair(t,this.#pt,this.#ht)}toString(){return`(${this.#pt.toString()}, ${this.#ht.toString()})`}isPair(){return!0}get first(){return this.#pt}get second(){return this.#ht}get key(){return this.#pt.data}get value(){return this.#ht.data}typeBits(){return["0111","0111","0110",this.#pt.typeBits(),this.#ht.typeBits()].join("1")}toFlatValueInternal(t){this.#pt.toFlatValueInternal(t),this.#ht.toFlatValueInternal(t)}}export class UplcList extends UplcValueImpl{#dt;#P;constructor(t,e,n){super(t),this.#dt=e,this.#P=n}static new(t,e){return new UplcList(Site.dummy(),t,e)}transfer(t){return t.transferUplcList(this.site.transfer(t),this.#dt.transfer(t),this.#P.map((e=>e.transfer(t))))}get length(){return this.#P.length}get memSize(){let t=0;for(let e of this.#P)t+=e.copy(this.site).memSize;return t}get flatSize(){const t=this.#dt.typeBits.length;return 10+t+this.#P.reduce(((e,n)=>n.flatSize-t+e),0)}get itemType(){return this.#dt}copy(t){return new UplcList(t,this.#dt,this.#P.slice())}isList(){return!0}get list(){return this.#P.slice()}isDataList(){return this.#dt.isData()}isDataMap(){return this.#dt.isDataPair()}toString(){return`[${this.#P.map((t=>t.toString())).join(", ")}]`}typeBits(){return["0111","0101",this.#dt.typeBits()].join("1")}toFlatValueInternal(t){for(let e of this.#P)t.write("1"),e.copy(this.site).toFlatValueInternal(t);t.write("0")}}export class UplcDataValue extends UplcValueImpl{#mt;constructor(t,e){super(t),this.#mt=assertDefined(e),assert(e instanceof UplcData)}transfer(t){return t.transferUplcDataValue(this.site.transfer(t),this.#mt.transfer(t))}get memSize(){return this.#mt.memSize}get flatSize(){const t=this.#mt.toCbor();return new UplcByteArray(Site.dummy(),t).flatSize}copy(t){return new UplcDataValue(t,this.#mt)}isData(){return!0}get data(){return this.#mt}toString(){return`data(${this.#mt.toString()})`}typeBits(){return UplcType.newDataType().typeBits()}toFlatValueInternal(t){UplcByteArray.writeBytes(t,this.#mt.toCbor())}static unwrap(t){return t instanceof UplcDataValue?t.data:t}}export class UplcTerm{#d;#f;constructor(t,e){assert(null!=t&&t instanceof Site),this.#d=t,this.#f=e}get type(){return this.#f}get site(){return this.#d}transfer(t){throw new Error("not yet implemented")}toString(){return`(Term ${this.#f.toString()})`}toFlat(t,e=null){throw new Error("not yet implemented")}}export class UplcVariable extends UplcTerm{index;constructor(t,e){super(t,0),this.index=e}transfer(t){return t.transferUplcVariable(this.site.transfer(t),this.index.transfer(t))}toString(){return`x${this.index.toString()}`}toFlat(t,e=null){t.write("0000"),this.index.toFlatUnsigned(t)}computeCek(t,e,n){t.incrVariableCost();const r=Number(this.index.value);return{reducing:n.env.values[n.env.values.length-r]}}}export class UplcDelay extends UplcTerm{expr;constructor(t,e){super(t,1),this.expr=e}transfer(t){return t.transferUplcDelay(this.site.transfer(t),this.expr.transfer(t))}toString(){return`(delay ${this.expr.toString()})`}toFlat(t,e=null){t.write("0001"),this.expr.toFlat(t,e)}computeCek(t,e,n){return t.incrDelayCost(),{reducing:new UplcDelayWithEnv(this,n.env)}}}export class UplcLambda extends UplcTerm{expr;#ft;constructor(t,e,n=null){super(t,2),this.expr=e,this.#ft=n}transfer(t){return t.transferUplcLambda(this.site.transfer(t),this.expr.transfer(t),this.#ft)}toString(){return`(Λ${null!==this.#ft?" "+this.#ft+" ->":""} ${this.expr.toString()})`}toFlat(t,e=null){t.write("0010"),this.expr.toFlat(t,e)}computeCek(t,e,n){return t.incrLambdaCost(),{reducing:new UplcLambdaWithEnv(this,n.env)}}}export class UplcCall extends UplcTerm{fn;arg;constructor(t,e,n){super(t,3),this.fn=e,this.arg=n}get callSite(){return this.site}transfer(t){return t.transferUplcCall(this.site.transfer(t),this.fn.transfer(t),this.arg.transfer(t))}toString(){return`[${this.fn.toString()} ${this.arg.toString()}]`}toFlat(t,e=null){if(e&&this.site.codeMapSite){t.write("1011");const n=this.site.codeMapSite;new UplcInt(n,BigInt(assertDefined(e.get(n.src.name))),!1).toFlatUnsigned(t),new UplcInt(n,BigInt(n.startPos),!1).toFlatUnsigned(t)}else t.write("0011");this.fn.toFlat(t,e),this.arg.toFlat(t,e)}computeCek(t,e,n){return t.incrCallCost(),e.push(new PreCallFrame(this,n.env)),{computing:this.fn,env:n.env}}}export class UplcConst extends UplcTerm{value;constructor(t){super(t.site,4),this.value=t,t instanceof UplcInt&&assert(t.signed)}get flatSize(){return 4+this.value.flatSize}transfer(t){return t.transferUplcConst(this.value.transfer(t))}toString(){return this.value.toString()}toFlat(t,e=null){t.write("0100"),this.value.toFlatValue(t)}computeCek(t,e,n){return t.incrConstCost(),{reducing:this}}reducePreCallFrame(t,e,n){if(this.value.isAny())return{reducing:this};throw new Error("UplcCall term expects UplcLambdaWithEnv or UplcBuiltin for first arg")}reduceForceFrame(t,e,n){if(this.value.isAny())return{reducing:this};throw new Error(`unexpected ${this.toString()} term in force`)}}export class UplcForce extends UplcTerm{expr;constructor(t,e){super(t,5),this.expr=e}transfer(t){return t.transferUplcForce(this.site.transfer(t),this.expr.transfer(t))}toString(){return`(force ${this.expr.toString()})`}toFlat(t,e=null){if(e&&this.site.codeMapSite){t.write("1101");const n=this.site.codeMapSite;new UplcInt(n,BigInt(assertDefined(e.get(n.src.name))),!1).toFlatUnsigned(t),new UplcInt(n,BigInt(n.startPos),!1).toFlatUnsigned(t)}else t.write("0101");this.expr.toFlat(t,e)}computeCek(t,e,n){return t.incrForceCost(),e.push(new ForceFrame(this,n.env)),{computing:this.expr,env:n.env}}}export class UplcError extends UplcTerm{#yt;constructor(t,e=""){super(t,6),this.#yt=e}transfer(t){return t.transferUplcError(this.site.transfer(t),this.#yt)}toString(){return"(error)"}toFlat(t,e=null){t.write("0110")}computeCek(t,e,n){return{error:"",env:n.env}}}export class UplcBuiltin extends UplcTerm{#i;#z;#j;constructor(t,e){if(super(t,7),this.#i=assertDefined(e),this.#z="string"!=typeof this.#i||this.#i.startsWith("macro__")?0:UPLC_BUILTINS[findUplcBuiltin("__core__"+this.#i)].forceCount,this.isMacro())this.#j=-1;else{if("string"!=typeof this.#i)throw new Error("unknown number of arguments");{const t=UPLC_BUILTINS.findIndex((t=>t.name==this.#i));assert(-1!=t),this.#j=UPLC_BUILTINS[t].nArgs}}}transfer(t){return t.transferUplcBuiltin(this.site.transfer(t),this.#i)}get name(){return this.#i.toString()}get nArgs(){return this.#j}allowAny(){if("string"==typeof this.#i){if(this.#i.startsWith("macro__"))return!0;{let t=UPLC_BUILTINS.findIndex((t=>t.name==this.#i));return assert(-1!=t),UPLC_BUILTINS[t].allowAny}}return!0}isMacro(){return"string"==typeof this.#i&&this.#i.startsWith("macro__")}toString(){return"string"==typeof this.#i?`(builtin ${this.#i})`:`(builtin unknown${this.#i.toString()})`}toFlat(t,e=null){let n;if(t.write("0111"),"string"==typeof this.#i)if(this.#i.startsWith("macro__")){const t=this.#i.slice(7);n=UPLC_MACROS.findIndex((e=>e==t)),assert(-1!=n,`macro '${t}' not found`),n+=UPLC_MACROS_OFFSET}else n=UPLC_BUILTINS.findIndex((t=>t.name==this.#i)),assert(-1!=n);else n=this.#i;let r=padZeroes(n.toString(2),7);t.write(r)}calcCost(t,...e){let n=UPLC_BUILTINS.findIndex((t=>t.name==this.#i)),r=e.map((t=>t.memSize));if(!r.every((t=>!Number.isNaN(t)&&t>=0)))throw new Error("invalid arg size");return UPLC_BUILTINS[n].calcCost(t,r)}static evalStatic(t,e){let n=new UplcBuiltin(t.site,t.value),r=new UplcRte,s=n.evalBuiltin(r,t.site,e,!0);if(r.throwError(),s instanceof Promise)throw new Error("can't call trace through evalStatic");return s}computeCek(t,e,n){return t.incrBuiltinCost(),{reducing:new AppliedUplcBuiltin(this)}}evalMacro(t,e,n){if(assert(this.isMacro()),"string"==typeof this.#i)return t.callMacro(this.#i.slice(7),n);throw new Error("unexpected")}evalBuiltin(t,e,n,r=!1){if(!this.allowAny()&&n.some((t=>t.isAny())))return new UplcAny(e);t.calcAndIncrCost(this,...n);return assertDefined({addInteger:(t,n)=>new UplcInt(e,t.int+n.int),subtractInteger:(t,n)=>new UplcInt(e,t.int-n.int),divideInteger:(n,r)=>0n===r.int?t.error("division by zero"):new UplcInt(e,n.int/r.int),multiplyInteger:(t,n)=>new UplcInt(e,t.int*n.int),quotientInteger:(n,r)=>0n===r.int?t.error("division by zero"):new UplcInt(e,n.int/r.int+(r.int<0n?1n:0n)),modInteger:(n,r)=>0n===r.int?t.error("division by zero"):new UplcInt(e,n.int%r.int),remainderInteger:(n,r)=>0n==r.int?t.error("division by zero"):new UplcInt(e,n.int-(n.int/r.int+(r.int<0n?1n:0n))*r.int),equalsInteger:(t,n)=>new UplcBool(e,t.int==n.int),lessThanInteger:(t,n)=>new UplcBool(e,t.int<n.int),lessThanEqualsInteger:(t,n)=>new UplcBool(e,t.int<=n.int),appendByteString:(t,n)=>new UplcByteArray(e,t.bytes.concat(n.bytes)),consByteString:(n,r)=>{let s=r.bytes;const a=Number(n.int);return a<0||a>=256?t.error("byte out of range"):(s.unshift(a),new UplcByteArray(e,s))},sliceByteString:(t,n,r)=>{const s=r.bytes;let a=Math.max(Number(t.int),0),i=Math.min(Number(t.int)+Number(n.int)-1,s.length-1);return new UplcByteArray(e,i<a?[]:s.slice(a,i+1))},lengthOfByteString:t=>new UplcInt(e,BigInt(t.bytes.length)),indexByteString:(t,n)=>{let r=t.bytes,s=n.int;if(s<0||s>=r.length)throw new Error("index out of range");return new UplcInt(e,BigInt(r[Number(s)]))},equalsByteString:(t,n)=>new UplcBool(e,0==ByteArrayData.comp(t.bytes,n.bytes)),lessThanByteString:(t,n)=>new UplcBool(e,-1==ByteArrayData.comp(t.bytes,n.bytes)),lessThanEqualsByteString:(t,n)=>new UplcBool(e,ByteArrayData.comp(t.bytes,n.bytes)<=0),appendString:(t,n)=>new UplcString(e,t.string+n.string),equalsString:(t,n)=>new UplcBool(e,t.string==n.string),encodeUtf8:t=>new UplcByteArray(e,textToBytes(t.string)),decodeUtf8:n=>{try{return new UplcString(e,bytesToText(n.bytes))}catch(e){return t.error("invalid utf-8")}},sha2_256:t=>new UplcByteArray(e,Crypto.sha2_256(t.bytes)),sha3_256:t=>new UplcByteArray(e,Crypto.sha3(t.bytes)),blake2b_256:t=>new UplcByteArray(e,Crypto.blake2b(t.bytes)),verifyEd25519Signature:(n,r,s)=>{t.calcAndIncrCost(this,n,r,s);let a=n.bytes;if(32!=a.length)return t.error(`expected key of length 32 for verifyEd25519Signature, got key of length ${a.length}`);let i=r.bytes,o=s.bytes;if(64!=o.length)return t.error(`expected signature of length 64 for verifyEd25519Signature, got signature of length ${o.length}`);let _=Ed25519.verify(o,i,a);return new UplcBool(e,_)},ifThenElse:(t,n,r)=>t.isAny()?new UplcAny(e):t.bool?n:r,chooseUnit:(t,e)=>(t.assertUnit(),e),trace:(n,s)=>n.isAny()||r?s:t.print(n.string.split("\n").map((t=>`INFO (${e.toString()}) ${t}`))).then((()=>s)),fstPair:t=>{if(t.isPair())return t.first;throw e.typeError(`expected pair or data-pair for first arg, got '${t.toString()}'`)},sndPair:t=>{if(t.isPair())return t.second;throw e.typeError(`expected pair or data-pair for first arg, got '${t.toString()}'`)},chooseList:(t,n,r)=>{if(t.isAny())return new UplcAny(e);if(t.isList())return 0==t.length?n:r;throw e.typeError(`expected list or map first arg, got '${t.toString()}'`)},mkCons:(t,n)=>{if(n.isList()){if(!n.itemType.isSameType(t))throw e.typeError(`wrong type for 2nd arg of mkCons, expected ${t.toString()}, got ${n.toString()}`);let r=n.list;return r.unshift(t),new UplcList(e,n.itemType,r)}throw e.typeError(`expected list or map for second arg, got '${n.toString()}'`)},headList:n=>{if(n.isList()){const e=n.list;return 0==e.length?t.error("empty list"):e[0]}throw e.typeError(`__core__headList expects list or map, got '${n.toString()}'`)},tailList:n=>{if(n.isList()){let r=n.list;return 0==r.length?t.error("empty list"):new UplcList(e,n.itemType,r.slice(1))}throw e.typeError(`__core__tailList expects list or map, got '${n.toString()}'`)},nullList:t=>{if(t.isList())return new UplcBool(e,0==t.list.length);throw e.typeError(`__core__nullList expects list or map, got '${t.toString()}'`)},chooseData:(t,n,r,s,a,i)=>{if(t.isAny())return new UplcAny(e);{const e=t.data;if(e instanceof ConstrData)return n;if(e instanceof MapData)return r;if(e instanceof ListData)return s;if(e instanceof IntData)return a;if(e instanceof ByteArrayData)return i;throw new Error("unexpected")}},constrData:(t,n)=>{const r=t.int;assert(r>=0);const s=n.list;return new UplcDataValue(e,new ConstrData(Number(r),s.map((t=>t.data))))},mapData:t=>new UplcDataValue(e,new MapData(t.list.map((t=>[t.first.data,t.second.data])))),listData:t=>new UplcDataValue(e,new ListData(t.list.map((t=>t.data)))),iData:t=>new UplcDataValue(e,new IntData(t.int)),bData:t=>new UplcDataValue(e,new ByteArrayData(t.bytes)),unConstrData:n=>{if(!n.isData())throw e.typeError(`expected data for arg of unConstrData, got ${n.toString()}`);let r=n.data;return r instanceof ConstrData?new UplcPair(e,new UplcInt(e,BigInt(r.index)),new UplcList(e,UplcType.newDataType(),r.fields.map((t=>new UplcDataValue(e,t))))):t.error(`unexpected unConstrData argument '${r.toString()}'`)},unMapData:n=>{if(!n.isData())throw e.typeError(`expected data for arg of unMapData, got ${n.toString()}`);let r=n.data;return r instanceof MapData?new UplcList(e,UplcType.newDataPairType(),r.map.map((([t,n])=>new UplcPair(e,new UplcDataValue(e,t),new UplcDataValue(e,n))))):t.error(`unexpected unMapData argument '${r.toString()}'`)},unListData:n=>{if(!n.isData())throw e.typeError(`expected data for arg of unListData, got ${n.toString()}`);let r=n.data;return r instanceof ListData?new UplcList(e,UplcType.newDataType(),r.list.map((t=>new UplcDataValue(e,t)))):t.error(`unexpected unListData argument '${r.toString()}'`)},unIData:n=>{if(!n.isData())throw e.typeError(`expected data for arg of unIData, got ${n.toString()}`);let r=n.data;return r instanceof IntData?new UplcInt(e,r.value):t.error(`unexpected unIData argument '${r.toString()}'`)},unBData:n=>{if(!n.isData())throw e.typeError(`expected data for arg of unBData, got ${n.toString()}`);let r=n.data;return r instanceof ByteArrayData?new UplcByteArray(e,r.bytes):t.error(`unexpected unBData argument '${r.toString()}'`)},equalsData:(t,n)=>{if(!t.isData())throw e.typeError(`expected data for 1st arg of equalsData, got ${t.toString()}`);if(!n.isData())throw e.typeError(`expected data for 2nd arg of equalsData, got ${n.toString()}`);return new UplcBool(e,t.data.isSame(n.data))},mkPairData:(t,n)=>new UplcPair(e,new UplcDataValue(e,t.data),new UplcDataValue(e,n.data)),mkNilData:t=>(t.assertUnit(),new UplcList(e,UplcType.newDataType(),[])),mkNilPairData:t=>(t.assertUnit(),new UplcList(e,UplcType.newDataPairType(),[])),serialiseData:t=>new UplcByteArray(e,t.data.toCbor()),verifyEcdsaSecp256k1Signature:(t,e,n)=>{throw new Error("no immediate need, so don't bother yet")},verifySchnorrSecp256k1Signature:(t,e,n)=>{throw new Error("no immediate need, so don't bother yet")}}[this.#i],`UplcBuiltin ${this.#i} not yet implemented`)(...n)}get forceCount(){return this.#z}}export class UplcFrame{async reduceCek(t,e,n){throw new Error("not yet implemented")}get site(){throw new Error("not yet implemented")}}export class ForceFrame extends UplcFrame{term;env;constructor(t,e){super(),this.term=t,this.env=e}get site(){return this.term.site}async reduceCek(t,e,n){const r=n.reducing;return await r.reduceForceFrame(t,e,this)}}export class PreCallFrame extends UplcFrame{term;env;constructor(t,e){super(),this.term=t,this.env=e}get site(){return this.term.site}async reduceCek(t,e,n){return n.reducing.reducePreCallFrame(t,e,this)}}export class CallFrame extends UplcFrame{term;fn;env;constructor(t,e,n){super(),this.term=t,this.fn=e,this.env=n}get site(){return this.term.site}async reduceCek(t,e,n){return this.fn.reduceCallFrame(t,e,n,this)}}class UplcTermWithEnv{term;env;constructor(t,e){this.term=t,this.env=e}get site(){return this.term.site}toString(){return`(WithEnv ${this.term.toString()})`}}class UplcLambdaWithEnv extends UplcTermWithEnv{async reducePreCallFrame(t,e,n){return e.push(new CallFrame(n.term,this,n.env)),{computing:n.term.arg,env:n.env}}async reduceForceFrame(t,e,n){throw new Error("expected force after delay")}async reduceCallFrame(t,e,n,r){return{computing:this.term.expr,env:{values:this.env.values.concat([n.reducing]),callSites:r.env.callSites.concat([r.term.callSite])}}}}class UplcDelayWithEnv extends UplcTermWithEnv{reducePreCallFrame(t,e,n){throw new Error("UplcCall term expects UplcLambdaWithEnv or UplcBuiltin for first arg")}reduceForceFrame(t,e,n){return{computing:this.term.expr,env:{values:this.env.values,callSites:n.env.callSites.concat([n.term.site])}}}}class UplcAnonValue extends UplcValueImpl{term;constructor(t,e){super(t),this.term=e}transfer(t){throw new Error("shouldn't be part of AST")}copy(t){throw new Error("shouldn't be part of AST")}get memSize(){return 1}get flatSize(){throw new Error("shouldn't be part of AST")}toString(){return this.term.toString()}}class AppliedUplcBuiltin{term;forceCount;args;constructor(t,e=0,n=[]){this.term=t,this.forceCount=e,this.args=n}get site(){return this.term.site}toString(){return`(AppliedBuiltin ${this.forceCount} [${this.args.map((t=>t.toString())).join(", ")}] ${this.term.toString()})`}force(){return assert(this.forceCount<this.term.forceCount),new AppliedUplcBuiltin(this.term,this.forceCount+1,this.args)}apply(t){return assert(-1==this.term.nArgs||this.args.length<this.term.nArgs),new AppliedUplcBuiltin(this.term,this.forceCount,this.args.concat([t]))}isFullForced(){return this.forceCount==this.term.forceCount}isFullyApplied(){if(this.term.isMacro()){if(0==this.args.length)return!1;{const t=this.args[this.args.length-1];return t instanceof UplcConst&&t.value instanceof UplcUnit}}return this.args.length==this.term.nArgs}async evalCek(t,e){let n=e[e.length-1];const r=this.args.map((t=>t instanceof UplcConst?t.value:new UplcAnonValue(Site.dummy(),t)));let s;if(this.term.isMacro())assertDefined(r.pop()).assertUnit(),s=await this.term.evalMacro(t,n,r);else if(!this.term.allowAny()&&r.some((t=>t.isAny())))s=new UplcAny(n);else if("trace"==this.term.name){if(n.codeMapSite)n=n.codeMapSite;else for(let t=e.length-1;t>=0;t--){const r=e[t];if(r.codeMapSite){n=r.codeMapSite;break}}s=await this.term.evalBuiltin(t,n,r)}else s=await this.term.evalBuiltin(t,n,r);return s instanceof UplcAnonValue?s.term:new UplcConst(s)}async reducePreCallFrame(t,e,n){return e.push(new CallFrame(n.term,this,n.env)),{computing:n.term.arg,env:n.env}}async reduceForceFrame(t,e,n){if(this.isFullForced())throw new Error(`can't apply force to ${this.term.name}`);return{reducing:this.force()}}async reduceCallFrame(t,e,n,r){if(this.isFullForced()){if(this.isFullyApplied())throw new Error("already fully applied");{const e=this.apply(n.reducing);if(e.isFullyApplied()){const n=r.env.callSites.concat([r.term.callSite]),s=await e.evalCek(t,n);return t.hasError()?{error:t.getError(),env:{values:r.env.values,callSites:n}}:{reducing:s}}return{reducing:e}}}throw new Error("must be fully forced before call")}}export async function evalCek(t,e,n=null){if(null!==n)if(0==n.length)e=new UplcForce(e.site,e);else for(let t of n)e=new UplcCall(e.site,e,new UplcConst(t));const r=[];let s={computing:e,env:{values:[],callSites:[]}};for(t.incrStartupCost();;)if("computing"in s){s=s.computing.computeCek(t,r,s)}else{if(!("reducing"in s)){if("error"in s){let e=t.messages.slice(),n=s.error;const r="thrown during UPLC evaluation";if("string"==typeof n){let t=n;""==t&&e.length>0&&(t=assertDefined(e.pop()).split(")").slice(1).join(")").trim());let r=!1;for(let n=s.env.callSites.length-1;n>=0;n--){const a=s.env.callSites[n];a.codeMapSite&&(r?e.push(`TRACE (${a.codeMapSite.toString()})`):(e.push(`ERROR (${a.codeMapSite.toString()}) ${t}`),r=!0))}r||e.push(`ERROR ${t}`)}else e=e.concat(n.message.split("\n").filter((t=>t!=r)));throw e.unshift(r),new RuntimeError(e.join("\n"))}throw new Error("unhandled CEK state")}{const e=r.pop(),n=s.reducing;if(!e){if(n instanceof UplcConst)return n.value;throw new Error("final UplcTerm in CEK isn't a UplcConst but a "+n.toString())}s=await e.reduceCek(t,r,s)}}}const UPLC_VERSION_COMPONENTS=[1n,0n,0n],UPLC_VERSION=UPLC_VERSION_COMPONENTS.map((t=>t.toString())).join("."),PLUTUS_SCRIPT_VERSION="PlutusScriptV2",UPLC_TAG_WIDTHS={term:4,type:3,constType:4,builtin:7,constant:4,kind:1};export class UplcProgram{#gt;#wt;#Tt;constructor(t,e={purpose:null,callsTxTimeRange:!1},n=UPLC_VERSION_COMPONENTS.map((e=>new UplcInt(t.site,e,!1)))){this.#gt=n,this.#wt=t,this.#Tt=e}get expr(){return this.#wt}get site(){return new Site(this.#wt.site.src,0)}get src(){return this.site.src.raw}get properties(){return this.#Tt}transfer(t){return t.transferUplcProgram(this.#wt.transfer(t.transferUplcAst),this.#Tt,this.#gt.map((e=>e.transfer(t.transferUplcAst))))}get versionString(){return this.#gt.map((t=>t.toString())).join(".")}plutusScriptVersion(){return"PlutusScriptV2"}versionTag(){let t=this.plutusScriptVersion();switch(t){case"PlutusScriptV1":return 1;case"PlutusScriptV2":return 2;default:throw new Error(`unhandled script version '${t}'`)}}toString(){return`(program ${this.versionString} ${this.#wt.toString()})`}toFlat(t){this.toFlatWithMapping(t,null)}toFlatWithMapping(t,e){for(let e of this.#gt)e.toFlatUnsigned(t);this.#wt.toFlat(t,e)}async runInternal(t,e=DEFAULT_UPLC_RTE_CALLBACKS,n=null){assertDefined(e);let r=new UplcRte(e,n);return await evalCek(r,this.#wt,t)}apply(t){let e=this.expr;for(let n of t)e=new UplcCall(n.site,e,new UplcConst(n));return new UplcProgram(e,this.#Tt,this.#gt)}async run(t,e=DEFAULT_UPLC_RTE_CALLBACKS,n=null){try{return await this.runInternal(t,e,n)}catch(t){if(t instanceof RuntimeError)return t;throw t}}async runWithPrint(t){const e=[],n=Object.assign({},DEFAULT_UPLC_RTE_CALLBACKS);n.onPrint=async function(t){e.push(t)};return[await this.run(t,n),e]}async profile(t,e){let n=Object.assign({},DEFAULT_UPLC_RTE_CALLBACKS),r=0n,s=0n;const a={},i={};n.onIncrCost=(t,e,n)=>{if(r+=n.mem,s+=n.cpu,void 0!==t)if(e){const e=i[t];i[t]=void 0!==e?{mem:e.mem+n.mem,cpu:e.cpu+n.cpu,count:e.count+1}:{...n,count:1}}else{const e=a[t];a[t]=void 0!==e?{mem:e.mem+n.mem,cpu:e.cpu+n.cpu,count:e.count+1}:{...n,count:1}}};let o=[];n.onPrint=async function(t){o.push(t)};let _=await this.run(t,n,e);return{mem:r,cpu:s,size:this.calcSize(),builtins:a,terms:i,result:_,messages:o}}serializeBytes(){let t=new BitWriter;return this.toFlat(t),t.finalize()}calcSize(){return this.serializeBytes().length}toCbor(){return Cbor.encodeBytes(Cbor.encodeBytes(this.serializeBytes()))}toCborWithMapping(t){let e=new BitWriter;return this.toFlatWithMapping(e,t),Cbor.encodeBytes(Cbor.encodeBytes(e.finalize()))}serialize(){const t=bytesToHex(this.toCbor());return`{"type": "${this.plutusScriptVersion()}", "description": "", "cborHex": "${t}"}`}hash(){let t=Cbor.encodeBytes(this.serializeBytes());return t.unshift(this.versionTag()),Crypto.blake2b(t,28)}get validatorHash(){const t=this.#Tt.purpose;return assert(null===t||"spending"===t),new ValidatorHash(this.hash())}get mintingPolicyHash(){const t=this.#Tt.purpose;return assert(null===t||"minting"===t),new MintingPolicyHash(this.hash())}get stakingValidatorHash(){const t=this.#Tt.purpose;return assert(null===t||"staking"===t),new StakingValidatorHash(this.hash())}static fromCborWithMapping(t,e,n={purpose:null,callsTxTimeRange:!1}){return"string"==typeof t?UplcProgram.fromCborWithMapping(hexToBytes(t),e,n):(Cbor.isBytes(t)&&(t=Cbor.decodeBytes(t)),Cbor.isBytes(t)&&(t=Cbor.decodeBytes(t)),UplcProgram.fromFlatWithMapping(t,e,n))}static fromCbor(t,e={purpose:null,callsTxTimeRange:!1}){return UplcProgram.fromCborWithMapping(t,[],e)}static fromFlat(t,e={purpose:null,callsTxTimeRange:!1}){return UplcProgram.fromFlatWithMapping(t,[],e)}static fromFlatWithMapping(t,e,n={purpose:null,callsTxTimeRange:!1}){const r=new UplcDeserializer(t,e),s=[r.readInteger(),r.readInteger(),r.readInteger()],a=s.map((t=>t.toString())).join("."),i=r.readTerm();return r.finalize(),a!=UPLC_VERSION&&console.error(`Warning: Plutus-core script doesn't match version of Helios (expected ${UPLC_VERSION}, got ${a})`),new UplcProgram(i,n,s)}static transferUplcProgram(t,e,n){if(t instanceof UplcTerm){if(n.every((t=>t instanceof UplcInt)))return new UplcProgram(t,e,n);throw new Error("program version ints not transferred correctly")}throw new Error("program expr not transferred correctly")}static get transferUplcAst(){return{transferByteArrayData:t=>new ByteArrayData(t),transferConstrData:(t,e)=>new ConstrData(t,e),transferIntData:t=>new IntData(t),transferListData:t=>new ListData(t),transferMapData:t=>new MapData(t),transferSite:(t,e,n,r=null)=>new Site(t,e,n,r),transferSource:(t,e)=>new Source(t,e?.toString()??"<>"),transferUplcBool:(t,e)=>new UplcBool(t,e),transferUplcBuiltin:(t,e)=>new UplcBuiltin(t,e),transferUplcByteArray:(t,e)=>new UplcByteArray(t,e),transferUplcCall:(t,e,n)=>new UplcCall(t,e,n),transferUplcConst:t=>new UplcConst(t),transferUplcDataValue:(t,e)=>new UplcDataValue(t,e),transferUplcDelay:(t,e)=>new UplcDelay(t,e),transferUplcError:(t,e)=>new UplcError(t,e),transferUplcForce:(t,e)=>new UplcForce(t,e),transferUplcInt:(t,e,n)=>new UplcInt(t,e,n),transferUplcLambda:(t,e,n=null)=>new UplcLambda(t,e,n),transferUplcList:(t,e,n)=>new UplcList(t,e,n),transferUplcPair:(t,e,n)=>new UplcPair(t,e,n),transferUplcString:(t,e)=>new UplcString(t,e),transferUplcType:t=>new UplcType(t),transferUplcUnit:t=>new UplcUnit(t),transferUplcVariable:(t,e)=>new UplcVariable(t,e)}}}class UplcDeserializer extends BitReader{#bt;constructor(t,e=[]){super(t),this.#bt=e}tagWidth(t){return assert(t in UPLC_TAG_WIDTHS,`unknown tag category ${t.toString()}`),UPLC_TAG_WIDTHS[t]}builtinName(t){let e=UPLC_BUILTINS;return t>=0&&t<e.length?e[t].name:t>=UPLC_MACROS_OFFSET&&t<UPLC_MACROS_OFFSET+UPLC_MACROS.length?`macro__${assertDefined(UPLC_MACROS[t-UPLC_MACROS_OFFSET])}`:(console.error(`Warning: builtin id ${t.toString()} out of range`),t)}readLinkedList(t){return 0==this.readBits(1)?[]:[this.readBits(t)].concat(this.readLinkedList(t))}readTerm(){let t=this.readBits(this.tagWidth("term"));switch(t){case 0:return this.readVariable();case 1:return this.readDelay();case 2:return this.readLambda();case 3:return this.readCall();case 4:return this.readConstant();case 5:return this.readForce();case 6:return new UplcError(Site.dummy());case 7:return this.readBuiltin();case 11:return this.readCallWithSite();case 13:return this.readForceWithSite();default:throw new Error("term tag "+t.toString()+" unhandled")}}readInteger(t=!1){let e=[],n=this.readByte();for(e.push(n);!UplcInt.rawByteIsLast(n);)n=this.readByte(),e.push(n);let r=new UplcInt(Site.dummy(),UplcInt.bytesToBigInt(e.map((t=>UplcInt.parseRawByte(t)))),!1);return t&&(r=r.toSigned()),r}readBytes(){this.moveToByteBoundary(!0);let t=[],e=this.readByte();for(;e>0;){for(let n=0;n<e;n++)t.push(this.readByte());e=this.readByte()}return t}readByteArray(){let t=this.readBytes();return new UplcByteArray(Site.dummy(),t)}readString(){let t=bytesToText(this.readBytes());return new UplcString(Site.dummy(),t)}readList(t){let e=[];for(;1==this.readBits(1);)e.push(t());return e}readData(){let t=this.readBytes();return UplcData.fromCbor(t)}readVariable(){let t=this.readInteger();return new UplcVariable(Site.dummy(),t)}readLambda(){let t=this.readTerm();return new UplcLambda(Site.dummy(),t)}readCall(){let t=this.readTerm(),e=this.readTerm();return new UplcCall(Site.dummy(),t,e)}readCallWithSite(){let[t,e]=[Number(this.readInteger().value),Number(this.readInteger().value)];const n=assertDefined(this.#bt[t],"serialized UplcProgram contains codeMapping symbols, requires list of original sources");let r=new Site(n,e);r=new Site(n,e,void 0,r);let s=this.readTerm(),a=this.readTerm();return new UplcCall(r,s,a)}readConstant(){let t=this.readLinkedList(this.tagWidth("constType"));return new UplcConst(this.readTypedValue(t))}readTypedValue(t){const e=this.constructTypedReader(t);return assertEq(t.length,0,"Did not consume all type parameters"),e()}constructTypedReader(t){const e=assertDefined(t.shift());switch(e){case 0:return()=>this.readInteger(!0);case 1:return()=>this.readByteArray();case 2:return()=>this.readString();case 3:return()=>new UplcUnit(Site.dummy());case 4:return()=>new UplcBool(Site.dummy(),1==this.readBits(1));case 5:case 6:throw new Error("unexpected type tag without type application");case 7:let n=assertDefined(t.shift());if(5==n){const e=UplcType.fromNumbers(t),n=this.constructTypedReader(t);return()=>new UplcList(Site.dummy(),e,this.readList(n))}if(assertEq(n,7,"Unexpected type tag"),n=assertDefined(t.shift()),6==n){const e=this.constructTypedReader(t),n=this.constructTypedReader(t);return()=>new UplcPair(Site.dummy(),e(),n())}case 8:return()=>new UplcDataValue(Site.dummy(),this.readData());default:throw new Error(`unhandled constant type ${e.toString()}`)}}readDelay(){let t=this.readTerm();return new UplcDelay(Site.dummy(),t)}readForce(){let t=this.readTerm();return new UplcForce(Site.dummy(),t)}readForceWithSite(){let[t,e]=[Number(this.readInteger().value),Number(this.readInteger().value)];const n=assertDefined(this.#bt[t],"serialized UplcProgram contains codeMapping symbols, requires list of original sources");let r=new Site(n,e);r=new Site(n,e,void 0,r);let s=this.readTerm();return new UplcForce(r,s)}readBuiltin(){let t=this.readBits(this.tagWidth("builtin")),e=this.builtinName(t);return new UplcBuiltin(Site.dummy(),e)}finalize(){this.moveToByteBoundary(!0),assert(this.eof(),"not at end")}}export function deserializeUplcBytes(t,e={purpose:null,callsTxTimeRange:!1}){return UplcProgram.fromFlat(t,e)}export function deserializeUplc(t){const e="string"==typeof t?JSON.parse(t):t;if(!("cborHex"in e))throw UserError.syntaxError(new Source("string"==typeof t?t:JSON.stringify(t,void 0,4),"<json>"),0,1,"cborHex field not in json");let n=e.cborHex;if("string"!=typeof n){const e="string"==typeof t?t:JSON.stringify(t,void 0,4),n=new Source(e,"<json>"),r=/cborHex/;if(null===e.match(r))throw UserError.syntaxError(n,0,1,"'cborHex' key not found");{const t=e.search(r);throw UserError.syntaxError(n,t,t+1,"cborHex not a string")}}return UplcProgram.fromCbor(hexToBytes(n))}export class Tokenizer{#_;#e;#xt;#It;#Et;#Ct;constructor(t,e=null,n=!1){assert(t instanceof Source),this.#_=t,this.#e=0,this.#xt=[],this.#It=e,this.#Et=0,this.#Ct=n}incrPos(){this.#e+=1}decrPos(){this.#e-=1,assert(this.#e>=0)}get currentSite(){return new Site(this.#_,this.#e)}pushToken(t){if(this.#xt.push(t),null!==this.#It&&this.#Et<this.#It.length){let e=this.#It[this.#Et];e[0]==t.site.startPos&&(t.site.setCodeMapSite(e[1]),this.#Et+=1)}}readChar(){let t;return assert(this.#e>=0),t=this.#e<this.#_.length?this.#_.getChar(this.#e):"\0",this.incrPos(),t}peekChar(){return assert(this.#e>=0),this.#e<this.#_.length?this.#_.getChar(this.#e):"\0"}unreadChar(){this.decrPos()}readToken(t,e){"b"==e?this.readMaybeUtf8ByteArray(t):"_"==e||e>="A"&&e<="Z"||e>="a"&&e<="z"||this.#Ct&&("@"==e||"["==e||"]"==e)?this.readWord(t,e):"/"==e?this.readMaybeComment(t):"0"==e?this.readSpecialInteger(t):e>="1"&&e<="9"?this.readDecimal(t,e):"#"==e?this.readByteArray(t):'"'==e?this.readString(t):"?"==e||"!"==e||"%"==e||"&"==e||e>="("&&e<="."||e>=":"&&e<=">"||"["==e||"]"==e||e>="{"&&e<="}"?this.readSymbol(t,e):" "!=e&&"\n"!=e&&"\t"!=e&&"\r"!=e&&t.syntaxError(`invalid source character '${e}' (utf-8 not yet supported outside string literals)`)}tokenize(){this.#xt=[];let t=this.currentSite,e=this.readChar();for(;"\0"!=e;)this.readToken(t,e),t=this.currentSite,e=this.readChar();return this.nestGroups(this.#xt)}*streamTokens(){this.#xt=[];let t=this.currentSite,e=this.readChar();for(;"\0"!=e;){this.readToken(t,e);let n=this.#xt.shift();for(;null!=n;)yield n,n=this.#xt.shift();t=this.currentSite,e=this.readChar()}assert(0==this.#xt.length)}readWord(t,e){let n=[],r=e;for(;"\0"!=r;){if(!("_"==r||r>="0"&&r<="9"||r>="A"&&r<="Z"||r>="a"&&r<="z"||this.#Ct&&("@"==r||"["==r||"]"==r))){this.unreadChar();break}n.push(r),r=this.readChar()}let s=n.join("");"true"==s||"false"==s?this.pushToken(new BoolLiteral(new Site(t.src,t.startPos,this.currentSite.startPos),"true"==s)):this.pushToken(new Word(new Site(t.src,t.startPos,this.currentSite.startPos),s))}readMaybeComment(t){let e=this.readChar();"\0"==e?this.pushToken(new SymbolToken(t,"/")):"/"==e?this.readSingleLineComment():"*"==e?this.readMultiLineComment(t):(this.pushToken(new SymbolToken(t,"/")),this.unreadChar())}readSingleLineComment(){let t=this.readChar();for(;"\n"!=t&&"\0"!=t;)t=this.readChar()}readMultiLineComment(t){let e="",n=this.readChar();for(;e=n,n=this.readChar(),"/"!=n||"*"!=e;)if("\0"==n){return void new Site(t.src,t.startPos,this.currentSite.startPos).syntaxError("unterminated multiline comment")}}readSpecialInteger(t){let e=this.readChar();"\0"==e?this.pushToken(new IntLiteral(t,0n)):"b"==e?this.readBinaryInteger(t):"o"==e?this.readOctalInteger(t):"x"==e?this.readHexInteger(t):e>="A"&&e<="Z"||e>="a"&&e<="z"?t.syntaxError(`bad literal integer type 0${e}`):e>="0"&&e<="9"?t.syntaxError("unexpected leading 0"):"."==e?this.readFixedPoint(t,["0"]):(this.pushToken(new IntLiteral(t,0n)),this.unreadChar())}readBinaryInteger(t){this.readRadixInteger(t,"0b",(t=>"0"==t||"1"==t))}readOctalInteger(t){this.readRadixInteger(t,"0o",(t=>t>="0"&&t<="7"))}readHexInteger(t){this.readRadixInteger(t,"0x",(t=>t>="0"&&t<="9"||t>="a"&&t<="f"))}static assertCorrectDecimalUnderscores(t,e,n=!1){if(e.some((t=>"_"==t))){for(let r=0;r<e.length;r++){const s=n?e[e.length-1-r]:e[r];r==e.length-1&&"_"==s&&t.syntaxError("redundant decimal underscore"),(r+1)%4==0?"_"!=s&&t.syntaxError("bad decimal underscore"):"_"==s&&t.syntaxError("bad decimal underscore")}return e.filter((t=>"_"!=t))}return e}readDecimal(t,e){let n=[],r=e;for(;"\0"!=r;){if(!(r>="0"&&r<="9"||"_"==r)){if(r>="0"&&r<="9"||r>="A"&&r<="Z"||r>="a"&&r<="z"){new Site(t.src,t.startPos,this.currentSite.startPos).syntaxError("invalid syntax for decimal integer literal")}else if("."==r){const e=this.peekChar();if(e>="0"&&e<="9")return void this.readFixedPoint(t,n)}this.unreadChar();break}n.push(r),r=this.readChar()}const s=new Site(t.src,t.startPos,this.currentSite.startPos);n=Tokenizer.assertCorrectDecimalUnderscores(s,n,!0),this.pushToken(new IntLiteral(s,BigInt(n.filter((t=>"_"!=t)).join(""))))}readRadixInteger(t,e,n){let r=this.readChar(),s=[];if(!n(r)){return new Site(t.src,t.startPos,this.currentSite.startPos).syntaxError(`expected at least one char for ${e} integer literal`),void this.unreadChar()}for(;"\0"!=r;){if(!n(r)){if(r>="0"&&r<="9"||r>="A"&&r<="Z"||r>="a"&&r<="z"){new Site(t.src,t.startPos,this.currentSite.startPos).syntaxError(`invalid syntax for ${e} integer literal`)}this.unreadChar();break}s.push(r),r=this.readChar()}this.pushToken(new IntLiteral(new Site(t.src,t.startPos,this.currentSite.startPos),BigInt(e+s.join(""))))}readFixedPoint(t,e){let n=[],r=this.readChar();for(;"\0"!=r;){if(!(r>="0"&&r<="9"||"_"==r)){this.unreadChar();break}n.push(r),r=this.readChar()}const s=new Site(t.src,t.startPos,this.currentSite.startPos);for(e=Tokenizer.assertCorrectDecimalUnderscores(s,e,!0),n=Tokenizer.assertCorrectDecimalUnderscores(s,n,!1),n.length>6&&(s.syntaxError(`literal real decimal places overflow (max 6 supported, but ${n.length} specified)`),n.splice(6));n.length<6;)n.push("0");this.pushToken(new RealLiteral(s,BigInt(e.concat(n).join(""))))}readByteArray(t){let e=this.readChar(),n=[];for(;e>="a"&&e<="f"||e>="0"&&e<="9";)n.push(e),e=this.readChar();this.unreadChar();let r=hexToBytes(n.join(""));this.pushToken(new ByteArrayLiteral(new Site(t.src,t.startPos,this.currentSite.startPos),r))}readMaybeUtf8ByteArray(t){if('"'==this.readChar()){const e=this.readStringInternal(t);this.pushToken(new ByteArrayLiteral(new Site(t.src,t.startPos,this.currentSite.startPos),textToBytes(e)))}else this.unreadChar(),this.readWord(t,"b")}readStringInternal(t){let e=this.readChar(),n=[],r=!1,s=null;for(;r||'"'!=e;){if("\0"==e){t.syntaxError("unmatched '\"'");break}if(r){if("n"==e)n.push("\n");else if("t"==e)n.push("\t");else if("\\"==e)n.push("\\");else if('"'==e)n.push(e);else{if(null===s)throw new Error("escape site should be non-null");new Site(s.src,s.startPos,this.currentSite.startPos).syntaxError(`invalid escape sequence ${e}`)}r=!1,s=null}else"\\"==e?(s=this.currentSite,r=!0):n.push(e);e=this.readChar()}return n.join("")}readString(t){const e=this.readStringInternal(t);this.pushToken(new StringLiteral(new Site(t.src,t.startPos,this.currentSite.startPos),e))}readSymbol(t,e){let n=[e],r=t=>{let e=this.readChar();return e==t?(n.push(e),!0):(this.unreadChar(),!1)};"|"==e?r("|"):"&"==e?r("&"):"="==e?r("=")||r(">"):"!"==e||"<"==e||">"==e?r("="):":"==e?r(":"):"-"==e&&r(">"),this.pushToken(new SymbolToken(new Site(t.src,t.startPos,t.endPos),n.join("")))}static buildGroup(t){const e=assertDefined(t.shift()).assertSymbol();if(!e)return null;const n=[e];let r=[],s=[],a=null,i=null,o=null;for(;n.length>0&&t.length>0;){const _=assertToken(t.shift(),e.site);if(!_)return null;const l=n.pop();if(o=_.site,null==_||null==l)throw new Error("unexpected");if(_.isSymbol(Group.matchSymbol(l)))n.length>0&&r.push(_);else{if(n.push(l),Group.isCloseSymbol(_))return _.site.syntaxError(`unmatched '${assertDefined(_.assertSymbol()).value}'`),null;if(Group.isOpenSymbol(_))n.push(assertDefined(_.assertSymbol())),r.push(_);else if(_.isSymbol(",")&&1==n.length){if(null===a&&(a=_.assertSymbol()),i=_.assertSymbol(),0==r.length)return _.site.syntaxError("empty field"),null;s.push(r),r=[]}else r.push(_)}}let _=n.pop();if(null!=_)return _.syntaxError(`EOF while matching '${_.value}'`),null;if(r.length>0)s.push(r);else if(null!==i)return i.syntaxError("trailing comma"),null;let l=e.site;return o&&(l=l.merge(o)),new Group(l,e.value,s,a)}nestGroups(t){const e=[];let n=[];for(let r of t)if(Group.isOpenSymbol(r))e.push(n),n=[r];else if(Group.isCloseSymbol(r)){const t=n[0]?.assertSymbol();if(!t)return null;if(!r.isSymbol(Group.matchSymbol(t)))return t.syntaxError(`unmatched '${t.value}'`),r.syntaxError(`unmatched '${assertDefined(r.assertSymbol()).value}'`),null;n.push(r);const s=Tokenizer.buildGroup(n);if(!s)return null;n=assertDefined(e.pop()),n.push(s)}else n.push(r);if(e.length>0){const t=e[e.length-1][0];if(t.isSymbol())t.syntaxError(`unmatched '${t.assertSymbol()?.value}'`);else if(n.length>0){const t=n[0];if(!t||!t.isSymbol())throw console.log(n),new Error("unhandled");t.syntaxError(`unmatched '${t.assertSymbol()?.value}`)}}return n}}export function tokenize(t){return new Tokenizer(t).tokenize()}export function tokenizeIR(t,e=[]){let n=new Source(t,"<ir>");const r=new Tokenizer(n,e,!0).tokenize();if(n.errors.length>0)throw console.log(n.pretty()),n.errors[0];if(null===r)throw new Error("should've been thrown above");return r}export function applyTypes(t,...e){return assertDefined(t.apply(e).asDataType)}export class Common{constructor(){}isParametric(){return!1}static instanceOf(t,e){return e.isBaseOf(t.type)}static typesEq(t,e){return t.isBaseOf(e)&&e.isBaseOf(t)}static isEnum(t){return Object.values(t.typeMembers).some((t=>t.asEnumMemberType))}static countEnumMembers(t){return Object.values(t.typeMembers).reduce(((t,e)=>e.asEnumMemberType?t+1:t),0)}static typeClassMembers(t){const e=t.toType("",""),n=Object.keys(t.genTypeMembers(e)).sort(),r=Object.keys(t.genInstanceMembers(e)).sort();return n.concat(r)}static typeImplements(t,e){if(t instanceof AllType||!1===t.asDataType?.ready)return!0;const n=e.genTypeMembers(t);for(let e in n){const r=t.typeMembers[e]?.asType;if(r&&!n[e].asType?.isBaseOf(r)||!r)return!1}const r=e.genInstanceMembers(t);for(let e in r){const n=t.instanceMembers[e]?.asType;if(n&&!r[e].asType?.isBaseOf(n)||!n)return!1}return!0}get asDataType(){return null}get asEnumMemberType(){return null}get asFunc(){return null}get asInstance(){return null}get asNamed(){return null}get asNamespace(){return null}get asParametric(){return null}get asType(){return null}get asTyped(){return this.asInstance??this.asFunc}get asTypeClass(){return null}get ready(){return!0}jsToUplc(t,e){throw new Error("not yet implemented")}uplcToJs(t,e){throw new Error("not yet implemented")}toString(){throw new Error("not yet implemented")}}export class AllType extends Common{constructor(){super()}get asDataType(){return this}get asNamed(){return this}get asType(){return this}get offChainType(){return null}get fieldNames(){return[]}get instanceMembers(){return{}}get name(){return""}get path(){return""}get typeMembers(){return{}}infer(t,e,n){return this}isBaseOf(t){return!0}toTyped(){throw new Error("can't be turned into a type")}toString(){return"All"}}export class AnyType extends Common{constructor(){super()}get fieldNames(){return[]}get offChainType(){return null}get name(){return"Any"}get path(){return""}get asType(){return this}get asNamed(){return this}get asDataType(){return this}get instanceMembers(){return{}}get typeMembers(){return{}}infer(t,e,n){return this}isBaseOf(t){return!0}toTyped(){throw new Error("can't be turned into a type")}toString(){return"Any"}}export class ErrorType extends Common{constructor(){super()}get instanceMembers(){return{}}get typeMembers(){return{}}get asType(){return this}infer(t,e,n){return this}isBaseOf(t){return t instanceof ErrorType}toString(){return"()"}toTyped(){return new ErrorEntity}}export class ArgType{#i;#f;#St;constructor(t,e,n=!1){this.#i=t,this.#f=assertDefined(e),this.#St=n}get name(){return null===this.#i?"":this.#i.toString()}get type(){return this.#f}infer(t,e,n){return new ArgType(this.#i,this.#f.infer(t,e,n),this.#St)}isBaseOf(t){return!(this.#St&&!t.#St)&&(null!=this.#i?this.#i.toString()==(t.#i?.toString()??""):!!t.#f.isBaseOf(this.#f))}isNamed(){return null!==this.#i}isOptional(){return this.#St}toString(){return[null!=this.#i?`${this.#i.toString()}: `:"",this.#St?"?":"",this.#f.toString()].join("")}}export class FuncType extends Common{#vt;#Rt;constructor(t,e){super(),this.#vt=t.map((t=>t instanceof ArgType?t:new ArgType(null,t))),this.#Rt=e}get argTypes(){return this.#vt.slice().map((t=>t.type))}get instanceMembers(){return{}}get nArgs(){return this.#vt.length}get nNonOptArgs(){return this.#vt.filter((t=>!t.isOptional())).length}get nOptArgs(){return this.#vt.filter((t=>t.isOptional())).length}get retType(){return this.#Rt}get typeMembers(){return{}}get asType(){return this}expandTuplesInPosArgs(t){let e=(t=t.slice()).shift(),n=[],r=0;for(;e;){if(r<this.#vt.length&&Common.instanceOf(e,this.#vt[r].type))n.push(e),r++;else{const t=getTupleItemTypes(e.type);t&&t.every(((t,e)=>r+e<this.#vt.length&&Common.instanceOf(t.toTyped(),this.#vt[r+e].type)))?(n=n.concat(t.map((t=>t.toTyped()))),r+=t.length):(n.push(e),r++)}e=t.shift()}return n}checkCall(t,e,n={}){if((e=this.expandTuplesInPosArgs(e)).length<this.nNonOptArgs)for(let r=0;r<this.nNonOptArgs;r++){if(!this.#vt[r].isNamed())return t.typeError(`expected at least ${this.#vt.filter((t=>!t.isNamed())).length} positional arg(s), got ${e.length} positional arg(s)`),null;if(!(this.#vt[r].name in n))return t.typeError(`expected at least ${this.nNonOptArgs} arg(s), missing '${this.#vt[r].name}'`),null}else if(e.length>this.#vt.length)return t.typeError(`expected at most ${this.#vt.length} arg(s), got ${e.length} arg(s)`),null;for(let n=0;n<e.length;n++)if(!Common.instanceOf(e[n],this.#vt[n].type))return t.typeError(`expected '${this.#vt[n].type.toString()}' for arg ${n+1}, got '${e[n].type.toString()}'`),null;for(let r in n){const s=this.#vt.findIndex((t=>t.name==r));if(-1==s){t.typeError(`arg named ${r} not found in function type ${this.toString()}`);continue}if(s<e.length){t.typeError(`named arg '${r}' already covered by positional arg ${s+1}`);continue}const a=this.#vt[s];Common.instanceOf(n[r],a.type)||t.typeError(`expected '${a.type.toString()}' for arg '${r}', got '${n[r].toString()}`)}return this.#Rt}infer(t,e,n){if(!n)return new FuncType(this.#vt.map((n=>n.infer(t,e,null))),this.#Rt.infer(t,e,null));if(n instanceof FuncType&&n.argTypes.length==this.#vt.length)return new FuncType(this.#vt.map(((r,s)=>r.infer(t,e,n.argTypes[s]))),this.#Rt.infer(t,e,n.retType));throw t.typeError(`unable to infer type of ${this.toString()}`)}inferArgs(t,e,n){if(n.length==this.argTypes.length)return new FuncType(this.#vt.map(((r,s)=>r.infer(t,e,n[s]))),this.#Rt.infer(t,e,null));throw t.typeError(`expected ${this.argTypes.length} arg(s), got ${n.length}`)}isAssociated(t,e){for(let t of this.#vt)if(Common.typesEq(t.type,e))return!0;return!!Common.typesEq(e,this.#Rt)}isBaseOf(t){if(t instanceof FuncType){if(this.nNonOptArgs!=t.nNonOptArgs)return!1;for(let e=0;e<this.nNonOptArgs;e++)if(!this.#vt[e].isBaseOf(t.#vt[e]))return!1;return!!this.#Rt.isBaseOf(t.#Rt)}return!1}isMaybeMethod(t,e){return this.#vt.length>0&&Common.typesEq(this.#vt[0].type,e)}toString(){return`(${this.#vt.map((t=>t.toString())).join(", ")}) -> ${this.#Rt.toString()}`}getNamedIndex(t,e){const n=this.#vt.findIndex((t=>t.name==e));if(-1==n)throw t.typeError(`arg name ${e} not found`);return n}toTyped(){return new FuncEntity(this)}}export class GenericType extends Common{#i;#Pt;#Dt;#Ft;#$t;#kt;#Bt;#At;#Mt;#Ut;#Nt;#Lt;#Vt;constructor({name:t,path:e,offChainType:n,genOffChainType:r,fieldNames:s,genInstanceMembers:a,genTypeMembers:i,genTypeDetails:o,jsToUplc:_,uplcToJs:l}){super(),this.#i=t,this.#Pt=e??`__helios__${t.toLowerCase()}`,this.#Dt=r??null,this.#Ft=n??null,this.#$t=s??[],this.#kt=a,this.#Bt=i,this.#At=null,this.#Mt=null,this.#Ut=o??null,this.#Nt=0,this.#Lt=_??null,this.#Vt=l??null}get asDataType(){return this}get asNamed(){return this}get asType(){return this}get fieldNames(){return this.#$t}get instanceMembers(){return this.#At||(this.#At=this.#kt(this)),this.#At}get name(){return this.#i}get offChainType(){return this.#Ft?this.#Ft:this.#Dt?this.#Dt():null}get typeDetails(){if(this.#Ut)return this.#Ut(this);throw new Error(`typeDetails not available for ${this.toString()}`)}get path(){return this.#Pt}get ready(){return this.#Nt<2}get typeMembers(){return this.#Mt||(this.#Nt+=1,this.#Mt=this.#Bt(this),this.#Nt-=1),this.#Mt}applyInternal(t,e){return{name:this.#i,path:this.#Pt,fieldNames:this.#$t,genInstanceMembers:n=>{const r={},s=this.#kt(n);for(let n in s){const a=s[n];if(a.asParametric)r[n]=a.asParametric.infer(t,e);else{if(!a.asType)throw new Error("unhandled");r[n]=a.asType.infer(t,e,null)}}return r},genTypeMembers:n=>{const r={},s=this.#Bt(n);for(let n in s){const a=s[n];if(a.asParametric)r[n]=a.asParametric.infer(t,e);else if(a.asTyped)r[n]=a.asTyped.type.infer(t,e,null).toTyped();else{if(!a.asType)throw new Error("unhandled");r[n]=a.asType.infer(t,e,null)}}return r}}}infer(t,e,n){return this}changeNameAndPath(t,e){return new GenericType({name:t,path:e,fieldNames:this.#$t,genInstanceMembers:this.#kt,genTypeMembers:this.#Bt})}isBaseOf(t){return t.asEnumMemberType?this.isBaseOf(t.asEnumMemberType.parentType):!!t.asNamed&&t.asNamed.path==this.#Pt}jsToUplc(t,e){if(this.#Lt)return this.#Lt(t,e);throw new Error(`'${this.name}' doesn't support converting from JS to Uplc`)}uplcToJs(t,e){if(this.#Vt)return this.#Vt(t,e);throw new Error(`'${this.name}' doesn't support converting from Uplc to JS`)}toString(){return this.name}toTyped(){return new DataEntity(this)}}export class GenericEnumMemberType extends GenericType{#Ot;#Ht;constructor({name:t,path:e,constrIndex:n,parentType:r,offChainType:s,genOffChainType:a,fieldNames:i,genInstanceMembers:o,genTypeMembers:_,genTypeDetails:l,jsToUplc:u,uplcToJs:c}){super({name:t,path:e??`${r.path}__${t.toLowerCase()}`,genOffChainType:a,offChainType:s,fieldNames:i,genInstanceMembers:o,genTypeMembers:_??(t=>({})),genTypeDetails:l,jsToUplc:u,uplcToJs:c}),this.#Ot=n,this.#Ht=r}get constrIndex(){return this.#Ot}get parentType(){return this.#Ht}get asEnumMemberType(){return this}infer(t,e,n){return this}isBaseOf(t){return t instanceof GenericEnumMemberType&&t.path==this.path}toString(){return`${this.#Ht.toString()}::${this.name}`}}export class VoidType extends Common{constructor(){super()}get instanceMembers(){return{}}get typeMembers(){return{}}get asType(){return this}infer(t,e,n){return this}isBaseOf(t){return t instanceof VoidType}toString(){return"()"}toTyped(){return new VoidEntity}}export class DataEntity extends Common{#f;constructor(t){super(),assert(!(t instanceof FuncType)),this.#f=t}get fieldNames(){return this.#f.fieldNames}get instanceMembers(){return this.#f.instanceMembers}get type(){return this.#f}get asInstance(){return this}get asTyped(){return this}toString(){return this.#f.toString()}}export class ErrorEntity extends Common{constructor(){super()}get fieldNames(){return[]}get instanceMembers(){return{}}get type(){return new ErrorType}get asInstance(){return this}get asTyped(){return this}toString(){return"()"}}export class NamedEntity{#i;#Pt;#qt;constructor(t,e,n){this.#i=t,this.#Pt=e,this.#qt=n}get asDataType(){return this.#qt.asDataType}get asEnumMemberType(){return this.#qt.asEnumMemberType}get asFunc(){return this.#qt.asFunc}get asInstance(){return this.#qt.asInstance}get asNamed(){return this}get asNamespace(){return this.#qt.asNamespace}get asParametric(){return this.#qt.asParametric}get asType(){return this.#qt.asType}get asTyped(){return this.#qt.asTyped}get asTypeClass(){return this.#qt.asTypeClass}get name(){return this.#i}get path(){return this.#Pt}toString(){return this.#qt.toString()}}export class FuncEntity extends Common{#f;constructor(t){super(),assert(t instanceof FuncType),this.#f=t}get type(){return this.#f}get funcType(){return this.#f}get asFunc(){return this}get asTyped(){return this}call(t,e,n={}){const r=this.#f.checkCall(t,e,n);return null===r?null:r.toTyped()}toString(){return this.#f.toString()}}export class TypedEntity extends Common{#f;constructor(t){super(),this.#f=t}get asTyped(){return this}get type(){return this.#f}}export class VoidEntity extends Common{constructor(){super()}get fieldNames(){return[]}get instanceMembers(){return{}}get type(){return new VoidType}get asInstance(){return this}get asTyped(){return this}toString(){return"()"}}export class ModuleNamespace extends Common{#zt;constructor(t){super(),this.#zt=t}get namespaceMembers(){return this.#zt}get asNamespace(){return this}}export function genCommonInstanceMembers(t){return{serialize:new FuncType([],ByteArrayType),show:new FuncType([],StringType)}}export function genCommonTypeMembers(t){return{__eq:new FuncType([t,t],BoolType),__neq:new FuncType([t,t],BoolType),from_data:new FuncType([RawDataType],t),__to_data:new FuncType([t],RawDataType),is_valid_data:new FuncType([RawDataType],BoolType)}}export function genCommonEnumTypeMembers(t,e){return{__eq:new FuncType([t,e],BoolType),__neq:new FuncType([t,e],BoolType),from_data:new FuncType([RawDataType],t),__to_data:new FuncType([t],RawDataType),is_valid_data:new FuncType([RawDataType],BoolType)}}export const BoolType=new GenericType({name:"Bool",offChainType:Bool,genTypeDetails:t=>({inputType:"boolean",outputType:"boolean",internalType:{type:"Bool"}}),jsToUplc:async(t,e)=>new ConstrData(t?1:0,[]),uplcToJs:async(t,e)=>0!=t.index,genInstanceMembers:t=>({...genCommonInstanceMembers(t),to_int:new FuncType([],IntType),trace:new FuncType([StringType],t),trace_if_false:new FuncType([StringType],t),trace_if_true:new FuncType([StringType],t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__and:new FuncType([t,t],t),__neq:new FuncType([t,t],t),__not:new FuncType([t],t),__or:new FuncType([t,t],t),and:new FuncType([new FuncType([],t),new FuncType([],t)],t),or:new FuncType([new FuncType([],t),new FuncType([],t)],t)})});export const ByteArrayType=new GenericType({name:"ByteArray",offChainType:ByteArray,genTypeDetails:t=>({inputType:"number[] | string",outputType:"number[]",internalType:{type:"ByteArray"}}),jsToUplc:async(t,e)=>{const n=Array.isArray(t)?t:hexToBytes(t);return new ByteArrayData(n)},uplcToJs:async(t,e)=>t.bytes,genInstanceMembers:t=>({...genCommonInstanceMembers(t),blake2b:new FuncType([],t),decode_utf8:new FuncType([],StringType),ends_with:new FuncType([t],BoolType),length:IntType,prepend:new FuncType([IntType],t),sha2:new FuncType([],t),sha3:new FuncType([],t),slice:new FuncType([IntType,IntType],t),starts_with:new FuncType([t],BoolType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,t],t),__geq:new FuncType([t,t],BoolType),__gt:new FuncType([t,t],BoolType),__leq:new FuncType([t,t],BoolType),__lt:new FuncType([t,t],BoolType),parse:new FuncType([StringType],t)})});export const IntType=new GenericType({name:"Int",offChainType:HInt,genTypeDetails:t=>({inputType:"number | bigint",outputType:"bigint",internalType:{type:"Int"}}),jsToUplc:async(t,e)=>new IntData(BigInt(t)),uplcToJs:async(t,e)=>t.int,genInstanceMembers:t=>({...genCommonInstanceMembers(t),abs:new FuncType([],t),bound:new FuncType([t,t],t),bound_max:new FuncType([t],t),bound_min:new FuncType([t],t),decode_zigzag:new FuncType([],t),encode_zigzag:new FuncType([],t),to_base58:new FuncType([],StringType),to_big_endian:new FuncType([],ByteArrayType),to_bool:new FuncType([],BoolType),to_hex:new FuncType([],StringType),to_little_endian:new FuncType([],ByteArrayType),to_real:new FuncType([],RealType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,t],t),__add1:new FuncType([t,RealType],RealType),__div:new FuncType([t,t],t),__div1:new FuncType([t,RealType],RealType),__geq:new FuncType([t,t],BoolType),__gt:new FuncType([t,t],BoolType),__leq:new FuncType([t,t],BoolType),__lt:new FuncType([t,t],BoolType),__mod:new FuncType([t,t],t),__mul:new FuncType([t,t],t),__mul1:new FuncType([t,RealType],RealType),__neg:new FuncType([t],t),__pos:new FuncType([t],t),__sub:new FuncType([t,t],t),__sub1:new FuncType([t,RealType],RealType),from_base58:new FuncType([StringType],t),from_big_endian:new FuncType([ByteArrayType],t),from_little_endian:new FuncType([ByteArrayType],t),max:new FuncType([t,t],t),min:new FuncType([t,t],t),parse:new FuncType([StringType],t),sqrt:new FuncType([t],t)})});export const RawDataType=new GenericType({name:"Data",genInstanceMembers:t=>({...genCommonInstanceMembers(t),tag:IntType}),genTypeMembers:t=>({...genCommonTypeMembers(t)})});export const RealType=new GenericType({name:"Real",genTypeDetails:t=>({inputType:"number",outputType:"number",internalType:{type:"Real"}}),jsToUplc:async(t,e)=>new IntData(BigInt(Math.round(1e6*t))),uplcToJs:async(t,e)=>Number(t.int)/1e6,genInstanceMembers:t=>({...genCommonInstanceMembers(t),abs:new FuncType([],t),ceil:new FuncType([],IntType),floor:new FuncType([],IntType),round:new FuncType([],IntType),trunc:new FuncType([],IntType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,t],t),__add1:new FuncType([t,IntType],t),__div:new FuncType([t,t],t),__div1:new FuncType([t,IntType],t),__eq1:new FuncType([t,IntType],BoolType),__geq:new FuncType([t,t],BoolType),__geq1:new FuncType([t,IntType],BoolType),__gt:new FuncType([t,t],BoolType),__gt1:new FuncType([t,IntType],BoolType),__leq:new FuncType([t,t],BoolType),__leq1:new FuncType([t,IntType],BoolType),__lt:new FuncType([t,t],BoolType),__lt1:new FuncType([t,IntType],BoolType),__mul:new FuncType([t,t],t),__mul1:new FuncType([t,IntType],t),__neg:new FuncType([t],t),__neq1:new FuncType([t,IntType],BoolType),__pos:new FuncType([t],t),__sub:new FuncType([t,t],t),__sub1:new FuncType([t,IntType],t),sqrt:new FuncType([t],t)})});export const StringType=new GenericType({name:"String",offChainType:HString,genTypeDetails:t=>({inputType:"string",outputType:"string",internalType:{type:"String"}}),jsToUplc:async(t,e)=>new ByteArrayData(textToBytes(t)),uplcToJs:async(t,e)=>bytesToText(t.bytes),genInstanceMembers:t=>({...genCommonInstanceMembers(t),encode_utf8:new FuncType([],ByteArrayType),ends_with:new FuncType([t],BoolType),starts_with:new FuncType([t],BoolType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,t],t),is_valid_utf8:new FuncType([ByteArrayType],BoolType)})});export class GenericParametricType extends GenericType{constructor(t){super(t)}infer(t,e,n){if(null!==n)return this;{let n=!1;e.forEach((t=>{t.isParametric()&&(n=!0)}));const r=this.applyInternal(t,e);return n?new GenericParametricType(r):new GenericType(r)}}}export class GenericParametricEnumMemberType extends GenericEnumMemberType{constructor(t){super(t)}infer(t,e,n){if(null!==n)return this;{let n=!1;e.forEach((t=>{t.isParametric()&&(n=!0)}));const r={...this.applyInternal(t,e),parentType:assertDefined(this.parentType.infer(t,e,null).asDataType),constrIndex:this.constrIndex};return n?new GenericParametricEnumMemberType(r):new GenericEnumMemberType(r)}}}export class TypeClassImpl extends Common{#i;#jt;#At;#Mt;constructor(t,e,n){super(),this.#i=e,this.#jt=n,this.#At=t.genInstanceMembers(this),this.#Mt=t.genTypeMembers(this)}isParametric(){return!0}get instanceMembers(){return this.#At}get name(){return this.#i}get typeMembers(){return this.#Mt}get asType(){return this}infer(t,e,n){const r=assertDefined(this.#jt,"unable to infer dummy TypeClass instantiation"),s=e.get(r);return s||(n?(e.set(r,n),n):this)}isBaseOf(t){return t instanceof TypeClassImpl&&t.name==this.name}toString(){return this.name}toTyped(){return new TypedEntity(this)}}export class DataTypeClassImpl extends TypeClassImpl{#Pt;constructor(t,e,n,r){super(t,e,r),this.#Pt=n}get asDataType(){return this}get asNamed(){return this}get fieldNames(){return[]}get offChainType(){return null}get path(){return this.#Pt}toTyped(){return new DataEntity(this)}}export class AnyTypeClass extends Common{constructor(){super()}get asTypeClass(){return this}genInstanceMembers(t){return{}}genTypeMembers(t){return{}}isImplementedBy(t){return!0}toString(){return"Any"}toType(t,e,n=null){return new TypeClassImpl(this,t,n)}}export class DefaultTypeClass extends Common{constructor(){super()}get asTypeClass(){return this}genTypeMembers(t){return{__eq:new FuncType([t,t],BoolType),__neq:new FuncType([t,t],BoolType),__to_data:new FuncType([t],RawDataType),from_data:new FuncType([RawDataType],t)}}genInstanceMembers(t){return{serialize:new FuncType([],ByteArrayType)}}isImplementedBy(t){return Common.typeImplements(t,this)}toString(){return""}toType(t,e,n=null){return new DataTypeClassImpl(this,t,e,n)}}export class SummableTypeClass extends Common{constructor(){super()}get asTypeClass(){return this}genTypeMembers(t){return{__add:new FuncType([t,t],t),__sub:new FuncType([t,t],t)}}genInstanceMembers(t){return{}}isImplementedBy(t){return Common.typeImplements(t,this)}toString(){return"Summable"}toType(t,e,n=null){return new DataTypeClassImpl(this,t,e,n)}}export class Parameter{#i;#Pt;#Wt;constructor(t,e,n){this.#i=t,this.#Pt=e,this.#Wt=n}get name(){return this.#i}get ref(){return this.#Wt.toType(this.#i,this.#Pt,this)}get typeClass(){return this.#Wt}toString(){return this.#Wt&&""!=this.#Wt.toString()?`${this.#i}: ${this.#Wt.toString()}`:this.#i}}export class ParametricFunc extends Common{#Gt;#Kt;constructor(t,e){super(),this.#Gt=t,this.#Kt=e}get offChainType(){return null}get params(){return this.#Gt}get fnType(){return this.#Kt}get typeClasses(){return this.#Gt.map((t=>t.typeClass))}apply(t,e=Site.dummy()){if(t.length!=this.#Gt.length)throw e.typeError("wrong number of parameter type arguments");const n=new Map;this.#Gt.forEach(((r,s)=>{if(!r.typeClass.isImplementedBy(t[s]))throw e.typeError("typeclass match failed");n.set(r,t[s])}));const r=this.#Kt.infer(e,n,null);return new FuncEntity(assertClass(r,FuncType))}get asParametric(){return this}inferCall(t,e,n={},r=[]){const s=new Map,a=this.#Kt.inferArgs(t,s,e.map((t=>t.type)));return this.#Gt.forEach((e=>{const n=s.get(e);if(!n)throw t.typeError(`failed to infer type of '${e.name}'  (hint: apply directly using [...])`);r.push(n)})),new FuncEntity(a)}infer(t,e){const n=assertClass(this.#Kt.infer(t,e,null),FuncType);return new ParametricFunc(this.#Gt,n)}toString(){return`[${this.#Gt.map((t=>t.toString())).join(", ")}]${this.#Kt.toString()}`}}class AppliedType extends Common{#Jt;#Zt;#Yt;constructor(t,e,n){super(),this.#Jt=t,this.#Zt=e,this.#Yt=n}get fieldNames(){return this.#Yt.fieldNames}get instanceMembers(){return this.#Yt.instanceMembers}get name(){return this.#Yt.name}get offChainType(){return this.#Yt.offChainType}get path(){return this.#Yt.path}get typeMembers(){return this.#Yt.typeMembers}get typeDetails(){return this.#Yt.typeDetails}get asDataType(){return this}get asNamed(){return this}get asType(){return this}jsToUplc(t,e){return this.#Yt.jsToUplc(t,e)}uplcToJs(t,e){return this.#Yt.uplcToJs(t,e)}infer(t,e,n){if(n){if(n instanceof AppliedType&&n.#Jt.length==this.#Jt.length){const r=this.#Jt.map(((r,s)=>r.infer(t,e,n.#Jt[s]))),s=new AppliedType(r,this.#Zt,this.#Zt(r));if(!s.isBaseOf(n))throw t.typeError("unable to infer type");return s}throw t.typeError("unable to infer type")}{const n=this.#Jt.map((n=>n.infer(t,e,null)));return new AppliedType(n,this.#Zt,this.#Zt(n))}}isBaseOf(t){return this.#Yt.isBaseOf(t)}toString(){return this.#Yt.toString()}toTyped(){return new DataEntity(this)}}export class ParametricType extends Common{#i;#Ft;#Xt;#Zt;constructor({name:t,offChainType:e,parameters:n,apply:r}){super(),this.#i=t,this.#Ft=e??null,this.#Xt=n,this.#Zt=r}get asParametric(){return this}get offChainType(){return this.#Ft}get typeClasses(){return this.#Xt.map((t=>t.typeClass))}apply(t,e=Site.dummy()){if(t.length!=this.#Xt.length)throw e.typeError(`expected ${this.#Xt.length} type parameter(s), got ${t.length}`);return this.#Xt.forEach(((n,r)=>{if(!n.typeClass.isImplementedBy(t[r]))throw e.typeError(`${t[r].toString()} doesn't implement ${n.typeClass.toString()}`)})),new AppliedType(t,this.#Zt,this.#Zt(t))}inferCall(t,e,n={},r=[]){throw t.typeError("not a parametric function")}infer(t,e){throw t.typeError("not a parametric function")}toString(){return`${this.#i}`}}export class BuiltinFunc extends Common{#i;#f;constructor({name:t,type:e}){super(),this.#i=t,this.#f=e}get name(){return this.#i}get path(){return`__helios__${this.#i}`}get type(){return this.#f}get funcType(){return this.#f}get asFunc(){return this}get asNamed(){return this}get asTyped(){return this}call(t,e,n={}){const r=this.#f.checkCall(t,e,n);return r?r.toTyped():null}toString(){return this.name}}export const AssertFunc=new BuiltinFunc({name:"assert",type:new FuncType([BoolType,StringType],new VoidType)});export const ErrorFunc=new BuiltinFunc({name:"error",type:new FuncType([StringType],new ErrorType)});export const PrintFunc=new BuiltinFunc({name:"print",type:new FuncType([StringType],new VoidType)});export function IteratorType$(t){const e={name:`Iterator[${t.map((t=>t.toString())).join(", ")}]`,path:`__helios__iterator__${t.length}`,genInstanceMembers:e=>{const n=1==t.length?t[0]:TupleType$(t),r={any:new FuncType([new FuncType(t,BoolType)],BoolType),drop:new FuncType([IntType],e),filter:new FuncType([new FuncType(t,BoolType)],e),find:new FuncType([new FuncType(t,BoolType)],n),for_each:new FuncType([new FuncType(t,new VoidType)],new VoidType),fold:(()=>{const e=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([e],new FuncType([new FuncType([e.ref].concat(t),e.ref),e.ref],e.ref))})(),head:n,get:new FuncType([IntType],n),get_singleton:new FuncType([],n),is_empty:new FuncType([],BoolType),map:(()=>{const e=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([e],new FuncType([new FuncType(t,e.ref)],IteratorType$([e.ref])))})(),map2:(()=>{const e=new Parameter("a",`${FTPP}0`,new AnyTypeClass),n=new Parameter("b",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([e,n],new FuncType([new FuncType(t,TupleType$([e.ref,n.ref]))],IteratorType$([e.ref,n.ref])))})(),prepend:new FuncType(t,e),tail:e,take:new FuncType([IntType],e)};return t.length<10&&(r.zip=(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([e],new FuncType([ListType$(e.ref)],IteratorType$(t.concat([e.ref]))))})()),r},genTypeMembers:t=>({})};return t.some((t=>t.isParametric()))?new GenericParametricType(e):new GenericType(e)}export class TupleType extends GenericType{#Qt;constructor(t,e){super(t),this.#Qt=e}get itemTypes(){return this.#Qt}isBaseOf(t){return t instanceof TupleType&&(t.#Qt.length==this.#Qt.length&&this.#Qt.every(((e,n)=>e.isBaseOf(t.#Qt[n]))))}infer(t,e,n){if(!this.#Qt.some((t=>t.isParametric())))return this;if(!n){return TupleType$(this.#Qt.map((n=>n.infer(t,e,null))))}if(n instanceof TupleType&&this.#Qt.length==n.#Qt.length){return TupleType$(this.#Qt.map(((r,s)=>r.infer(t,e,n.#Qt[s]))))}throw t.typeError(`unable to infer type of ${this.toString()} (${n instanceof TupleType} ${n instanceof GenericType})`)}}export function isDataType(t){const e=t.asDataType;if(!e)return!1;if(e==IntType||e==StringType||e==ByteArrayType||e==BoolType||e==RealType)return!0;return(new DefaultTypeClass).isImplementedBy(e)}export function TupleType$(t,e=null){const n=null!==e?e:t.every((t=>isDataType(t))),r={name:`(${t.map((t=>t.toString())).join(", ")})`,path:`__helios__tuple[${t.map((t=>t.asDataType?t.asDataType.path:"__helios__func")).join("@")}]`,genInstanceMembers:e=>{const r=n?genCommonInstanceMembers(e):{},s=["first","second","third","fourth","fifth"];for(let e=0;e<5&&e<t.length;e++){r[s[e]]=t[e]}const a=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return r.__to_func=new ParametricFunc([a],new FuncType([new FuncType(t,a.ref)],a.ref)),r},genTypeMembers:t=>n?genCommonTypeMembers(t):{}};return new TupleType(r,t)}export function getTupleItemTypes(t){return t instanceof TupleType?t.itemTypes:null}export const ListType=new ParametricType({name:"[]",offChainType:HList,parameters:[new Parameter("ItemType",`${TTPP}0`,new DefaultTypeClass)],apply:([t])=>{const e=assertDefined(t.asDataType),n=e.offChainType??null,r={offChainType:n?HList(n):null,name:`[]${e.toString()}`,path:`__helios__list[${e.path}]`,genTypeDetails:t=>({inputType:`(${assertDefined(e.typeDetails?.inputType)})[]`,outputType:`(${assertDefined(e.typeDetails?.outputType)})[]`,internalType:{type:"List",itemType:assertDefined(e.typeDetails?.internalType)}}),jsToUplc:async(t,n)=>{if(Array.isArray(t))return new ListData(await Promise.all(t.map((t=>e.jsToUplc(t,n)))));throw new Error("expected array")},uplcToJs:async(t,n)=>await Promise.all(t.list.map((t=>e.uplcToJs(t,n)))),genInstanceMembers:t=>{const n={};return(new SummableTypeClass).isImplementedBy(e)?n.sum=new FuncType([],e):StringType.isBaseOf(e)?n.join=new FuncType([new ArgType(new Word(Site.dummy(),"separator"),StringType,!0)],StringType):ByteArrayType.isBaseOf(e)?n.join=new FuncType([new ArgType(new Word(Site.dummy(),"separator"),ByteArrayType,!0)],ByteArrayType):e.asNamed?.name.startsWith("[]")&&(n.flatten=new FuncType([],e)),{...genCommonInstanceMembers(t),...n,all:new FuncType([new FuncType([e],BoolType)],BoolType),any:new FuncType([new FuncType([e],BoolType)],BoolType),append:new FuncType([e],t),drop:new FuncType([IntType],t),drop_end:new FuncType([IntType],t),filter:new FuncType([new FuncType([e],BoolType)],t),find:new FuncType([new FuncType([e],BoolType)],e),find_index:new FuncType([new FuncType([e],BoolType)],IntType),find_safe:new FuncType([new FuncType([e],BoolType)],OptionType$(e)),fold:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([t.ref,e],t.ref),t.ref],t.ref))})(),fold2:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass),n=new Parameter("b",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t,n],new FuncType([new FuncType([t.ref,n.ref,e],TupleType$([t.ref,n.ref])),t.ref,n.ref],TupleType$([t.ref,n.ref])))})(),fold3:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass),n=new Parameter("b",`${FTPP}0`,new AnyTypeClass),r=new Parameter("c",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t,n,r],new FuncType([new FuncType([t.ref,n.ref,r.ref,e],TupleType$([t.ref,n.ref,r.ref])),t.ref,n.ref,r.ref],TupleType$([t.ref,n.ref,r.ref])))})(),fold_lazy:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([e,new FuncType([],t.ref)],t.ref),t.ref],t.ref))})(),fold2_lazy:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass),n=new Parameter("b",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t,n],new FuncType([new FuncType([e,new FuncType([],TupleType$([t.ref,n.ref]))],TupleType$([t.ref,n.ref])),t.ref,n.ref],TupleType$([t.ref,n.ref])))})(),for_each:new FuncType([new FuncType([e],new VoidType)],new VoidType),get:new FuncType([IntType],e),get_singleton:new FuncType([],e),head:e,is_empty:new FuncType([],BoolType),length:IntType,map:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([e],t.ref)],ListType$(t.ref)))})(),map_option:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([e],OptionType$(t.ref))],ListType$(t.ref)))})(),prepend:new FuncType([e],t),set:new FuncType([IntType,e],t),sort:new FuncType([new FuncType([e,e],BoolType)],t),split_at:new FuncType([IntType],TupleType$([t,t],!0)),tail:t,take:new FuncType([IntType],t),take_end:new FuncType([IntType],t),to_iterator:new FuncType([],IteratorType$([e])),zip:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([ListType$(t.ref)],IteratorType$([e,t.ref])))})()}},genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,t],t),new:new FuncType([IntType,new FuncType([IntType],e)],t),new_const:new FuncType([IntType,e],t),from_iterator:new FuncType([IteratorType$([e])],t)})};return t.isParametric()?new GenericParametricType(r):new GenericType(r)}});export function ListType$(t){return applyTypes(ListType,t)}export const MapType=new ParametricType({name:"Map",offChainType:HMap,parameters:[new Parameter("KeyType",`${TTPP}0`,new DefaultTypeClass),new Parameter("ValueType",`${TTPP}1`,new DefaultTypeClass)],apply:([t,e])=>{const n=assertDefined(t.asDataType),r=assertDefined(e.asDataType),s=n.offChainType??null,a=r.offChainType??null,i={offChainType:s&&a?HMap(s,a):null,name:`Map[${n.toString()}]${r.toString()}`,path:`__helios__map[${n.path}@${r.path}]`,genTypeDetails:t=>({inputType:`[${assertDefined(n.typeDetails?.inputType)}, ${assertDefined(r.typeDetails?.inputType)}][]`,outputType:`[${assertDefined(n.typeDetails?.outputType)}, ${assertDefined(r.typeDetails?.outputType)}][]`,internalType:{type:"Map",keyType:assertDefined(n.typeDetails?.internalType),valueType:assertDefined(r.typeDetails?.internalType)}}),genInstanceMembers:t=>({...genCommonInstanceMembers(t),all:new FuncType([new FuncType([n,r],BoolType)],BoolType),any:new FuncType([new FuncType([n,r],BoolType)],BoolType),append:new FuncType([n,r],t),delete:new FuncType([n],t),filter:new FuncType([new FuncType([n,r],BoolType)],t),find:new FuncType([new FuncType([n,r],BoolType)],TupleType$([n,r],!0)),find_key:new FuncType([new FuncType([n],BoolType)],n),find_key_safe:new FuncType([new FuncType([n],BoolType)],OptionType$(n)),find_safe:new FuncType([new FuncType([n,r],BoolType)],TupleType$([new FuncType([],TupleType$([n,r])),BoolType],!1)),find_value:new FuncType([new FuncType([r],BoolType)],r),find_value_safe:new FuncType([new FuncType([r],BoolType)],OptionType$(r)),fold:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([t.ref,n,r],t.ref),t.ref],t.ref))})(),fold_lazy:(()=>{const t=new Parameter("a",`${FTPP}0`,new AnyTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([n,r,new FuncType([],t.ref)],t.ref),t.ref],t.ref))})(),for_each:new FuncType([new FuncType([n,r],new VoidType)],new VoidType),get:new FuncType([n],r),get_safe:new FuncType([n],OptionType$(r)),head:TupleType$([n,r],!0),head_key:n,head_value:r,is_empty:new FuncType([],BoolType),length:IntType,map:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass),e=new Parameter("b",`${FTPP}1`,new DefaultTypeClass);return new ParametricFunc([t,e],new FuncType([new FuncType([n,r],TupleType$([t.ref,e.ref],!0))],MapType$(t.ref,e.ref)))})(),prepend:new FuncType([n,r],t),set:new FuncType([n,r],t),sort:new FuncType([new FuncType([n,r,n,r],BoolType)],t),tail:t,to_iterator:new FuncType([],IteratorType$([n,r])),update:new FuncType([n,new FuncType([r],r)],t),update_safe:new FuncType([n,new FuncType([r],r)],t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,t],t),from_iterator:new FuncType([IteratorType$([n,r])],t)})};return n.isParametric()||r.isParametric()?new GenericParametricType(i):new GenericType(i)}});export function MapType$(t,e){return applyTypes(MapType,t,e)}const OptionType=new ParametricType({name:"Option",offChainType:Option,parameters:[new Parameter("SomeType",`${TTPP}0`,new DefaultTypeClass)],apply:([t])=>{const e=assertDefined(t.asDataType),n=e.offChainType??null,r=n?Option(n):null,s=e.path;let a=null,i=null;const o={offChainType:r,name:`Option[${e.toString()}]`,path:`__helios__option[${s}]`,genTypeDetails:t=>({inputType:`null | ${assertDefined(e.typeDetails?.inputType)}`,outputType:`null | ${assertDefined(e.typeDetails?.outputType)}`,internalType:{type:"Option",someType:assertDefined(e.typeDetails?.internalType)}}),genInstanceMembers:t=>({...genCommonInstanceMembers(t),map:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([new FuncType([e],t.ref)],OptionType$(t.ref)))})(),unwrap:new FuncType([],e)}),genTypeMembers:t=>({...genCommonTypeMembers(t),None:assertDefined(a),Some:assertDefined(i)})},_={name:"Some",constrIndex:0,fieldNames:["some"],path:`__helios__option[${s}]__some`,genInstanceMembers:t=>({...genCommonInstanceMembers(t),some:e}),genTypeMembers:t=>({...genCommonTypeMembers(t)})},l={name:"None",constrIndex:1,path:`__helios__option[${s}]__none`,genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t)})};if(e.isParametric()){const t=new GenericParametricType(o);return i=new GenericParametricEnumMemberType({..._,parentType:t}),a=new GenericParametricEnumMemberType({...l,parentType:t}),t}{const t=new GenericType(o);return i=new GenericEnumMemberType({..._,parentType:t}),a=new GenericEnumMemberType({...l,parentType:t}),t}}});export function OptionType$(t){return applyTypes(OptionType,t)}export var DurationType=new GenericType({name:"Duration",offChainType:Duration,genTypeDetails:t=>({inputType:"number | bigint",outputType:"number",internalType:{type:"Duration"}}),jsToUplc:async(t,e)=>Duration.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>Number(Duration.fromUplcData(t).value),genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>{const e=new DataEntity(assertDefined(t.asDataType));return{...genCommonTypeMembers(t),__add:new FuncType([t,t],t),__div:new FuncType([t,IntType],t),__div1:new FuncType([t,DurationType],IntType),__geq:new FuncType([t,DurationType],BoolType),__gt:new FuncType([t,DurationType],BoolType),__leq:new FuncType([t,DurationType],BoolType),__lt:new FuncType([t,DurationType],BoolType),__mod:new FuncType([t,t],t),__mul:new FuncType([t,IntType],t),__sub:new FuncType([t,t],t),new:new FuncType([IntType],t),SECOND:e,MINUTE:e,HOUR:e,DAY:e,WEEK:e}}});export var TimeType=new GenericType({name:"Time",offChainType:Time,genTypeDetails:t=>({inputType:"number | bigint | string | Date",outputType:"Date",internalType:{type:"Time"}}),jsToUplc:async(t,e)=>Time.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>new Date(Number(Time.fromUplcData(t).value)),genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),__add:new FuncType([t,DurationType],TimeType),__geq:new FuncType([t,TimeType],BoolType),__gt:new FuncType([t,TimeType],BoolType),__leq:new FuncType([t,TimeType],BoolType),__lt:new FuncType([t,TimeType],BoolType),__sub:new FuncType([t,TimeType],DurationType),__sub1:new FuncType([t,DurationType],TimeType),new:new FuncType([IntType],t)})});export var TimeRangeType=new GenericType({name:"TimeRange",genInstanceMembers:t=>({...genCommonInstanceMembers(t),contains:new FuncType([TimeType],BoolType),start:TimeType,end:TimeType,is_before:new FuncType([TimeType],BoolType),is_after:new FuncType([TimeType],BoolType)}),genTypeMembers:t=>{const e=new DataEntity(assertDefined(t.asDataType));return{...genCommonTypeMembers(t),new:new FuncType([TimeType,TimeType],t),ALWAYS:e,NEVER:e,from:new FuncType([TimeType],t),to:new FuncType([TimeType],t)}}});function genHashInstanceMembers(t){return{...genCommonInstanceMembers(t),bytes:ByteArrayType}}function genHashTypeMembers(t){return{...genCommonTypeMembers(t),__geq:new FuncType([t,t],BoolType),__gt:new FuncType([t,t],BoolType),__leq:new FuncType([t,t],BoolType),__lt:new FuncType([t,t],BoolType),new:new FuncType([ByteArrayType],t)}}function genHashTypeProps(t){return{genTypeDetails:e=>({inputType:`number[] | string | helios.${t.name}`,outputType:`helios.${t.name}`,internalType:{type:t.name}}),jsToUplc:async(e,n)=>{if(e instanceof t)return e._toUplcData();{const t=Array.isArray(e)?e:hexToBytes(e);return new ByteArrayData(t)}},uplcToJs:async(e,n)=>new t(e.bytes)}}export class ScriptHashType extends GenericType{constructor(t=null,e=null){e&&t?super({...genHashTypeProps(e),name:t,offChainType:e,genInstanceMembers:genHashInstanceMembers,genTypeMembers:t=>({...genHashTypeMembers(t),from_script_hash:new FuncType([scriptHashType],t)})}):(assert(null===t),super({name:"ScriptHash",genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t)})}))}}export const scriptHashType=new ScriptHashType;export const DatumHashType=new GenericType({...genHashTypeProps(DatumHash),name:"DatumHash",offChainType:DatumHash,genInstanceMembers:genHashInstanceMembers,genTypeMembers:genHashTypeMembers});export const MintingPolicyHashType=new ScriptHashType("MintingPolicyHash",MintingPolicyHash);export const PubKeyType=new GenericType({name:"PubKey",offChainType:PubKey,genInstanceMembers:t=>({...genCommonInstanceMembers(t),verify:new FuncType([ByteArrayType,ByteArrayType],BoolType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),new:new FuncType([ByteArrayType],t)})});export const PubKeyHashType=new GenericType({...genHashTypeProps(PubKeyHash),name:"PubKeyHash",offChainType:PubKeyHash,genInstanceMembers:genHashInstanceMembers,genTypeMembers:genHashTypeMembers});export const StakingHashType=new GenericType({name:"StakingHash",genInstanceMembers:genCommonInstanceMembers,genTypeMembers:t=>({StakeKey:StakingHashStakeKeyType,Validator:StakingHashValidatorType,new_stakekey:new FuncType([PubKeyHashType],StakingHashStakeKeyType),new_validator:new FuncType([StakingValidatorHashType],StakingHashValidatorType)})});export const StakingHashStakeKeyType=new GenericEnumMemberType({name:"StakeKey",constrIndex:0,parentType:StakingHashType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),hash:PubKeyHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,StakingHashType)})});export const StakingHashValidatorType=new GenericEnumMemberType({name:"Validator",constrIndex:1,parentType:StakingHashType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),hash:StakingValidatorHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,StakingHashType)})});export const StakingValidatorHashType=new ScriptHashType("StakingValidatorHash",StakingValidatorHash);export const ValidatorHashType=new ScriptHashType("ValidatorHash",ValidatorHash);export const AssetClassType=new GenericType({name:"AssetClass",offChainType:AssetClass,genTypeDetails:t=>({inputType:"string | {mph: number[] | string | helios.MintingPolicyHash, tokenName: number[] | string} | helios.AssetClass",outputType:"helios.AssetClass",internalType:{type:"AssetClass"}}),jsToUplc:async(t,e)=>AssetClass.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>AssetClass.fromUplcData(t),genInstanceMembers:t=>({...genCommonInstanceMembers(t),mph:MintingPolicyHashType,token_name:ByteArrayType}),genTypeMembers:t=>{const e=new DataEntity(assertDefined(t.asDataType));return{...genCommonTypeMembers(t),ADA:e,new:new FuncType([MintingPolicyHashType,ByteArrayType],t),__geq:new FuncType([t,t],BoolType),__gt:new FuncType([t,t],BoolType),__leq:new FuncType([t,t],BoolType),__lt:new FuncType([t,t],BoolType)}}});export const ValueType=new GenericType({name:"Value",offChainType:Value,genTypeDetails:t=>({inputType:"number | bigint | {lovelace?: number | bigint, assets: [string, number | bigint][] | [number[] | string | helios.MintingPolicyHash, [number[] | string, number | bigint][]][] | helios.Assets} | helios.Value",outputType:"helios.Value",internalType:{type:"Value"}}),jsToUplc:async(t,e)=>Value.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>Value.fromUplcData(t),genInstanceMembers:t=>({...genCommonInstanceMembers(t),contains:new FuncType([t],BoolType),contains_policy:new FuncType([MintingPolicyHashType],BoolType),get:new FuncType([AssetClassType],IntType),get_assets:new FuncType([],ValueType),get_lovelace:new FuncType([],IntType),get_policy:new FuncType([MintingPolicyHashType],MapType$(ByteArrayType,IntType)),get_safe:new FuncType([AssetClassType],IntType),is_zero:new FuncType([],BoolType),to_map:new FuncType([],MapType$(MintingPolicyHashType,MapType$(ByteArrayType,IntType))),value:t}),genTypeMembers:t=>{const e=new DataEntity(assertDefined(t.asDataType));return{...genCommonTypeMembers(t),__add:new FuncType([t,t],t),__div:new FuncType([t,IntType],ValueType),__geq:new FuncType([t,ValueType],BoolType),__gt:new FuncType([t,ValueType],BoolType),__leq:new FuncType([t,ValueType],BoolType),__lt:new FuncType([t,ValueType],BoolType),__mul:new FuncType([t,IntType],ValueType),__sub:new FuncType([t,t],t),from_map:new FuncType([MapType$(MintingPolicyHashType,MapType$(ByteArrayType,IntType))],t),lovelace:new FuncType([IntType],t),new:new FuncType([AssetClassType,IntType],t),sum:(()=>{const e=new Parameter("a",`${FTPP}0`,new ValuableTypeClass);return new ParametricFunc([e],new FuncType([ListType$(e.ref)],t))})(),ZERO:e}}});export class ValuableTypeClass extends DefaultTypeClass{genTypeMembers(t){return{...super.genTypeMembers(t)}}genInstanceMembers(t){return{...super.genInstanceMembers(t),value:ValueType}}toString(){return"Valuable"}}export const AddressType=new GenericType({name:"Address",offChainType:Address,genTypeDetails:t=>({inputType:"string | helios.Address",outputType:"helios.Address",internalType:{type:"Address"}}),jsToUplc:async(t,e)=>Address.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>Address.fromUplcData(t),genInstanceMembers:t=>({...genCommonInstanceMembers(t),credential:CredentialType,staking_credential:OptionType$(StakingCredentialType),to_bytes:new FuncType([],ByteArrayType),to_hex:new FuncType([],StringType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),new:new FuncType([CredentialType,OptionType$(StakingCredentialType)],t),new_empty:new FuncType([],t),from_bytes:new FuncType([ByteArrayType],t),from_hex:new FuncType([StringType],t)})});export const DCertType=new GenericType({name:"DCert",genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),Delegate:DCertDelegateType,Deregister:DCertDeregisterType,Register:DCertRegisterType,RegisterPool:DCertRegisterPoolType,RetirePool:DCertRetirePoolType,new_delegate:new FuncType([StakingCredentialType,PubKeyHashType],DCertDelegateType),new_deregister:new FuncType([StakingCredentialType],DCertDeregisterType),new_register:new FuncType([StakingCredentialType],DCertRegisterType),new_register_pool:new FuncType([PubKeyHashType,PubKeyHashType],DCertRegisterPoolType),new_retire_pool:new FuncType([PubKeyHashType,IntType],DCertRetirePoolType)})});const DCertDelegateType=new GenericEnumMemberType({name:"Delegate",constrIndex:2,parentType:DCertType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),delegator:StakingCredentialType,pool_id:PubKeyHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,DCertType)})}),DCertDeregisterType=new GenericEnumMemberType({name:"Deregister",constrIndex:1,parentType:DCertType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),credential:StakingCredentialType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,DCertType)})}),DCertRegisterType=new GenericEnumMemberType({name:"Register",constrIndex:0,parentType:DCertType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),credential:StakingCredentialType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,DCertType)})}),DCertRegisterPoolType=new GenericEnumMemberType({name:"RegisterPool",constrIndex:3,parentType:DCertType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),pool_id:PubKeyHashType,pool_vrf:PubKeyHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,DCertType)})}),DCertRetirePoolType=new GenericEnumMemberType({name:"RetirePool",constrIndex:4,parentType:DCertType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),pool_id:PubKeyHashType,epoch:IntType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,DCertType)})});export const CredentialType=new GenericType({name:"Credential",genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),PubKey:CredentialPubKeyType,Validator:CredentialValidatorType,new_pubkey:new FuncType([PubKeyHashType],CredentialPubKeyType),new_validator:new FuncType([ValidatorHashType],CredentialValidatorType)})});const CredentialPubKeyType=new GenericEnumMemberType({name:"PubKey",constrIndex:0,fieldNames:["hash"],parentType:CredentialType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),hash:PubKeyHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,CredentialType)})}),CredentialValidatorType=new GenericEnumMemberType({name:"Validator",constrIndex:1,fieldNames:["hash"],parentType:CredentialType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),hash:ValidatorHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,CredentialType)})});export const OutputDatumType=new GenericType({name:"OutputDatum",path:"__helios__outputdatum",genInstanceMembers:t=>({...genCommonInstanceMembers(t),get_inline_data:new FuncType([],RawDataType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),Hash:OutputDatumHashType,Inline:OutputDatumInlineType,None:OutputDatumNoneType,new_hash:new FuncType([DatumHashType],OutputDatumHashType),new_inline:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([t.ref],OutputDatumInlineType))})(),new_none:new FuncType([],OutputDatumNoneType)})});const OutputDatumHashType=new GenericEnumMemberType({name:"Hash",constrIndex:1,parentType:OutputDatumType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),hash:DatumHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,OutputDatumType)})}),OutputDatumInlineType=new GenericEnumMemberType({name:"Inline",constrIndex:2,parentType:OutputDatumType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),data:RawDataType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,OutputDatumType)})}),OutputDatumNoneType=new GenericEnumMemberType({name:"None",constrIndex:0,parentType:OutputDatumType,genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,OutputDatumType)})});export class MacroType extends Common{get fieldNames(){return[]}get instanceMembers(){throw new Error("not yet implemented")}get name(){throw new Error("not yet implemented")}get offChainType(){return null}get path(){throw new Error("not yet implemented")}get typeMembers(){return{}}get asDataType(){return this}get asNamed(){return this}get asType(){return this}infer(t,e,n){return this}isBaseOf(t){throw new Error("not yet implemented")}toString(){return this.name}toTyped(){return new DataEntity(this)}}export class ScriptsType extends MacroType{#te;constructor(t){super(),this.#te={};for(let e in t)this.#te[e]=t[e].toTyped()}get instanceMembers(){return{}}get typeMembers(){return{...this.#te}}get name(){return"Scripts"}get path(){return"__helios__scripts"}isBaseOf(t){return t instanceof ScriptsType}isEmpty(){return 0==Object.keys(this.#te).length}}export class ScriptContextType extends MacroType{constructor(){super()}get name(){return"ScriptContext"}get instanceMembers(){return{...genCommonInstanceMembers(this),get_current_minting_policy_hash:new FuncType([],MintingPolicyHashType),get_current_input:new FuncType([],TxInputType),get_cont_outputs:new FuncType([],ListType$(TxOutputType)),get_current_validator_hash:new FuncType([],ValidatorHashType),get_spending_purpose_output_id:new FuncType([],TxOutputIdType),get_staking_purpose:new FuncType([],StakingPurposeType),get_script_purpose:new FuncType([],ScriptPurposeType),tx:TxType}}get path(){return"__helios__scriptcontext"}get typeMembers(){return{...genCommonTypeMembers(this),new_certifying:new FuncType([TxType,DCertType],new ScriptContextType),new_minting:new FuncType([TxType,MintingPolicyHashType],new ScriptContextType),new_rewarding:new FuncType([TxType,StakingCredentialType],new ScriptContextType),new_spending:new FuncType([TxType,TxOutputIdType],new ScriptContextType)}}isBaseOf(t){return t instanceof ScriptContextType}}export class ContractContextType extends MacroType{constructor(){super()}get instanceMembers(){return{now:new FuncType([],TimeType),agent:WalletType,network:NetworkType,new_tx_builder:new FuncType([],TxBuilderType)}}get name(){return"ContractContext"}get path(){return"__helios__contractcontext"}isBaseOf(t){return t instanceof ContractContextType}}export const WalletType=new GenericType({name:"Wallet",genInstanceMembers:t=>({address:AddressType,hash:PubKeyHashType,pick:new FuncType([ValueType],ListType$(TxInputType))}),genTypeMembers:t=>({})});export const NetworkType=new GenericType({name:"Network",genInstanceMembers:t=>({pick:new FuncType([AddressType,ValueType],ListType$(TxInputType)),get:new FuncType([TxOutputIdType],TxInputType),utxos_at:new FuncType([AddressType],IteratorType$([TxInputType]))}),genTypeMembers:t=>({})});export const ScriptPurposeType=new GenericType({name:"ScriptPurpose",genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),Certifying:ScriptPurposeCertifyingType,Minting:ScriptPurposeMintingType,Rewarding:ScriptPurposeTypeRewarding,Spending:ScriptPurposeSpendingType,new_certifying:new FuncType([DCertType],ScriptPurposeCertifyingType),new_minting:new FuncType([MintingPolicyHashType],ScriptPurposeMintingType),new_rewarding:new FuncType([StakingCredentialType],ScriptPurposeTypeRewarding),new_spending:new FuncType([TxOutputIdType],ScriptPurposeSpendingType)})});const ScriptPurposeCertifyingType=new GenericEnumMemberType({name:"Certifying",constrIndex:3,parentType:ScriptPurposeType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),dcert:DCertType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,ScriptPurposeType)})}),ScriptPurposeMintingType=new GenericEnumMemberType({name:"Minting",constrIndex:0,parentType:ScriptPurposeType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),policy_hash:MintingPolicyHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,ScriptPurposeType)})}),ScriptPurposeTypeRewarding=new GenericEnumMemberType({name:"Rewarding",constrIndex:2,parentType:ScriptPurposeType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),credential:StakingCredentialType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,ScriptPurposeType)})}),ScriptPurposeSpendingType=new GenericEnumMemberType({name:"Spending",constrIndex:1,parentType:ScriptPurposeType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),output_id:TxOutputIdType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,ScriptPurposeType)})});export const StakingCredentialType=new GenericType({name:"StakingCredential",genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),Hash:StakingCredentialHashType,Ptr:StakingCredentialPtrType,new_hash:new FuncType([StakingHashType],StakingCredentialHashType),new_ptr:new FuncType([IntType,IntType,IntType],StakingCredentialPtrType)})});const StakingCredentialHashType=new GenericEnumMemberType({name:"Hash",constrIndex:0,parentType:StakingCredentialType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),hash:StakingHashType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,StakingCredentialType)})}),StakingCredentialPtrType=new GenericEnumMemberType({name:"Ptr",constrIndex:1,parentType:StakingCredentialType,genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,StakingCredentialType)})});export const StakingPurposeType=new GenericType({name:"StakingPurpose",genInstanceMembers:t=>({...genCommonInstanceMembers(t)}),genTypeMembers:t=>({...genCommonTypeMembers(t),Certifying:StakingPurposeCertifyingType,Rewarding:StakingPurposeRewardingType})});const StakingPurposeCertifyingType=new GenericEnumMemberType({name:"Certifying",constrIndex:3,parentType:StakingPurposeType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),dcert:DCertType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,StakingPurposeType)})}),StakingPurposeRewardingType=new GenericEnumMemberType({name:"Rewarding",constrIndex:2,parentType:StakingPurposeType,genInstanceMembers:t=>({...genCommonInstanceMembers(t),credential:StakingCredentialType}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,StakingPurposeType)})});export const TxBuilderType=new GenericType({name:"TxBuilder",path:"__helios__txbuilder",genInstanceMembers:t=>({...genCommonInstanceMembers(t),add_output:new FuncType([TxOutputType],t),add_outputs:new FuncType([ListType$(TxOutputType)],t),add_ref_input:new FuncType([TxInputType],t),add_signer:new FuncType([PubKeyHashType],t),finalize:new FuncType([],TxType),pay:(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([e],new FuncType([AddressType,ValueType,e.ref],t))})(),pay_if_true:(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([e],new FuncType([BoolType,AddressType,ValueType,e.ref],t))})(),mint:(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([e],new FuncType([ValueType,e.ref],t))})(),redeem:(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([e],new FuncType([TxInputType,e.ref],t))})(),redeem_many:(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([e],new FuncType([ListType$(TxInputType),e.ref],t))})(),spend:new FuncType([TxInputType],t),spend_many:new FuncType([ListType$(TxInputType)],t)}),genTypeMembers:t=>({...genCommonTypeMembers(t)})});export const TxType=new GenericType({name:"Tx",jsToUplc:async(t,e)=>e.Tx(t),uplcToJs:async(t,e)=>e.Tx(t),genTypeDetails:t=>({inputType:"helios.Tx",outputType:"helios.Tx",internalType:{type:"Tx"}}),genInstanceMembers:t=>({...genCommonInstanceMembers(t),inputs:ListType$(TxInputType),ref_inputs:ListType$(TxInputType),outputs:ListType$(TxOutputType),fee:ValueType,minted:ValueType,dcerts:ListType$(DCertType),withdrawals:MapType$(StakingCredentialType,IntType),time_range:TimeRangeType,signatories:ListType$(PubKeyHashType),redeemers:MapType$(ScriptPurposeType,RawDataType),datums:MapType$(DatumHashType,RawDataType),id:TxIdType,find_datum_hash:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([t.ref],DatumHashType))})(),get_datum_data:new FuncType([TxOutputType],RawDataType),outputs_sent_to:new FuncType([PubKeyHashType],ListType$(TxOutputType)),outputs_sent_to_datum:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([PubKeyHashType,t.ref,BoolType],ListType$(TxOutputType)))})(),outputs_locked_by:new FuncType([ValidatorHashType],ListType$(TxOutputType)),outputs_locked_by_datum:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([ValidatorHashType,t.ref,BoolType],ListType$(TxOutputType)))})(),value_sent_to:new FuncType([PubKeyHashType],ValueType),value_sent_to_datum:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([PubKeyHashType,t.ref,BoolType],ValueType))})(),value_locked_by:new FuncType([ValidatorHashType],ValueType),value_locked_by_datum:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([ValidatorHashType,t.ref,BoolType],ValueType))})(),value_paid_to:(()=>{const t=new Parameter("a",`${FTPP}0`,new DefaultTypeClass);return new ParametricFunc([t],new FuncType([AddressType,t.ref],ValueType))})(),is_signed_by:new FuncType([PubKeyHashType],BoolType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),new:(()=>{const e=new Parameter("a",`${FTPP}0`,new DefaultTypeClass),n=new Parameter("b",`${FTPP}1`,new DefaultTypeClass);return new ParametricFunc([e,n],new FuncType([ListType$(TxInputType),ListType$(TxInputType),ListType$(TxOutputType),ValueType,ValueType,ListType$(DCertType),MapType$(StakingCredentialType,IntType),TimeRangeType,ListType$(PubKeyHashType),MapType$(ScriptPurposeType,e.ref),MapType$(DatumHashType,n.ref),TxIdType],t))})()})});export const TxIdType=new GenericType({name:"TxId",offChainType:TxId,genTypeDetails:t=>({inputType:"number[] | string | helios.TxId",outputType:"helios.TxId",internalType:{type:"TxId"}}),jsToUplc:async(t,e)=>TxId.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>TxId.fromUplcData(t),genInstanceMembers:t=>({...genCommonInstanceMembers(t),bytes:ByteArrayType}),genTypeMembers:t=>({...genCommonTypeMembers(t),__geq:new FuncType([t,t],BoolType),__gt:new FuncType([t,t],BoolType),__leq:new FuncType([t,t],BoolType),__lt:new FuncType([t,t],BoolType),new:new FuncType([ByteArrayType],t)})});export const TxInputType=new GenericType({name:"TxInput",genInstanceMembers:t=>({...genCommonInstanceMembers(t),output_id:TxOutputIdType,output:TxOutputType,address:AddressType,value:ValueType,datum:OutputDatumType}),genTypeMembers:t=>({...genCommonTypeMembers(t),new:new FuncType([TxOutputIdType,TxOutputType],t)})});export const TxOutputType=new GenericType({name:"TxOutput",genInstanceMembers:t=>({...genCommonInstanceMembers(t),address:AddressType,value:ValueType,datum:OutputDatumType,ref_script_hash:OptionType$(scriptHashType)}),genTypeMembers:t=>({...genCommonTypeMembers(t),new:new FuncType([AddressType,ValueType,OutputDatumType],t)})});export const TxOutputIdType=new GenericType({name:"TxOutputId",genTypeDetails:t=>({inputType:"{txId: number[] | string | helios.TxId, utxoId: number | bigint} | helios.TxOutputId",outputType:"helios.TxOutputId",internalType:{type:"TxOutputId"}}),jsToUplc:async(t,e)=>TxOutputId.fromProps(t)._toUplcData(),uplcToJs:async(t,e)=>TxOutputId.fromUplcData(t),genInstanceMembers:t=>({...genCommonInstanceMembers(t),tx_id:TxIdType,index:IntType}),genTypeMembers:t=>({...genCommonTypeMembers(t),__geq:new FuncType([t,TxOutputIdType],BoolType),__gt:new FuncType([t,TxOutputIdType],BoolType),__leq:new FuncType([t,TxOutputIdType],BoolType),__lt:new FuncType([t,TxOutputIdType],BoolType),new:new FuncType([TxIdType,IntType],TxOutputIdType)})});export const builtinTypes={Address:AddressType,AssetClass:AssetClassType,Bool:BoolType,ByteArray:ByteArrayType,DCert:DCertType,Credential:CredentialType,DatumHash:DatumHashType,Data:RawDataType,Duration:DurationType,Int:IntType,MintingPolicyHash:MintingPolicyHashType,OutputDatum:OutputDatumType,PubKey:PubKeyType,PubKeyHash:PubKeyHashType,Real:RealType,ScriptHash:scriptHashType,ScriptPurpose:ScriptPurposeType,StakingCredential:StakingCredentialType,StakingHash:StakingHashType,StakingPurpose:StakingPurposeType,StakingValidatorHash:StakingValidatorHashType,String:StringType,Time:TimeType,TimeRange:TimeRangeType,Tx:TxType,TxId:TxIdType,TxInput:TxInputType,TxOutput:TxOutputType,TxOutputId:TxOutputIdType,ValidatorHash:ValidatorHashType,Value:ValueType};export class GlobalScope{#ee;constructor(){this.#ee=[]}has(t){for(let e of this.#ee)if(e[0].toString()==t.toString())return!0;return!1}set(t,e){let n=t instanceof Word?t:Word.new(t);this.#ee.push([n,e])}get(t){for(let e of this.#ee)if(e[0].toString()==t.toString())return e[1];return t.referenceError(`'${t.toString()}' undefined`),null}isStrict(){throw new Error("should've been returned be TopScope")}static new(t={}){let e=new GlobalScope;for(let t in builtinTypes)e.set(t,builtinTypes[t]);return e.set("Any",new AnyTypeClass),e.set("Valuable",new ValuableTypeClass),Object.keys(t).length>0&&e.set("Scripts",new ScriptsType(t)),e.set("ScriptContext",new ScriptContextType),e.set("ContractContext",new ContractContextType),e.set("TxBuilder",TxBuilderType),e.set("Wallet",WalletType),e.set("Network",NetworkType),e.set("assert",AssertFunc),e.set("error",ErrorFunc),e.set("print",PrintFunc),e}loopTypes(t){for(let[e,n]of this.#ee)n.asType&&t(e.value,n.asType)}}export class Scope extends Common{#ut;#ee;#ne;constructor(t,e=!1){super(),this.#ut=t,this.#ee=[],this.#ne=e}get allowShadowing(){return this.#ne}get values(){return this.#ee.slice()}has(t){for(let e of this.#ee)if(e[0].toString()==t.toString())return!0;return null!==this.#ut&&this.#ut.has(t)}setInternal(t,e,n=!1){if(e instanceof Scope&&assert(t.value.startsWith("__scope__")),this.has(t)){const r=this.get(t,!0);n&&e.asTyped&&r&&!(r instanceof Scope)&&r.asTyped&&r.asTyped.type.isBaseOf(e.asTyped.type)&&e.asTyped.type.isBaseOf(r.asTyped.type)||t.syntaxError(`'${t.toString()}' already defined`)}this.#ee.push([t,e,!1])}set(t,e){this.setInternal(t,e,this.#ne)}remove(t){this.#ee=this.#ee.filter((([e,n])=>e.value!=t.value))}getScope(t){assert(!t.value.startsWith("__scope__"));const e=this.get(new Word(t.site,`__scope__${t.value}`));return e instanceof Scope?e:e?(t.typeError(`expected Scope, got ${e.toString()}`),null):(t.typeError("expected Scope"),null)}get(t,e=!1){t instanceof Word||(t=Word.new(t));for(let n=this.#ee.length-1;n>=0;n--){const[r,s,a]=this.#ee[n];if(r.toString()==t.toString())return e||(this.#ee[n][2]=!0),s}return null!==this.#ut?this.#ut.get(t,e):(t.referenceError(`'${t.toString()}' undefined`),null)}isStrict(){return this.#ut.isStrict()}assertAllUsed(t=!0){if(!t||this.isStrict())for(let[t,e,n]of this.#ee)e instanceof Scope||n||t.referenceError(`'${t.toString()}' unused`)}isUsed(t){for(let[e,n,r]of this.#ee)if(t.value==e.value&&!(n instanceof Scope))return r;throw new Error(`${t.value} not found`)}dump(){console.log("DUMPING SCOPE",this.#ee.length),this.#ee.forEach((([t,e])=>{console.log(t.value,e)}))}loopTypes(t){this.#ut.loopTypes(t);for(let[e,n]of this.#ee)n.asType&&t(e.value,n.asType)}}export class TopScope extends Scope{#re;constructor(t,e=!0){super(t),this.#re=e}setScope(t,e){assert(!t.value.startsWith("__scope__")),this.set(new Word(t.site,`__scope__${t.value}`),e)}set(t,e){super.setInternal(t,e,!1)}setStrict(t){this.#re=t}isStrict(){return this.#re}getModuleScope(t){assert(!t.value.startsWith("__scope__"));const e=this.get(new Word(t.site,`__scope__${t.value}`));if(e instanceof ModuleScope)return e;throw new Error("expected ModuleScope")}}export class ModuleScope extends Scope{}var onNotifyRawUsage=null;export function setRawUsageNotifier(t){onNotifyRawUsage=t}const RE_BUILTIN=new RegExp("(?<![@[])__helios[a-zA-Z0-9_@[\\]]*","g");class RawFunc{#i;#se;constructor(t,e){this.#i=t,assert(null!=e),this.#se="string"==typeof e?(t,n)=>{if(IRParametricName.matches(this.#i)){let r=IRParametricName.parse(this.#i);r=new IRParametricName(r.base,t,r.fn,n);const[s,a]=r.replaceTemplateNames(new IR(e)).generateSource();return s}return e}:e}get name(){return this.#i}toIR(t=[],e=[]){return new IR(replaceTabs(this.#se(t,e)))}load(t,e,n=[],r=[]){null!==onNotifyRawUsage&&onNotifyRawUsage(this.#i,1);let s=this.#i;if(n.length>0||r.length>0){let t=IRParametricName.parse(s);t=new IRParametricName(t.base,n,t.fn,r),s=t.toString()}if(!e.has(s)){const a=this.toIR(n,r),[i,o]=a.generateSource(),_=new Set;i.match(RE_BUILTIN)?.forEach((t=>_.add(t)));for(let n of _)if(t.has(n))assertDefined(t.get(n)).load(t,e);else{if(!IRParametricName.matches(n))throw new Error(`InternalError: dependency ${n} not found`);{const r=IRParametricName.parse(n),s=r.toTemplate(!0);let a=t.get(s);if(a)a.load(t,e,r.ttp,r.ftp);else{if(a=t.get(r.toTemplate(!1)),!a)throw new Error(`InternalError: dependency ${n} not found`);{const s=r.replaceTemplateNames(a.toIR());a=new RawFunc(n,s.toString()),a.load(t,e)}}}}e.set(s,a)}}}function makeRawFunctions(t,e=config.IS_TESTNET){let n=new Map;function r(t){if(n.has(t.name))throw new Error(`builtin ${t.name} duplicate`);n.set(t.name,t)}function s(t){r(new RawFunc(`${t}____neq`,`(self, other) -> {\n\t\t\t__helios__bool____not(${t}____eq(self, other))\n\t\t}`))}function a(t){r(new RawFunc(`${t}____eq`,`(self, other) -> {\n\t\t\t__core__equalsData(${t}____to_data(self), ${t}____to_data(other))\n\t\t}`))}function i(t){r(new RawFunc(`${t}__serialize`,`(self) -> {\n\t\t\t() -> {\n\t\t\t\t__core__serialiseData(${t}____to_data(self))\n\t\t\t}\n\t\t}`))}function o(t){r(new RawFunc(`${t}____eq`,"__helios__int____eq")),r(new RawFunc(`${t}____neq`,"__helios__int____neq")),r(new RawFunc(`${t}__serialize`,"__helios__int__serialize")),r(new RawFunc(`${t}__from_data`,"__helios__int__from_data")),r(new RawFunc(`${t}__from_data_safe`,"__helios__int__from_data_safe")),r(new RawFunc(`${t}____to_data`,"__helios__int____to_data"))}function _(t){r(new RawFunc(`${t}____eq`,"__helios__bytearray____eq")),r(new RawFunc(`${t}____neq`,"__helios__bytearray____neq")),r(new RawFunc(`${t}__serialize`,"__helios__bytearray__serialize")),r(new RawFunc(`${t}__from_data`,"__helios__bytearray__from_data")),r(new RawFunc(`${t}__from_data_safe`,"__helios__bytearray__from_data_safe")),r(new RawFunc(`${t}____to_data`,"__helios__bytearray____to_data")),r(new RawFunc(`${t}____lt`,"__helios__bytearray____lt")),r(new RawFunc(`${t}____leq`,"__helios__bytearray____leq")),r(new RawFunc(`${t}____gt`,"__helios__bytearray____gt")),r(new RawFunc(`${t}____geq`,"__helios__bytearray____geq")),r(new RawFunc(`${t}__new`,"__helios__common__identity")),r(new RawFunc(`${t}__bytes`,"__helios__common__identity")),r(new RawFunc(`${t}__show`,"__helios__bytearray__show"))}function l(t,e={}){r(new RawFunc(`${t}____eq`,e?.eq??"__helios__common____eq")),r(new RawFunc(`${t}____neq`,e?.neq??"__helios__common____neq")),r(new RawFunc(`${t}__serialize`,e?.serialize??"__helios__common__serialize")),r(new RawFunc(`${t}__from_data`,e?.from_data??"__helios__common__identity")),r(new RawFunc(`${t}__from_data_safe`,e?.from_data_safe??"(data) -> {__helios__option__SOME_FUNC(data)}")),r(new RawFunc(`${t}____to_data`,e?.to_data??"__helios__common__identity"))}function u(t,e){r(new RawFunc(`${t}____eq`,"__helios__common____eq")),r(new RawFunc(`${t}____neq`,"__helios__common____neq")),r(new RawFunc(`${t}__serialize`,"__helios__common__serialize")),r(new RawFunc(`${t}____to_data`,"__helios__common__identity")),r(new RawFunc(`${t}__from_data`,`(data) -> {\n\t\t\t__helios__common__assert_constr_index(data, ${e})\n\t\t}`)),r(new RawFunc(`${t}__from_data_safe`,`(data) -> {\n\t\t\t__core__chooseData(\n\t\t\t\tdata,\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(${e}, __core__fstPair(__core__unConstrData__safe(data))),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__option__SOME_FUNC(data)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__option__NONE_FUNC\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t\t)()\n\t\t}`))}r(new RawFunc("__helios__common__assert_constr_index",'(data, i) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(data)), i),\n\t\t\t() -> {data},\n\t\t\t() -> {__helios__error("unexpected constructor index")}\n\t\t)()\n\t}')),r(new RawFunc("__helios__common__identity","(self) -> {self}")),r(new RawFunc("__helios__common____eq","__core__equalsData")),r(new RawFunc("__helios__common____neq","(a, b) -> {\n\t\t__helios__bool____not(__core__equalsData(a, b))\n\t}")),r(new RawFunc("__helios__common__serialize","(self) -> {\n\t\t() -> {\n\t\t\t__core__serialiseData(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__common__any","(self, fn) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {false},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList__safe(self)),\n\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), fn)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__all","(self, fn) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {true},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(__core__headList__safe(self)),\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), fn)},\n\t\t\t\t\t\t\t() -> {false}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__map","(self, fn, init) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, init)\n\t\t}(\n\t\t\t(recurse, rem, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\trem,\n\t\t\t\t\t() -> {lst},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\tfn(__core__headList__safe(rem)),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(rem), lst)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__filter","(self, fn, nil) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {nil},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tfn(head),\n\t\t\t\t\t\t\t\t() -> {__core__mkCons(head, recurse(recurse, __core__tailList__safe(self), fn))},\n\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), fn)}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList__safe(self))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__filter_list","(self, fn) -> {\n\t\t__helios__common__filter(self, fn, __helios__common__list_0)\n\t}")),r(new RawFunc("__helios__common__filter_map","(self, fn) -> {\n\t\t__helios__common__filter(self, fn, __core__mkNilPairData(()))\n\t}")),r(new RawFunc("__helios__common__find",'(self, fn) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {__helios__error("not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tfn(head),\n\t\t\t\t\t\t\t\t() -> {head},\n\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), fn)}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList__safe(self))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}')),r(new RawFunc("__helios__common__find_safe","(self, fn, callback) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, fn)\n\t\t}(\n\t\t\t(recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {__core__constrData(1, __helios__common__list_0)},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tfn(head),\n\t\t\t\t\t\t\t\t() -> {__core__constrData(0, __helios__common__list_1(callback(head)))},\n\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), fn)}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList__safe(self))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__fold","(self, fn, z) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, z)\n\t\t}(\n\t\t\t(recurse, self, z) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {z},\n\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), fn(z, __core__headList__safe(self)))}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__fold_lazy","(self, fn, z) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self)\n\t\t}(\n\t\t\t(recurse, self) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {z},\n\t\t\t\t\t() -> {fn(__core__headList__safe(self), () -> {recurse(recurse, __core__tailList__safe(self))})}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__insert_in_sorted","(x, lst, comp) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, lst)\n\t\t}(\n\t\t\t(recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {__core__mkCons(x, lst)},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tcomp(x, head),\n\t\t\t\t\t\t\t\t() -> {__core__mkCons(x, lst)},\n\t\t\t\t\t\t\t\t() -> {__core__mkCons(head, recurse(recurse, __core__tailList__safe(lst)))}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList__safe(lst))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__sort","(lst, comp) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, lst)\n\t\t}(\n\t\t\t(recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {lst},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head, tail) -> {\n\t\t\t\t\t\t\t__helios__common__insert_in_sorted(head, tail, comp)\n\t\t\t\t\t\t}(__core__headList__safe(lst), recurse(recurse, __core__tailList__safe(lst)))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__map_get","(self, key, fnFound, fnNotFound) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, self, key)\n\t\t}(\n\t\t\t(recurse, self, key) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\tfnNotFound,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(head) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(head)),\n\t\t\t\t\t\t\t\t() -> {fnFound(__core__sndPair(head))},\n\t\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(self), key)}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}(__core__headList__safe(self))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__is_in_bytearray_list","(lst, key) -> {\n\t\t__helios__common__any(lst, (item) -> {__core__equalsData(item, key)})\n\t}")),r(new RawFunc("__helios__common__length","(lst) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, lst)\n\t\t}(\n\t\t\t(recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {0},\n\t\t\t\t\t() -> {__core__addInteger(recurse(recurse, __core__tailList__safe(lst)), 1)}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__concat","(a, b) -> {\n\t\t(recurse) -> {\n\t\t\trecurse(recurse, b, a)\n\t\t}(\n\t\t\t(recurse, lst, rem) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\trem,\n\t\t\t\t\t() -> {lst},\n\t\t\t\t\t() -> {__core__mkCons(__core__headList__safe(rem), recurse(recurse, lst, __core__tailList__safe(rem)))}\n\t\t\t\t)()\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__common__slice_bytearray","(self, selfLengthFn) -> {\n\t\t(start, end) -> {\n\t\t\t(normalize) -> {\n\t\t\t\t(fn) -> {\n\t\t\t\t\tfn(normalize(start))\n\t\t\t\t}(\n\t\t\t\t\t(start) -> {\n\t\t\t\t\t\t(fn) -> {\n\t\t\t\t\t\t\tfn(normalize(end))\n\t\t\t\t\t\t}(\n\t\t\t\t\t\t\t(end) -> {\n\t\t\t\t\t\t\t\t__core__sliceByteString(start, __core__subtractInteger(end, __helios__int__max(start, 0)), self)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}(\n\t\t\t\t(pos) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanInteger(pos, 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__addInteger(__core__addInteger(selfLengthFn(self), 1), pos)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tpos\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__common__starts_with","(self, selfLengthFn) -> {\n\t\t(prefix) -> {\n\t\t\t(n, m) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(n, m),\n\t\t\t\t\t() -> {false},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__equalsByteString(prefix, __core__sliceByteString(0, m, self))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}(selfLengthFn(self), __core__lengthOfByteString(prefix))\n\t\t}\n\t}")),r(new RawFunc("__helios__common__ends_with","(self, selfLengthFn) -> {\n\t\t(suffix) -> {\n\t\t\tn = selfLengthFn(self);\n\t\t\tm = __core__lengthOfByteString(suffix);\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(n, m),\n\t\t\t\t() -> {\n\t\t\t\t\tfalse\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__equalsByteString(suffix, __core__sliceByteString(__core__subtractInteger(n, m), m, self))\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__common__cip68_field",'(self, name) -> {\n\t\tname_data = __core__bData(name);\n\t\tmap = __core__unMapData(__core__headList(__core__sndPair(__core__unConstrData(self))));\n\t\trecurse = (recurse, map) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error(\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t"field ",\n\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t__helios__bytearray__show(name)(),\n\t\t\t\t\t\t\t\t" not found in struct"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\tkey = __core__fstPair(head);\n\t\t\t\t\tvalue = __core__sndPair(head);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsData(key, name_data),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, map)\n\t}')),r(new RawFunc("__helios__common__cip68_field_safe","(map, name) -> {\n\t\tname = __core__bData(name);\n\t\trecurse = (recurse, map) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__option__NONE_FUNC\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\tkey = __core__fstPair(head);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsData(key, name),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__option__SOME_FUNC(__core__sndPair(head))\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, map)\n\t}")),r(new RawFunc("__helios__common__test_cip68_field","(self, name, inner_test) -> {\n\t\t__core__chooseData(\n\t\t\tself,\n\t\t\t() -> {\n\t\t\t\tfields = __core__sndPair(__core__unConstrData__safe(self));\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tfields,\n\t\t\t\t\t() -> {false},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = __core__headList__safe(fields);\n\t\t\t\t\t\t__core__chooseData(\n\t\t\t\t\t\t\thead,\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tmap = __core__unMapData__safe(head);\n\t\t\t\t\t\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\tmap,\n\t\t\t\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\t\t\t\t\t\t\tkey = __core__fstPair(head);\n\t\t\t\t\t\t\t\t\t\t\tvalue = __core__sndPair(head);\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__equalsData(key, name),\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\tinner_test(value)\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\trecurse(recurse, map)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t() -> {false}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__common__enum_fields","(self) -> {\n\t\t__core__sndPair(__core__unConstrData(self))\n\t}")),r(new RawFunc("__helios__common__enum_field_0","(self) -> {\n\t\t__core__headList(__helios__common__enum_fields(self))\n\t}")),r(new RawFunc("__helios__common__enum_fields_after_0","(self) -> {\n\t\t__core__tailList(__helios__common__enum_fields(self))\n\t}"));for(let t=1;t<20;t++)r(new RawFunc(`__helios__common__enum_field_${t.toString()}`,`(self) -> {\n\t\t__core__headList(__helios__common__enum_fields_after_${(t-1).toString()}(self))\n\t}`)),r(new RawFunc(`__helios__common__enum_fields_after_${t.toString()}`,`(self) -> {\n\t\t__core__tailList(__helios__common__enum_fields_after_${(t-1).toString()}(self))\n\t}`));r(new RawFunc("__helios__common__struct_field_0","__core__headList")),r(new RawFunc("__helios__common__struct_fields_after_0","__core__tailList"));for(let t=1;t<20;t++)r(new RawFunc(`__helios__common__struct_field_${t.toString()}`,`(self) -> {\n\t\t__core__headList(__helios__common__struct_fields_after_${(t-1).toString()}(self))\n\t}`)),r(new RawFunc(`__helios__common__struct_fields_after_${t.toString()}`,`(self) -> {\n\t\t__core__tailList(__helios__common__struct_fields_after_${(t-1).toString()}(self))\n\t}`));r(new RawFunc("__helios__common__list_0","__core__mkNilData(())")),r(new RawFunc("__helios__common__list_1","(a) -> {\n\t\t__core__mkCons(a, __helios__common__list_0)\n\t}"));for(let t=2;t<20;t++){let e=[];for(let n=0;n<t;n++)e.push(`arg${n.toString()}`);let n=e.slice(),s=assertDefined(n.shift());r(new RawFunc(`__helios__common__list_${t.toString()}`,`(${e.join(", ")}) -> {\n\t\t__core__mkCons(${s}, __helios__common__list_${(t-1).toString()}(${n.join(", ")}))\n\t}`))}r(new RawFunc(`__helios__common__hash_datum_data[${FTPP}0]`,`(data) -> {\n\t\t__core__blake2b_256(${FTPP}0__serialize(data)())\n\t}`)),r(new RawFunc("__helios__common__test_constr_data_2","(data, index, test_a, test_b) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\tpair = __core__unConstrData__safe(data);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(__core__fstPair(pair), index),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tfields = __core__sndPair(pair);\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\ttest_a(__core__headList__safe(fields)),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\ttail = __core__tailList__safe(fields);\n\t\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\t\ttail,\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttest_b(__core__headList__safe(tail)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__tailList__safe(tail),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tfalse\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__print","(msg) -> {\n\t\t__core__trace(msg, ())\n\t}")),r(new RawFunc("__helios__error","(msg) -> {\n\t\t__core__trace(\n\t\t\tmsg,\n\t\t\t() -> {\n\t\t\t\terror()\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__assert","(cond, msg) -> {\n\t\t__core__ifThenElse(\n\t\t\tcond,\n\t\t\t() -> {\n\t\t\t\t()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__trace(\n\t\t\t\t\tmsg,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\terror()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__int____eq","__core__equalsInteger")),r(new RawFunc("__helios__int__from_data","__core__unIData")),r(new RawFunc("__helios__int__from_data_safe","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {\n\t\t\t\t__helios__option__SOME_FUNC(__core__unIData__safe(data))\n\t\t\t},\n\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t)()\n\t}")),r(new RawFunc("__helios__int__is_valid_data","(data) -> {\n\t\t__core__chooseData(data, false, false, false, true, false)\n\t}")),r(new RawFunc("__helios__int____to_data","__core__iData")),s("__helios__int"),i("__helios__int"),r(new RawFunc("__helios__int____neg","(self) -> {\n\t\t__core__multiplyInteger(self, -1)\n\t}")),r(new RawFunc("__helios__int____pos","__helios__common__identity")),r(new RawFunc("__helios__int____add","__core__addInteger")),r(new RawFunc("__helios__int____sub","__core__subtractInteger")),r(new RawFunc("__helios__int____mul","__core__multiplyInteger")),r(new RawFunc("__helios__int____div","__core__divideInteger")),r(new RawFunc("__helios__int____mod","__core__modInteger")),r(new RawFunc("__helios__int____add1","(a, b) -> {\n\t\t__core__addInteger(\n\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__int____sub1","(a, b) -> {\n\t\t__core__subtractInteger(\n\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__int____mul1","__helios__int____mul")),r(new RawFunc("__helios__int____div1","(a, b) -> {\n\t\t__core__divideInteger(\n\t\t\t__core__multiplyInteger(a, __helios__real__ONESQ),\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__int____geq","(a, b) -> {\n\t\t__helios__bool____not(__core__lessThanInteger(a, b))\n\t}")),r(new RawFunc("__helios__int____gt","(a, b) -> {\n\t\t__helios__bool____not(__core__lessThanEqualsInteger(a, b))\n\t}")),r(new RawFunc("__helios__int____leq","__core__lessThanEqualsInteger")),r(new RawFunc("__helios__int____lt","__core__lessThanInteger")),r(new RawFunc("__helios__int____geq1","(a, b) -> {\n\t\t__helios__bool____not(\n\t\t\t__core__lessThanInteger(\n\t\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\t\tb\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__int____gt1","(a, b) -> {\n\t\t__helios__bool____not(\n\t\t\t__core__lessThanEqualsInteger(\n\t\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\t\tb\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__int____leq1","(a, b) -> {\n\t\t__core__lessThanEqualsInteger(\n\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__int____lt1","(a, b) -> {\n\t\t__core__lessThanInteger(\n\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__int__min","(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanInteger(a, b),\n\t\t\ta,\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__int__max","(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanInteger(a, b),\n\t\t\tb,\n\t\t\ta\n\t\t)\n\t}")),r(new RawFunc("__helios__int__bound_min","(self) -> {\n\t\t(other) -> {\n\t\t\t__helios__int__max(self, other)\n\t\t}\n\t}")),r(new RawFunc("__helios__int__bound_max","(self) -> {\n\t\t(other) -> {\n\t\t\t__helios__int__min(self, other)\n\t\t}\n\t}")),r(new RawFunc("__helios__int__bound","(self) -> {\n\t\t(min, max) -> {\n\t\t\t__helios__int__max(__helios__int__min(self, max), min)\n\t\t}\n\t}")),r(new RawFunc("__helios__int__abs","(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__core__multiplyInteger(self, -1)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tself\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__int__encode_zigzag","(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__core__subtractInteger(__core__multiplyInteger(self, -2), 1)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__multiplyInteger(self, 2)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__int__decode_zigzag",'(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("expected positive int")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(__core__modInteger(self, 2), 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__divideInteger(self, 2)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__divideInteger(__core__addInteger(self, 1), -2)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc("__helios__int__to_bool","(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(__core__equalsInteger(self, 0), false, true)\n\t\t}\n\t}")),r(new RawFunc("__helios__int__to_real","(self) -> {\n\t\t() -> {\n\t\t\t__core__multiplyInteger(self, __helios__real__ONE)\n\t\t}\n\t}")),r(new RawFunc("__helios__int__to_hex","(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, self, bytes) -> {\n\t\t\t\tdigit = __core__modInteger(self, 16);\n\t\t\t\tbytes = __core__consByteString(\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanInteger(digit, 10),\n\t\t\t\t\t\t__core__addInteger(digit, 48),\n\t\t\t\t\t\t__core__addInteger(digit, 87)\n\t\t\t\t\t),\n\t\t\t\t\tbytes\n\t\t\t\t);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(self, 16),\n\t\t\t\t\t() -> {bytes},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse(recurse, __core__divideInteger(self, 16), bytes)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__decodeUtf8__safe(\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t45,\n\t\t\t\t\t\t\trecurse(recurse, __core__multiplyInteger(self, -1), #)\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse(recurse, self, #)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__common__BASE58_ALPHABET","#31323334353637383941424344454647484a4b4c4d4e505152535455565758595a6162636465666768696a6b6d6e6f707172737475767778797a")),r(new RawFunc("__helios__int__to_base58",'(self) -> {\n\t\t() -> {\n\t\t\t__core__decodeUtf8(\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("expected positive number")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse = (recurse, self, bytes) -> {\n\t\t\t\t\t\t\tdigit = __core__modInteger(self, 58);\n\t\t\t\t\t\t\tbytes = __core__consByteString(\n\t\t\t\t\t\t\t\t__core__indexByteString(__helios__common__BASE58_ALPHABET, digit),\n\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(self, 58),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__divideInteger(self, 58), bytes)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t};\n\t\t\t\t\t\trecurse(recurse, self, #)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t)\n\t\t}\n\t}')),r(new RawFunc("__helios__int__BASE58_INVERSE_ALPHABET_1","#ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000102030405060708ffffffffffff")),r(new RawFunc("__helios__int__BASE58_INVERSE_ALPHABET_2","#ff090a0b0c0d0e0f10ff1112131415ff161718191a1b1c1d1e1f20ffffffffffff2122232425262728292a2bff2c2d2e2f30313233343536373839ffffffffff")),r(new RawFunc("__helios__int__invert_base58_char",'(char) -> {\n\t\tdigit = __core__ifThenElse(\n\t\t\t__core__lessThanInteger(char, 64),\n\t\t\t() -> {\n\t\t\t\t__core__indexByteString(__helios__int__BASE58_INVERSE_ALPHABET_1, char)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(char, 128),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__indexByteString(\n\t\t\t\t\t\t\t__helios__int__BASE58_INVERSE_ALPHABET_2,\n\t\t\t\t\t\t\t__core__subtractInteger(char, 64)\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t0xff\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)();\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(digit, 0xff),\n\t\t\t() -> {\n\t\t\t\t__helios__error("invalid base58 character")\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\tdigit\n\t\t\t}\n\t\t)()\n\t}')),r(new RawFunc("__helios__int__from_base58","(str) -> {\n\t\tbytes = __core__encodeUtf8(str);\n\t\tn = __core__lengthOfByteString(bytes);\n\t\trecurse = (recurse, acc, pow, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(i, -1),\n\t\t\t\t() -> {\n\t\t\t\t\tacc\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tnew_acc = __core__addInteger(\n\t\t\t\t\t\tacc,\n\t\t\t\t\t\t__core__multiplyInteger(\n\t\t\t\t\t\t\t__helios__int__invert_base58_char(\n\t\t\t\t\t\t\t\t__core__indexByteString(bytes, i)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tpow\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\trecurse(recurse, new_acc, __core__multiplyInteger(pow, 58), __core__subtractInteger(i, 1))\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, 0, 1, __core__subtractInteger(n, 1))\n\t}")),r(new RawFunc("__helios__int__show_digit","(x) -> {\n\t\t__core__addInteger(__core__modInteger(x, 10), 48)\n\t}")),r(new RawFunc("__helios__int__show","(self) -> {\n\t\t() -> {\n\t\t\t__core__decodeUtf8__safe(\n\t\t\t\trecurse = (recurse, i, bytes) -> {\n\t\t\t\t\t(bytes) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanInteger(i, 10),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__divideInteger(i, 10), bytes)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}(__core__consByteString(__helios__int__show_digit(i), bytes))\n\t\t\t\t};\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t\t() -> {__core__consByteString(45, recurse(recurse, __core__multiplyInteger(self, -1), #))},\n\t\t\t\t\t() -> {recurse(recurse, self, #)}\n\t\t\t\t)()\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__int__show_padded","(self, n) -> {\n\t\trecurse = (recurse, x, pos, bytes) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(x, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanEqualsInteger(n, pos),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(\n\t\t\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t__core__addInteger(pos, 1),\n\t\t\t\t\t\t\t\t__core__consByteString(48, bytes)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse(\n\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t__core__divideInteger(x, 10),\n\t\t\t\t\t\t__core__addInteger(pos, 1),\n\t\t\t\t\t\t__core__consByteString(__helios__int__show_digit(x), bytes)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, self, 0, #)\n\t}")),r(new RawFunc("__helios__int__parse_digit",'(digit) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanEqualsInteger(digit, 57),\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanEqualsInteger(48, digit),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__subtractInteger(digit, 48)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("not a digit")\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__error("not a digit")\n\t\t\t}\n\t\t)()\n\t}')),r(new RawFunc("__helios__int__parse_hex_digit",'(hex) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanEqualsInteger(hex, 57),\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanEqualsInteger(48, hex),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__subtractInteger(hex, 48)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("not a hex digit")\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanEqualsInteger(hex, 70),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanEqualsInteger(65, hex),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__subtractInteger(hex, 55)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__error("not a hex digit")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanEqualsInteger(hex, 102),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__lessThanEqualsInteger(97, hex),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__subtractInteger(hex, 87)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__error("not a hex digit")\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__error("not a hex digit")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)()\n\t}')),r(new RawFunc("__helios__int__parse",'(string) -> {\n\t\tbytes = __core__encodeUtf8(string);\n\t\tn = __core__lengthOfByteString(bytes);\n\t\tb0 = __core__indexByteString(bytes, 0);\n\t\trecurse = (recurse, acc, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(i, n),\n\t\t\t\t() -> {\n\t\t\t\t\tacc\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tnew_acc = __core__addInteger(\n\t\t\t\t\t\t__core__multiplyInteger(acc, 10),\n\t\t\t\t\t\t__helios__int__parse_digit(__core__indexByteString(bytes, i))\n\t\t\t\t\t);\n\t\t\t\t\trecurse(recurse, new_acc, __core__addInteger(i, 1))\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(b0, 48),\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(n, 1),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t0\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("zero padded integer can\'t be parsed")\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(b0, 45),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(__core__indexByteString(bytes, 1), 48),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__error("-0 not allowed")\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__multiplyInteger(\n\t\t\t\t\t\t\t\t\trecurse(recurse, 0, 1),\n\t\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse(recurse, 0, 0)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)()\n\t}')),r(new RawFunc("__helios__int__from_big_endian","(bytes) -> {\n\t\tn = __core__lengthOfByteString(bytes);\n\t\trecurse = (recurse, acc, pow, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(i, -1),\n\t\t\t\t() -> {\n\t\t\t\t\tacc\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tnew_acc = __core__addInteger(\n\t\t\t\t\t\tacc,\n\t\t\t\t\t\t__core__multiplyInteger(__core__indexByteString(bytes, i), pow)\n\t\t\t\t\t);\n\t\t\t\t\trecurse(recurse, new_acc, __core__multiplyInteger(pow, 256), __core__subtractInteger(i, 1))\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, 0, 1, __core__subtractInteger(n, 1))\n\t}")),r(new RawFunc("__helios__int__from_little_endian","(bytes) -> {\n\t\tn = __core__lengthOfByteString(bytes);\n\t\trecurse = (recurse, acc, pow, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(i, n),\n\t\t\t\t() -> {\n\t\t\t\t\tacc\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tnew_acc = __core__addInteger(\n\t\t\t\t\t\tacc,\n\t\t\t\t\t\t__core__multiplyInteger(__core__indexByteString(bytes, i), pow)\n\t\t\t\t\t);\n\t\t\t\t\trecurse(recurse, new_acc, __core__multiplyInteger(pow, 256), __core__addInteger(i, 1))\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, 0, 1, 0)\n\t}")),r(new RawFunc("__helios__int__to_big_endian",'(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("can\'t convert negative number to big endian bytearray")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse = (recurse, self, bytes) -> {\n\t\t\t\t\t\tbytes = __core__consByteString(__core__modInteger(self, 256), bytes);\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__lessThanInteger(self, 256),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(\n\t\t\t\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t\t\t\t__core__divideInteger(self, 256),\n\t\t\t\t\t\t\t\t\tbytes\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t};\n\t\t\t\t\trecurse(recurse, self, #)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc("__helios__int__to_little_endian",'(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(self, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("can\'t convert negative number to little endian bytearray")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse = (recurse, self) -> {\n\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t__core__modInteger(self, 256),\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(self, 256),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t#\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__divideInteger(self, 256))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t)\n\t\t\t\t\t};\n\t\t\t\t\trecurse(recurse, self)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc("__helios__int__sqrt",'(x) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__lessThanInteger(x, 2),\n\t\t\t() -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(x, 1),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t1\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(x, 0),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__error("negative number in sqrt")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\trecurse = (recurse, x0) -> {\n\t\t\t\t\tx1 = __core__divideInteger(\n\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\tx0,\n\t\t\t\t\t\t\t__core__divideInteger(x, x0)\n\t\t\t\t\t\t),\n\t\t\t\t\t\t2\n\t\t\t\t\t);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanEqualsInteger(x0, x1),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tx0\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(recurse, x1)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t};\n\t\t\t\trecurse(recurse, __core__divideInteger(x, 2))\n\t\t\t}\n\t\t)()\n\t}')),o("__helios__real"),r(new RawFunc("__helios__real__is_valid_data","__helios__int__is_valid_data")),r(new RawFunc("__helios__real__PRECISION",6..toString())),r(new RawFunc("__helios__real__ONE","1"+new Array(6).fill("0").join(""))),r(new RawFunc("__helios__real__HALF","5"+new Array(5).fill("0").join(""))),r(new RawFunc("__helios__real__NEARLY_ONE",new Array(6).fill("9").join(""))),r(new RawFunc("__helios__real__ONESQ","1"+new Array(12).fill("0").join(""))),r(new RawFunc("__helios__real____neg","__helios__int____neg")),r(new RawFunc("__helios__real____pos","__helios__int____pos")),r(new RawFunc("__helios__real____add","__helios__int____add")),r(new RawFunc("__helios__real____add1","(a, b) -> {\n\t\t__core__addInteger(\n\t\t\ta,\n\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____sub","__helios__int____sub")),r(new RawFunc("__helios__real____sub1","(a, b) -> {\n\t\t__core__subtractInteger(\n\t\t\ta,\n\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____mul","(a, b) -> {\n\t\t__core__divideInteger(\n\t\t\t__core__multiplyInteger(a, b),\n\t\t\t__helios__real__ONE\n\t\t)\n\t}")),r(new RawFunc("__helios__real____mul1","__helios__int____mul")),r(new RawFunc("__helios__real____div","(a, b) -> {\n\t\t__core__divideInteger(\n\t\t\t__core__multiplyInteger(a, __helios__real__ONE),\n\t\t\tb\n\t\t)\n\t}")),r(new RawFunc("__helios__real____div1","__helios__int____div")),r(new RawFunc("__helios__real____geq","__helios__int____geq")),r(new RawFunc("__helios__real____gt","__helios__int____gt")),r(new RawFunc("__helios__real____leq","__helios__int____leq")),r(new RawFunc("__helios__real____lt","__helios__int____lt")),r(new RawFunc("__helios__real____eq1","(a, b) -> {\n\t\t__core__equalsInteger(a,\n\t\t\t__core__multiplyInteger(\n\t\t\t\tb,\n\t\t\t\t__helios__real__ONE\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____neq1","(a, b) -> {\n\t\t__helios__bool____not(\n\t\t\t__core__equalsInteger(\n\t\t\t\ta,\n\t\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____geq1","(a, b) -> {\n\t\t__helios__bool____not(\n\t\t\t__core__lessThanInteger(\n\t\t\t\ta,\n\t\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____gt1","(a, b) -> {\n\t\t__helios__bool____not(\n\t\t\t__core__lessThanEqualsInteger(\n\t\t\t\ta,\n\t\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____leq1","(a, b) -> {\n\t\t__core__lessThanEqualsInteger(\n\t\t\ta,\n\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t)\n\t}")),r(new RawFunc("__helios__real____lt1","(a, b) -> {\n\t\t__core__lessThanInteger(\n\t\t\ta,\n\t\t\t__core__multiplyInteger(b, __helios__real__ONE)\n\t\t)\n\t}")),r(new RawFunc("__helios__real__abs","__helios__int__abs")),r(new RawFunc("__helios__real__sqrt","(self) -> {\n\t\t__helios__int__sqrt(\n\t\t\t__helios__int____mul(self, __helios__real__ONE)\n\t\t)\n\t}")),r(new RawFunc("__helios__real__floor","(self) -> {\n\t\t() -> {\n\t\t\t__core__divideInteger(self, __helios__real__ONE)\n\t\t}\n\t}")),r(new RawFunc("__helios__real__trunc","(self) -> {\n\t\t() -> {\n\t\t\t__core__quotientInteger(self, __helios__real__ONE)\n\t\t}\n\t}")),r(new RawFunc("__helios__real__ceil","(self) -> {\n\t\t() -> {\n\t\t\t__core__divideInteger(\n\t\t\t\t__core__addInteger(self, __helios__real__NEARLY_ONE),\n\t\t\t\t__helios__real__ONE\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__real__round","(self) -> {\n\t\t() -> {\n\t\t\t__core__divideInteger(\n\t\t\t\t__core__addInteger(self, __helios__real__HALF),\n\t\t\t\t__helios__real__ONE\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__real__show",'(self) -> {\n\t\t() -> {\n\t\t\t__helios__string____add(\n\t\t\t\t__helios__string____add(\n\t\t\t\t\t__core__ifThenElse(__core__lessThanInteger(self, 0), "-", ""),\n\t\t\t\t\t__helios__int__show(\n\t\t\t\t\t\t__helios__real__floor(\n\t\t\t\t\t\t\t__helios__real__abs(self)()\n\t\t\t\t\t\t)()\n\t\t\t\t\t)()\n\t\t\t\t),\n\t\t\t\t__helios__string____add(\n\t\t\t\t\t".",\n\t\t\t\t\t__core__decodeUtf8(\n\t\t\t\t\t\t__helios__int__show_padded(\n\t\t\t\t\t\t\t__helios__int____mod(self, __helios__real__ONE),\n\t\t\t\t\t\t\t__helios__real__PRECISION\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}')),i("__helios__bool"),r(new RawFunc("__helios__bool__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\tpair = __core__unConstrData__safe(data);\n\t\t\t\tindex = __core__fstPair(pair);\n\t\t\t\tfields = __core__sndPair(pair);\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tfields,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(0, index),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(1, index),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tfalse\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__bool____eq","(a, b) -> {\n\t\t__core__ifThenElse(a, b, __helios__bool____not(b))\n\t}")),r(new RawFunc("__helios__bool____neq","(a, b) -> {\n\t\t__core__ifThenElse(a, __helios__bool____not(b), b)\n\t}")),r(new RawFunc("__helios__bool__from_data","(d) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(d)), 0),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t)\n\t}")),r(new RawFunc("__helios__bool__from_data_safe","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\t__helios__option__SOME_FUNC(\n\t\t\t\t\t__core__equalsInteger(\n\t\t\t\t\t\t__core__fstPair(\n\t\t\t\t\t\t\t__core__unConstrData__safe(data)\n\t\t\t\t\t\t),\n\t\t\t\t\t\t1\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t)()\n\t}")),r(new RawFunc("__helios__bool____to_data","(b) -> {\n\t\t__core__constrData(__core__ifThenElse(b, 1, 0), __helios__common__list_0)\n\t}")),r(new RawFunc("__helios__bool__and","(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\ta(),\n\t\t\t() -> {b()},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__bool__or","(a, b) -> {\n\t\t__core__ifThenElse(\n\t\t\ta(),\n\t\t\t() -> {true},\n\t\t\t() -> {b()}\n\t\t)()\n\t}")),r(new RawFunc("__helios__bool____not","(b) -> {\n\t\t__core__ifThenElse(b, false, true)\n\t}")),r(new RawFunc("__helios__bool__to_int","(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(self, 1, 0)\n\t\t}\n\t}")),r(new RawFunc("__helios__bool__show",'(self) -> {\n\t\t() -> {\n\t\t\t__core__ifThenElse(self, "true", "false")\n\t\t}\n\t}')),r(new RawFunc("__helios__bool__trace","(self) -> {\n\t\t(prefix) -> {\n\t\t\t__core__trace(\n\t\t\t\t__helios__string____add(\n\t\t\t\t\tprefix,\n\t\t\t\t\t__helios__bool__show(self)()\n\t\t\t\t),\n\t\t\t\tself\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__bool__trace_if_false","(self) -> {\n\t\t(msg) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tself,\n\t\t\t\t() -> {\n\t\t\t\t\tself\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__trace(msg, self)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__bool__trace_if_true","(self) -> {\n\t\t(msg) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tself,\n\t\t\t\t() -> {\n\t\t\t\t\t__core__trace(msg, self)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tself\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),i("__helios__string"),s("__helios__string"),r(new RawFunc("__helios__string____eq","__core__equalsString")),r(new RawFunc("__helios__string__from_data","(d) -> {\n\t\t__core__decodeUtf8(__core__unBData(d))\n\t}")),r(new RawFunc("__helios__string__from_data_safe","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {\n\t\t\t\tbytes = __core__unBData__safe(data);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__helios__string__is_valid_utf8(bytes),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__option__SOME_FUNC(__core__decodeUtf8__safe(bytes))\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__option__NONE_FUNC\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__string__show",'(self) -> {\n\t\t() -> {\n\t\t\t__core__appendString(\n\t\t\t\t"\'",\n\t\t\t\t__core__appendString(\n\t\t\t\t\tself,\n\t\t\t\t\t"\'"\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}')),r(new RawFunc("__helios__string__parse_utf8_cont_byte","(byte, callback) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__divideInteger(byte, 64), 2),\n\t\t\t() -> {\n\t\t\t\tcallback(true, __core__modInteger(byte, 64))\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\tcallback(false, 0)\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__string__is_valid_utf8","(bytes) -> {\n\t\tn = __core__lengthOfByteString(bytes);\n\t\trecurse = (recurse, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(i, n),\n\t\t\t\t() -> {\n\t\t\t\t\ttrue\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tb0 = __core__indexByteString__safe(bytes, i);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__lessThanEqualsInteger(b0, 127),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(recurse, __core__addInteger(i, 1))\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__equalsInteger(__core__divideInteger(b0, 32), 6),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tinext = __core__addInteger(i, 2);\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__lessThanEqualsInteger(inext, n),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t__helios__string__parse_utf8_cont_byte(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(bytes, __core__addInteger(i, 1)),\n\t\t\t\t\t\t\t\t\t\t\t\t(valid, c1) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = __core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(__core__modInteger(b0, 32), 64),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(128, c)},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(c, 2047)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, inext)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(__core__divideInteger(b0, 16), 14),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\tinext = __core__addInteger(i, 3);\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__lessThanEqualsInteger(inext, n),\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string__parse_utf8_cont_byte(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(bytes, __core__addInteger(i, 1)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(valid, c1) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string__parse_utf8_cont_byte(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(bytes, __core__addInteger(i, 2)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(valid, c2) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = __core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(__core__modInteger(b0, 16), 4096),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(c1, 64),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc2\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(2048, c)},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(c, 65535)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, inext)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(__core__divideInteger(b0, 8), 30),\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\tinext = __core__addInteger(i, 4);\n\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__lessThanEqualsInteger(inext, n),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string__parse_utf8_cont_byte(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(bytes, __core__addInteger(i, 1)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(valid, c1) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string__parse_utf8_cont_byte(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(bytes, __core__addInteger(i, 2)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(valid, c2) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string__parse_utf8_cont_byte(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(bytes, __core__addInteger(i, 3)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(valid, c3) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = __core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(__core__modInteger(b0, 8), 262144),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(c1, 4096),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__addInteger(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__multiplyInteger(c2, 64),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc3\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(65536, c)},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(c, 2097151)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, inext)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, 0)\n\t}")),r(new RawFunc("__helios__string__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {\n\t\t\t\t__helios__string__is_valid_utf8(__core__unBData__safe(data))\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__string____to_data","(s) -> {\n\t\t__core__bData(__core__encodeUtf8(s))\n\t}")),r(new RawFunc("__helios__string____add","__core__appendString")),r(new RawFunc("__helios__string__starts_with","(self) -> {\n\t\t(prefix) -> {\n\t\t\t__helios__bytearray__starts_with(\n\t\t\t\t__core__encodeUtf8(self)\n\t\t\t)(__core__encodeUtf8(prefix))\n\t\t}\n\t}")),r(new RawFunc("__helios__string__ends_with","(self) -> {\n\t\t(suffix) -> {\n\t\t\t__helios__bytearray__ends_with(\n\t\t\t\t__core__encodeUtf8(self)\n\t\t\t)(__core__encodeUtf8(suffix))\n\t\t}\n\t}")),r(new RawFunc("__helios__string__encode_utf8","(self) -> {\n\t\t() -> {\n\t\t\t__core__encodeUtf8(self)\n\t\t}\n\t}")),i("__helios__bytearray"),s("__helios__bytearray"),r(new RawFunc("__helios__bytearray__parse","(string) -> {\n\t\thex = __core__encodeUtf8(string);\n\t\ti = __core__subtractInteger(__core__lengthOfByteString(hex), 1);\n\t\trecurse = (recurse, tail, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(i, -1),\n\t\t\t\t() -> {\n\t\t\t\t\ttail\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tbyte = __core__addInteger(\n\t\t\t\t\t\t__helios__int__parse_hex_digit(__core__indexByteString(hex, i)),\n\t\t\t\t\t\t__core__multiplyInteger(\n\t\t\t\t\t\t\t16,\n\t\t\t\t\t\t\t__helios__int__parse_hex_digit(__core__indexByteString(hex, __core__subtractInteger(i, 1)))\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\trecurse(\n\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t__core__consByteString(byte, tail),\n\t\t\t\t\t\t__core__subtractInteger(i, 2)\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, #, i)\n\t}")),r(new RawFunc("__helios__bytearray____eq","__core__equalsByteString")),r(new RawFunc("__helios__bytearray__from_data","__core__unBData")),r(new RawFunc("__helios__bytearray__from_data_safe","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__SOME_FUNC(__core__unBData__safe(data))}\n\t\t)()\n\t}")),r(new RawFunc("__helios__bytearray__is_valid_data","(data) -> {\n\t\t__core__chooseData(data, false, false, false, false, true)\n\t}")),r(new RawFunc("__helios__bytearray__is_valid_data_fixed_length","(data, n) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {\n\t\t\t\tbytes = __core__unBData__safe(data);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(__core__lengthOfByteString(bytes), n),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\ttrue\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tfalse\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__bytearray____to_data","__core__bData")),r(new RawFunc("__helios__bytearray____add","__core__appendByteString")),r(new RawFunc("__helios__bytearray____geq","(a, b) -> {\n\t\t__helios__bool____not(__core__lessThanByteString(a, b))\n\t}")),r(new RawFunc("__helios__bytearray____gt","(a, b) -> {\n\t\t__helios__bool____not(__core__lessThanEqualsByteString(a, b))\n\t}")),r(new RawFunc("__helios__bytearray____leq","__core__lessThanEqualsByteString")),r(new RawFunc("__helios__bytearray____lt","__core__lessThanByteString")),r(new RawFunc("__helios__bytearray__length","__core__lengthOfByteString")),r(new RawFunc("__helios__bytearray__slice","(self) -> {\n\t\t__helios__common__slice_bytearray(self, __core__lengthOfByteString)\n\t}")),r(new RawFunc("__helios__bytearray__starts_with","(self) -> {\n\t\t__helios__common__starts_with(self, __core__lengthOfByteString)\n\t}")),r(new RawFunc("__helios__bytearray__ends_with","(self) -> {\n\t\t__helios__common__ends_with(self, __core__lengthOfByteString)\n\t}")),r(new RawFunc("__helios__bytearray__prepend","(self) -> {\n\t\t(byte) -> {\n\t\t\t__core__consByteString(byte, self)\n\t\t}\n\t}")),r(new RawFunc("__helios__bytearray__sha2","(self) -> {\n\t\t() -> {\n\t\t\t__core__sha2_256(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__bytearray__sha3","(self) -> {\n\t\t() -> {\n\t\t\t__core__sha3_256(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__bytearray__blake2b","(self) -> {\n\t\t() -> {\n\t\t\t__core__blake2b_256(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__bytearray__decode_utf8","(self) -> {\n\t\t() -> {\n\t\t\t__core__decodeUtf8(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__bytearray__show",'(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, self) -> {\n\t\t\t\tn = __core__lengthOfByteString(self);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanInteger(0, n),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t__core__decodeUtf8__safe(\n\t\t\t\t\t\t\t\thex_bytes = (\n\t\t\t\t\t\t\t\t\t__core__encodeUtf8(\n\t\t\t\t\t\t\t\t\t\t__helios__int__to_hex(\n\t\t\t\t\t\t\t\t\t\t\t__core__indexByteString__safe(self, 0)\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(__core__lengthOfByteString(hex_bytes), 1),\n\t\t\t\t\t\t\t\t\t__core__consByteString(48, hex_bytes),\n\t\t\t\t\t\t\t\t\thex_bytes\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trecurse(recurse, __core__sliceByteString(1, n, self))\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t""\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}'));for(let t=1;t<=10;t++){const e=`__helios__iterator__${t}`,n=new Array(t).fill("").map(((t,e)=>`head${e}`)).join(", "),s=new Array(t).fill("").map(((t,e)=>"()")).join(", "),a=1==t?`${n}`:`(callback) -> {callback(${n})}`;r(new RawFunc(`${e}__drop`,`(self) -> {\n\t\t(n) -> {\n\t\t\trecurse = (recurse, iterator, i) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanEqualsInteger(i, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titerator\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titerator(\n\t\t\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\titerator\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator, __core__subtractInteger(i, 1))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, n)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__is_empty`,`(self) -> {\n\t\t() -> {\n\t\t\tself(\n\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\tis_null\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__head`,`(self) -> {\n\t\tself(\n\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t${a}\n\t\t\t}\n\t\t)\n\t}`)),r(new RawFunc(`${e}__tail`,`(self) -> {\n\t\tself(\n\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\tnext_iterator\n\t\t\t}\n\t\t)\n\t}`)),r(new RawFunc(`${e}__get`,`(self) -> {\n\t\t(i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(i, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("negative index in iterator.get()")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse = (recurse, iterator, i) -> {\n\t\t\t\t\t\titerator(\n\t\t\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__error("index out of range")\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(i, 0),\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t${a}\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator, __core__subtractInteger(i, 1))\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t};\n\t\t\t\t\trecurse(recurse, self, i)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc(`${e}__get_singleton`,`(self) -> {\n\t\t() -> {\n\t\t\tself(\n\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__error("empty iterator, not a singleton")\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t${e}__is_empty(next_iterator)(),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t${a}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__helios__error("not a singleton iterator")\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__take`,`(self) -> {\n\t\t(n) -> {\n\t\t\trecurse = (recurse, iterator, i) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__lessThanEqualsInteger(i, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\tcallback(true, ${s}, ())\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titerator(\n\t\t\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\titerator\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\tcallback(false, ${n}, recurse(recurse, next_iterator, __core__subtractInteger(i, 1)))\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, n)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__for_each`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, iterator) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t\t\t\t\tfn(${n}),\n\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__fold[${FTPP}0]`,`(self) -> {\n\t\t(fn, z0) -> {\n\t\t\trecurse = (recurse, iterator, z) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tz\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, next_iterator, fn(z, ${n}))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self, z0)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__find`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, iterator) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__error("not found")\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tfn(${n}),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t${a}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__any`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, iterator) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tfn(${n}),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__prepend`,`(self) -> {\n\t\t(${n}) -> {\n\t\t\t(callback) -> {\n\t\t\t\tcallback(false, ${n}, self)\n\t\t\t}\n\t\t}\n\t}`)),r(new RawFunc(`${e}__filter`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, iterator) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tcallback(true, ${s}, ())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\tfn(${n}),\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\tcallback(false, ${n}, recurse(recurse, next_iterator))\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator)(callback)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__map[${FTPP}0]`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, iterator) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tcallback(true, (), ())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tcallback(false, fn(${n}), recurse(recurse, next_iterator))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__map2[${FTPP}0@${FTPP}1]`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, iterator) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tcallback(true, (), (), ())\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tfn(${n})(\n\t\t\t\t\t\t\t\t\t\t(new_head0, new_head1) -> {\n\t\t\t\t\t\t\t\t\t\t\tcallback(false, new_head0, new_head1, recurse(recurse, next_iterator))\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`${e}__zip[${FTPP}0]`,`(self) -> {\n\t\t(lst) -> {\n\t\t\trecurse = (recurse, iterator, lst) -> {\n\t\t\t\titerator(\n\t\t\t\t\t(is_null, ${n}, next_iterator) -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\tcallback(true, ${s}, (), ())\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\tlst,\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tcallback(true, ${s}, (), ())\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\t\t${n},\n\t\t\t\t\t\t\t\t\t\t\t${FTPP}0__from_data(__core__headList__safe(lst)),\n\t\t\t\t\t\t\t\t\t\t\trecurse(recurse, next_iterator, __core__tailList__safe(lst))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self, lst)\n\t\t}\n\t}`))}i("__helios__struct"),s("__helios__struct"),a("__helios__struct"),r(new RawFunc("__helios__struct__from_data","__core__unListData")),r(new RawFunc("__helios__struct____to_data","__core__listData")),r(new RawFunc("__helios__tuple[]____to_func",(t=>"__helios__common__identity"))),r(new RawFunc("__helios__tuple[]__from_data",(t=>(assert(t.length>=2),`(data) -> {\n\t\t\tfields = __core__unListData(data);\n\t\t\t(callback) -> {\n\t\t\t\tcallback(${t.map(((t,e)=>{let n="fields";for(let t=0;t<e;t++)n=`__core__tailList(${n})`;return`${t}__from_data(__core__headList(${n}))`})).join(", ")})\n\t\t\t}\n\t\t}`)))),r(new RawFunc("__helios__tuple[]__from_data_safe",(t=>{assert(t.length>=2);let e=`__helios__option__SOME_FUNC(\n\t\t\t(callback) -> {\n\t\t\t\tcallback(${t.map(((t,e)=>`opt${e}`)).join(", ")})\n\t\t\t}\n\t\t}`;for(let n=t.length-1;n>=0;n--)e=`opt${n}(\n\t\t\t\t(valid, value${n}) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t${e}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__option__NONE_FUNC\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)`;for(let n=t.length-1;n>=0;n--)e=`(fields) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tfields,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__option__NONE_FUNC\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(opt${n}) -> {\n\t\t\t\t\t\t\t${n==t.length-1?e:`${e}(__core__tailList__safe(fields))`}\n\t\t\t\t\t\t}(${t[n]}__from_data_safe(__core__headList__safe(fields)))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t}`;return`(data) -> {\n\t\t\t__core__chooseData(\n\t\t\t\tdata,\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {\n\t\t\t\t\t${e}(__core__unListData__safe(data))\n\t\t\t\t},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t\t)\n\t\t}`}))),r(new RawFunc("__helios__tuple[]__show",(t=>{let e=`${t[t.length-1]}__show(x${t.length-1})()`;for(let n=t.length-2;n>=0;n--)e=`__core__appendString(\n\t\t\t\t${t[n]}__show(x${n})(),\n\t\t\t\t__core__appendString(\n\t\t\t\t\t", ",\n\t\t\t\t\t${e}\n\t\t\t\t)\n\t\t\t)`;return`(tuple) -> {\n\t\t\t() -> {\n\t\t\t\ttuple(\n\t\t\t\t\t(${t.map(((t,e)=>`x${e}`)).join(", ")}) -> {\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t"(",\n\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t${e},\n\t\t\t\t\t\t\t\t")"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t}`}))),r(new RawFunc("__helios__tuple[]____to_data",(t=>{assert(t.length>=2);let e="__core__mkNilData(())";for(let n=t.length-1;n>=0;n--)e=`__core__mkCons(${t[n]}____to_data(x${n}), ${e})`;return`(tuple) -> {\n\t\t\ttuple(\n\t\t\t\t(${t.map(((t,e)=>`x${e}`)).join(", ")}) -> {\n\t\t\t\t\t__core__listData(${e})\n\t\t\t\t}\n\t\t\t)\n\t\t}`}))),r(new RawFunc("__helios__tuple[]__is_valid_data",(t=>{assert(t.length>=2);let e="__core__chooseList(\n\t\t\tlist,\n\t\t\t() -> {true},\n\t\t\t() -> {false}\n\t\t)()";for(let n=t.length-1;n>=0;n--){e=`__core__chooseList(\n\t\t\t\tlist,\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {\n\t\t\t\t\thead = __core__headList__safe(list);\n\t\t\t\t\tlist = __core__tailList__safe(list);\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t() -> {${t[n]}__is_valid_data(head)},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t${e}\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()`}return`(data) -> {\n\t\t\t__core__chooseData(\n\t\t\t\tdata,\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {\n\t\t\t\t\tlist = __core__unListData__safe(list);\n\t\t\t\t\t${e}\n\t\t\t\t},\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {false}\n\t\t\t)()\n\t\t}`}))),r(new RawFunc("__helios__tuple[]__serialize",(t=>(assert(t.length>=2),`(tuple) -> {\n\t\t\t__helios__common__serialize(__helios__tuple[${t.join("@")}]____to_data(tuple))\n\t\t}`)))),r(new RawFunc("__helios__tuple[]____eq",(t=>(assert(t.length>=2),`(a, b) -> {\n\t\t\t__helios__common____eq(\n\t\t\t\t__helios__tuple[${t.join("@")}]____to_data(a),\n\t\t\t\t__helios__tuple[${t.join("@")}]____to_data(b)\n\t\t\t)\n\t\t}`)))),r(new RawFunc("__helios__tuple[]____neq",(t=>(assert(t.length>=2),`(a, b) -> {\n\t\t\t__helios__common____neq(\n\t\t\t\t__helios__tuple[${t.join("@")}]____to_data(a),\n\t\t\t\t__helios__tuple[${t.join("@")}]____to_data(b)\n\t\t\t)\n\t\t}`)))),["first","second","third","fourth","fifth"].forEach(((t,e)=>{r(new RawFunc(`__helios__tuple[]__${t}`,(t=>(assert(t.length>=2),`(tuple) -> {\n\t\t\t\ttuple(\n\t\t\t\t\t(${t.map(((t,e)=>`x${e}`)).join(", ")}) -> {\n\t\t\t\t\t\tx${e}\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}`))))})),i(`__helios__list[${TTPP}0]`),s(`__helios__list[${TTPP}0]`),a(`__helios__list[${TTPP}0]`),r(new RawFunc(`__helios__list[${TTPP}0]__is_valid_data_internal`,`(lst) -> {\n\t\trecurse = (recurse, lst) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tlst,\n\t\t\t\t() -> {\n\t\t\t\t\ttrue\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t${TTPP}0__is_valid_data(__core__headList__safe(lst)),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, lst)\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__from_data`,`(data) -> {\n\t\tlst = __core__unListData(data);\n\t\t_ = __core__ifThenElse(\n\t\t\t__helios__list[${TTPP}0]__is_valid_data_internal(lst),\n\t\t\t() -> {\n\t\t\t\t()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__trace("Warning: invalid list data", ())\n\t\t\t}\n\t\t)();\n\t\tlst\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__from_data_safe`,"(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {\n\t\t\t\t__helios__option__SOME_FUNC(__core__unListData__safe(data))\n\t\t\t},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t)()\n\t}")),r(new RawFunc(`__helios__list[${TTPP}0]__is_valid_data`,`(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {\n\t\t\t\t__helios__list[${TTPP}0]__is_valid_data_internal(__core__unListData__safe(data))\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]____to_data`,"__core__listData")),r(new RawFunc(`__helios__list[${TTPP}0]__show`,`(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, self, first) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t""\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tfirst,\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t""\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\thead = ${TTPP}0__from_data_safe(__core__headList__safe(self));\n\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\thead(\n\t\t\t\t\t\t\t\t\t(valid, value) -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t${TTPP}0__show(value)()\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t"<n/a>"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(self), false)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__appendString(\n\t\t\t\t"[",\n\t\t\t\t__core__appendString(\n\t\t\t\t\trecurse(recurse, self, true),\n\t\t\t\t\t"]"\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__new`,`(n, fn) -> {\n\t\trecurse = (recurse, i) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(i, n),\n\t\t\t\t() -> {__core__mkCons(${TTPP}0____to_data(fn(i)), recurse(recurse, __core__addInteger(i, 1)))},\n\t\t\t\t() -> {__core__mkNilData(())}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, 0)\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__new_const`,`(n, item) -> {\n\t\t__helios__list[${TTPP}0]__new(n, (i) -> {item})\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]____add`,"__helios__common__concat")),r(new RawFunc(`__helios__list[${TTPP}0]__length`,"__helios__common__length")),r(new RawFunc(`__helios__list[${TTPP}0]__head`,`(self) -> {\n\t\t${TTPP}0__from_data(__core__headList(self))\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__tail`,"__core__tailList")),r(new RawFunc(`__helios__list[${TTPP}0]__is_empty`,"(self) -> {\n\t\t() -> {\n\t\t\t__core__nullList(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__list[__helios__data]__to_iterator","(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t(callback) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tlst,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tcallback(true, (), ())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t__core__headList__safe(lst),\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}")),r(new RawFunc(`__helios__list[${TTPP}0]__to_iterator`,`(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t(callback) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tlst,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tcallback(true, (), ())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t${TTPP}0__from_data(__core__headList__safe(lst)),\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__from_iterator`,`(iterator) -> {\n\t\trecurse = (recurse, iterator) -> {\n\t\t\titerator(\n\t\t\t\t(is_null, head, next_iterator) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__mkNilData(())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t${TTPP}0____to_data(head),\n\t\t\t\t\t\t\t\trecurse(recurse, next_iterator)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t};\n\t\trecurse(recurse, iterator)\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__zip[${FTPP}0]`,`(self) -> {\n\t\t(other) -> {\n\t\t\trecurse = (recurse, lst1, lst2) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst1,\n\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\tcallback(true, (), (), ())\n\t\t\t\t\t},\n\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tlst2,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tcallback(true, (), (), ())\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t${TTPP}0__from_data(__core__headList__safe(lst1)),\n\t\t\t\t\t\t\t\t\t${FTPP}0__from_data(__core__headList__safe(lst2)),\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst1), __core__tailList__safe(lst2))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t};\n\t\t\trecurse(recurse, self, other)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__get`,`(self) -> {\n\t\t(index) -> {\n\t\t\t${TTPP}0__from_data(__helios__list[__helios__data]__get(self)(index))\n\t\t}\n\t}`)),r(new RawFunc("__helios__list[__helios__data]__get",'(self) -> {\n\t\t(index) -> {\n\t\t\trecurse = (recurse, self, i) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("index out of range")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(index, i),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__headList__safe(self)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(self), __core__addInteger(i, 1))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, 0)\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__get_singleton`,`(self) -> {\n\t\t() -> {\n\t\t\t${TTPP}0__from_data(\n\t\t\t\t__helios__list[__helios__data]__get_singleton(self)()\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc("__helios__list[__helios__data]__get_singleton",'(self) -> {\n\t\t() -> {\n\t\t\t__core__chooseUnit(\n\t\t\t\t__helios__assert(\n\t\t\t\t\t__core__nullList(__core__tailList(self)),\n\t\t\t\t\t"not a singleton list"\n\t\t\t\t),\n\t\t\t\t__core__headList(self)\n\t\t\t)\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__set`,`(self) -> {\n\t\t(index, item) -> {\n\t\t\t__helios__list[__helios__data]__set(self)(index, ${TTPP}0____to_data(item))\n\t\t}\n\t}`)),r(new RawFunc("__helios__list[__helios__data]__set",'(self) -> {\n\t\t(index, item) -> {\n\t\t\trecurse = (recurse, lst, i) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("index out of range")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(i, index),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(item, __core__tailList__safe(lst))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t__core__headList__safe(lst),\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst), __core__addInteger(i, 1))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, 0)\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__split_at`,"__helios__list[__helios__data]__split_at")),r(new RawFunc("__helios__list[__helios__data]__split_at",'(self) -> {\n\t\t(index) -> {\n\t\t\trecurse = (recurse, lst, i, build_head) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("index out of range")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(i, index),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\tcallback(build_head(__core__mkNilData(())), lst)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst), __core__addInteger(i, 1), (h) -> {\n\t\t\t\t\t\t\t\t\tbuild_head(__core__mkCons(__core__headList__safe(lst), h))\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, 0, (head) -> {head})\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__drop`,"__helios__list[__helios__data]__drop")),r(new RawFunc("__helios__list[__helios__data]__drop",'(self) -> {\n\t\t(n) -> {\n\t\t\trecurse = (recurse, lst, n) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(n, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tlst\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse(\n\t\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t\t__core__tailList(lst),\n\t\t\t\t\t\t\t__core__subtractInteger(n, 1)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(n, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("negative n in drop")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse(recurse, self, n)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__drop_end`,"__helios__list[__helios__data]__drop_end")),r(new RawFunc("__helios__list[__helios__data]__drop_end",'(self) -> {\n\t\t(n) -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(callback) -> {callback(0, lst)}\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))(\n\t\t\t\t\t\t\t(count, result) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(count, n),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t\t\tcount,\n\t\t\t\t\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__core__headList__safe(lst),\n\t\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__addInteger(count, 1),\n\t\t\t\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(n, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("negative n in drop_end")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse(recurse, self)(\n\t\t\t\t\t\t(count, result) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(count, n),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__helios__error("list too short")\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__take`,"__helios__list[__helios__data]__take")),r(new RawFunc("__helios__list[__helios__data]__take",'(self) -> {\n\t\t(n) -> {\n\t\t\trecurse = (recurse, lst, n) -> {\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(n, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkNilData(())\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t__core__headList(lst),\n\t\t\t\t\t\t\trecurse(\n\t\t\t\t\t\t\t\trecurse,\n\t\t\t\t\t\t\t\t__core__tailList(lst),\n\t\t\t\t\t\t\t\t__core__subtractInteger(n, 1)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(n, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("negative n in take")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse(recurse, self, n)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__take_end`,"__helios__list[__helios__data]__take_end")),r(new RawFunc("__helios__list[__helios__data]__take_end",'(self) -> {\n\t\t(n) -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(callback) -> {callback(0, lst)}\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))(\n\t\t\t\t\t\t\t(count, tail) -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(count, n),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t(callback) -> {callback(count, tail)}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t\t\t__core__addInteger(count, 1),\n\t\t\t\t\t\t\t\t\t\t\t\tlst\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__lessThanInteger(n, 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("negative n in take_end")\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\trecurse(recurse, self)(\n\t\t\t\t\t\t(count, result) -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__lessThanInteger(count, n),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__helios__error("list too short")\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc(`__helios__list[${TTPP}0]__any`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__any(\n\t\t\t\tself,\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__all`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__all(\n\t\t\t\tself,\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc("__helios__list[__helios__data]__append","(self) -> {\n\t\t(item) -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkCons(item, lst)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkCons(__core__headList__safe(lst), recurse(recurse, __core__tailList__safe(lst)))\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}")),r(new RawFunc(`__helios__list[${TTPP}0]__append`,`(self) -> {\n\t\t(item) -> {\n\t\t\t__helios__list[__helios__data]__append(self)(${TTPP}0____to_data(item))\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__prepend`,`(self) -> {\n\t\t(item) -> {\n\t\t\t__core__mkCons(${TTPP}0____to_data(item), self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__find`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {__helios__error("not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titem = ${TTPP}0__from_data(__core__headList__safe(lst));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(item),\n\t\t\t\t\t\t\t() -> {item},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(lst))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__find_index`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, lst, i) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {-1},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titem = ${TTPP}0__from_data(__core__headList__safe(lst));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(item),\n\t\t\t\t\t\t\t() -> {i},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(lst), __core__addInteger(i, 1))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, 0)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__find_safe`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__find_safe(\n\t\t\t\tself,\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(item))\n\t\t\t\t},\n\t\t\t\t__helios__common__identity\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__filter`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__filter_list(\n\t\t\t\tself,\n\t\t\t\t(item) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(item))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__for_each`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t\t\tfn(${TTPP}0__from_data(__core__headList__safe(lst))),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__fold[${FTPP}0]`,`(self) -> {\n\t\t(fn, a0) -> {\n\t\t\t__helios__common__fold(\n\t\t\t\tself,\n\t\t\t\t(prev, item) -> {\n\t\t\t\t\tfn(prev, ${TTPP}0__from_data(item))\n\t\t\t\t},\n\t\t\t\ta0\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__fold2[${FTPP}0@${FTPP}1]`,`(self) -> {\n\t\t(fn, a0, b0) -> {\n\t\t\t__helios__common__fold(\n\t\t\t\tself,\n\t\t\t\t(prev, item) -> {\n\t\t\t\t\tprev(\n\t\t\t\t\t\t(a, b) -> {\n\t\t\t\t\t\t\tfn(a, b, ${TTPP}0__from_data(item))\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t(callback) -> {\n\t\t\t\t\tcallback(a0, b0)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__fold3[${FTPP}0@${FTPP}1@${FTPP}2]`,`(self) -> {\n\t\t(fn, a0, b0, c0) -> {\n\t\t\t__helios__common__fold(\n\t\t\t\tself,\n\t\t\t\t(prev, item) -> {\n\t\t\t\t\tprev(\n\t\t\t\t\t\t(a, b, c) -> {\n\t\t\t\t\t\t\tfn(a, b, c, ${TTPP}0__from_data(item))\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t(callback) -> {\n\t\t\t\t\tcallback(a0, b0, c0)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__fold_lazy[${FTPP}0]`,`(self) -> {\n\t\t(fn, a0) -> {\n\t\t\t__helios__common__fold_lazy(\n\t\t\t\tself,\n\t\t\t\t(item, next) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(item), next)\n\t\t\t\t},\n\t\t\t\ta0\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__fold2_lazy[${FTPP}0@${FTPP}1]`,`(self) -> {\n\t\t(fn, a0, b0) -> {\n\t\t\t__helios__common__fold_lazy(\n\t\t\t\tself,\n\t\t\t\t(item, next) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(item), next)\n\t\t\t\t},\n\t\t\t\t(callback) -> {\n\t\t\t\t\tcallback(a0, b0)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__map[${FTPP}0]`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__map(\n\t\t\t\tself,\n\t\t\t\t(item) -> {\n\t\t\t\t\t${FTPP}0____to_data(fn(${TTPP}0__from_data(item)))\n\t\t\t\t},\n\t\t\t\t__core__mkNilData(())\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__map_option[${FTPP}0]`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tlst\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = ${TTPP}0__from_data(__core__headList__safe(lst));\n\t\t\t\t\t\ttail = recurse(recurse, __core__tailList__safe(lst));\n\t\t\t\t\t\topt = __core__unConstrData(fn(head));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(opt), 0),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t__core__headList(__core__sndPair(opt)),\n\t\t\t\t\t\t\t\t\ttail\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\ttail\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__sort`,`(self) -> {\n\t\t(comp) -> {\n\t\t\t__helios__common__sort(\n\t\t\t\tself,\n\t\t\t\t(a, b) -> {\n\t\t\t\t\tcomp(${TTPP}0__from_data(a), ${TTPP}0__from_data(b))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__list[${TTPP}0]__sum`,`(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t0\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t${TTPP}0____add(\n\t\t\t\t\t\t\t${TTPP}0__from_data(__core__headList__safe(lst)),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc("__helios__list[__helios__string]__join",'(self) -> {\n\t\t(__useopt__separator, separator) -> {\n\t\t\tseparator = __core__ifThenElse(__useopt__separator, separator, "");\n\t\t\trecurse = (recurse, lst, sep) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t""\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\tsep,\n\t\t\t\t\t\t\t\t__helios__string__from_data(__core__headList__safe(lst))\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst), separator)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, "")\n\t\t}\n\t}')),r(new RawFunc("__helios__list[__helios__bytearray]__join","(self) -> {\n\t\t(__useopt__separator, separator) -> {\n\t\t\tseparator = __core__ifThenElse(__useopt__separator, separator, #);\n\t\t\trecurse = (recurse, lst, sep) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t#\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__bytearray____add(\n\t\t\t\t\t\t\t__helios__bytearray____add(\n\t\t\t\t\t\t\t\tsep,\n\t\t\t\t\t\t\t\t__core__unBData(__core__headList__safe(lst))\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst), separator)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, #)\n\t\t}\n\t}")),r(new RawFunc(`__helios__list[${TTPP}0]__flatten`,`(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkNilData(())\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__list[${TTPP}0]____add(\n\t\t\t\t\t\t\t__core__unListData(__core__headList__safe(lst)),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),i(`__helios__map[${TTPP}0@${TTPP}1]`),s(`__helios__map[${TTPP}0@${TTPP}1]`),a(`__helios__map[${TTPP}0@${TTPP}1]`),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__is_valid_data_internal`,`(map) -> {\n\t\trecurse = (recurse, map) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {\n\t\t\t\t\ttrue\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t${TTPP}0__is_valid_data(__core__fstPair(head)),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t${TTPP}1__is_valid_data(__core__sndPair(head)),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, map)\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__from_data`,`(data) -> {\n\t\tmap = __core__unMapData(data);\n\t\t_ = __core__ifThenElse(\n\t\t\t__helios__map[${TTPP}0@${TTPP}1]__is_valid_data_internal(map),\n\t\t\t() -> {\n\t\t\t\t()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__core__trace("Warning: invalid map data", ())\n\t\t\t}\n\t\t)();\n\t\tmap\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__from_data_safe`,"(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {\n\t\t\t\t__helios__option__SOME_FUNC(__core__unMapData__safe(data))\n\t\t\t},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t)()\n\t}")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__show`,`(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, self, first) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t""\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tfirst,\n\t\t\t\t\t\t\t\t() -> {""},\n\t\t\t\t\t\t\t\t() -> {", "}\n\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\thead = __core__headList__safe(self);\n\t\t\t\t\t\t\tkey = ${TTPP}0__from_data_safe(__core__fstPair(head));\n\t\t\t\t\t\t\tvalue = ${TTPP}1__from_data_safe(__core__sndPair(head));\n\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t\t\tkey(\n\t\t\t\t\t\t\t\t\t\t\t(valid, key) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t${TTPP}0__show(key)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t"<n/a>"\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t": "\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tvalue(\n\t\t\t\t\t\t\t\t\t\t(valid, value) -> {\n\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t${TTPP}1__show(value)()\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t"<n/a>"\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(self), false)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__appendString(\n\t\t\t\t"{",\n\t\t\t\t__core__appendString(\n\t\t\t\t\trecurse(recurse, self, true),\n\t\t\t\t\t"}"\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__is_valid_data`,`(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {false},\n\t\t\t() -> {\n\t\t\t\t__helios__map[${TTPP}0@${TTPP}1]__is_valid_data_internal(__core__unMapData__safe(data))\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]____to_data`,"__core__mapData")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]____add`,"__helios__common__concat")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__prepend`,`(self) -> {\n\t\t(key, value) -> {\n\t\t\t__core__mkCons(__core__mkPairData(${TTPP}0____to_data(key), ${TTPP}1____to_data(value)), self)\n\t\t}\n\t}`)),r(new RawFunc("__helios__map[__helios__data@__helios__data]__append","(self) -> {\n\t\t(key, value) -> {\n\t\t\t__helios__list[__helios__data]__append(self)(__core__mkPairData(key, value))\n\t\t}\n\t}")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__append`,`(self) -> {\n\t\t(key, value) -> {\n\t\t\t__helios__map[__helios__data@__helios__data]__append(self)(${TTPP}0____to_data(key), ${TTPP}1____to_data(value))\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__head`,`(self) -> {\n\t\thead = __core__headList(self);\n\t\t(callback) -> {\n\t\t\tcallback(${TTPP}0__from_data(__core__fstPair(head)), ${TTPP}1__from_data(__core__sndPair(head)))\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__head_key`,`(self) -> {\n\t\t${TTPP}0__from_data(__core__fstPair(__core__headList(self)))\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__head_value`,`(self) -> {\n\t\t${TTPP}1__from_data(__core__sndPair(__core__headList(self)))\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__length`,"(self) -> {\n\t\t__helios__common__length(self)\n\t}")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__tail`,"__core__tailList")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__is_empty`,"(self) -> {\n\t\t() -> {\n\t\t\t__core__nullList(self)\n\t\t}\n\t}")),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__get`,`(self) -> {\n\t\t(key) -> {\n\t\t\t__helios__common__map_get(\n\t\t\t\tself,\n\t\t\t\t${TTPP}0____to_data(key),\n\t\t\t\t(x) -> {${TTPP}1__from_data(x)},\n\t\t\t\t() -> {__helios__error("key not found")}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__get_safe`,`(self) -> {\n\t\t(key) -> {\n\t\t\t__helios__common__map_get(\n\t\t\t\tself,\n\t\t\t\t${TTPP}0____to_data(key),\n\t\t\t\t(x) -> {\n\t\t\t\t\t__core__constrData(0, __helios__common__list_1(x))\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__constrData(1, __helios__common__list_0)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__all`,`(self) -> {\n\t\t(fn) -> {\n\t\t\tfn = (pair) -> {\n\t\t\t\tfn(${TTPP}0__from_data(__core__fstPair(pair)), ${TTPP}1__from_data(__core__sndPair(pair)))\n\t\t\t};\n\t\t\t__helios__common__all(self, fn)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__any`,`(self) -> {\n\t\t(fn) -> {\n\t\t\tfn = (pair) -> {\n\t\t\t\tfn(${TTPP}0__from_data(__core__fstPair(pair)), ${TTPP}1__from_data(__core__sndPair(pair)))\n\t\t\t};\n\t\t\t__helios__common__any(self, fn)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__delete`,`(self) -> {\n\t\t(key) -> {\n\t\t\tkey = ${TTPP}0____to_data(key);\n\t\t\trecurse = (recurse, self) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {self},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = __core__headList__safe(self);\n\t\t\t\t\t\ttail = __core__tailList__safe(self);\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(head)),\n\t\t\t\t\t\t\t() -> {recurse(recurse, tail)},\n\t\t\t\t\t\t\t() -> {__core__mkCons(head, recurse(recurse, tail))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__filter`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__filter_map(\n\t\t\t\tself,\n\t\t\t\t(pair) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(__core__fstPair(pair)), ${TTPP}1__from_data(__core__sndPair(pair)))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__find`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, self) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {__helios__error("not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = __core__headList__safe(self);\n\t\t\t\t\t\tkey = ${TTPP}0__from_data(__core__fstPair(head));\n\t\t\t\t\t\tvalue = ${TTPP}1__from_data(__core__sndPair(head));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(key, value),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\tcallback(key, value)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(self))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__find_safe`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, self, fn) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\tcallback(() -> {__helios__error("not found")}, false)\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = __core__headList__safe(self);\n\t\t\t\t\t\tkey = ${TTPP}0__from_data(__core__fstPair(head));\n\t\t\t\t\t\tvalue = ${TTPP}1__from_data(__core__sndPair(head));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(key, value),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t(callback) -> {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(key, value)\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(self), fn)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self, fn)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__find_key`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {__helios__error("not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titem = ${TTPP}0__from_data(__core__fstPair(__core__headList__safe(map)));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(item),\n\t\t\t\t\t\t\t() -> {item},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(map))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__find_key_safe`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__find_safe(\n\t\t\t\tself,\n\t\t\t\t(pair) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(__core__fstPair(pair)))\n\t\t\t\t},\n\t\t\t\t__core__fstPair\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__find_value`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {__helios__error("not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titem = ${TTPP}1__from_data(__core__sndPair(__core__headList__safe(map)));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\tfn(item),\n\t\t\t\t\t\t\t() -> {item},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(map))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__find_value_safe`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__find_safe(\n\t\t\t\tself,\n\t\t\t\t(pair) -> {\n\t\t\t\t\tfn(${TTPP}1__from_data(__core__sndPair(pair)))\n\t\t\t\t},\n\t\t\t\t__core__sndPair\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__map[${FTPP}0@${FTPP}1]`,`(self) -> {\n\t\t(fn) -> {\n\t\t\t__helios__common__map(\n\t\t\t\tself,\n\t\t\t\t(pair) -> {\n\t\t\t\t\tmapped_pair = fn(${TTPP}0__from_data(__core__fstPair(pair)), ${TTPP}1__from_data(__core__sndPair(pair)));\n\t\t\t\t\tmapped_pair(\n\t\t\t\t\t\t(key, value) -> {\n\t\t\t\t\t\t\t__core__mkPairData(${FTPP}0____to_data(key), ${FTPP}1____to_data(value))\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t__core__mkNilPairData(())\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__fold[${FTPP}0]`,`(self) -> {\n\t\t(fn, z) -> {\n\t\t\t__helios__common__fold(self,\n\t\t\t\t(z, pair) -> {\n\t\t\t\t\tfn(z, ${TTPP}0__from_data(__core__fstPair(pair)), ${TTPP}1__from_data(__core__sndPair(pair)))\n\t\t\t\t},\n\t\t\t\tz\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__fold_lazy[${FTPP}0]`,`(self) -> {\n\t\t(fn, z) -> {\n\t\t\t__helios__common__fold_lazy(self,\n\t\t\t\t(pair, next) -> {\n\t\t\t\t\tfn(${TTPP}0__from_data(__core__fstPair(pair)), ${TTPP}1__from_data(__core__sndPair(pair)), next)\n\t\t\t\t},\n\t\t\t\tz\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__for_each`,`(self) -> {\n\t\t(fn) -> {\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t\t\tfn(${TTPP}0__from_data(__core__fstPair(head)), ${TTPP}1__from_data(__core__sndPair(head))),\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__set`,`(self) -> {\n\t\t(key, value) -> {\n\t\t\tkey = ${TTPP}0____to_data(key);\n\t\t\tvalue = ${TTPP}1____to_data(value);\n\t\t\trecurse = (recurse, self) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tself,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__mkCons(__core__mkPairData(key, value), __core__mkNilPairData(()))\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\thead = __core__headList__safe(self);\n\t\t\t\t\t\ttail = __core__tailList__safe(self);\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(head)),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(__core__mkPairData(key, value), tail)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(head, recurse(recurse, tail))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__to_iterator`,`(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t(callback) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tmap,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tcallback(true, (), (), ())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t${TTPP}0__from_data(__core__fstPair(head)),\n\t\t\t\t\t\t\t\t${TTPP}1__from_data(__core__sndPair(head)),\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__from_iterator`,`(iterator) -> {\n\t\trecurse = (recurse, iterator) -> {\n\t\t\titerator(\n\t\t\t\t(is_null, head0, head1, next_iterator) -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\tis_null,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__mkNilPairData(())\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t__core__mkPairData(${TTPP}0____to_data(head0), ${TTPP}1____to_data(head1)),\n\t\t\t\t\t\t\t\trecurse(recurse, next_iterator)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t};\n\t\trecurse(recurse, iterator)\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__update`,`(self) -> {\n\t\t(key, fn) -> {\n\t\t\tkey = ${TTPP}0____to_data(key);\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error("key not found")\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tpair = __core__headList__safe(map);\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(key, __core__fstPair(pair)),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t${TTPP}1____to_data(fn(${TTPP}1__from_data(__core__sndPair(pair))))\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t__core__tailList(map)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__mkCons(pair, recurse(recurse, __core__tailList__safe(map)))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__update_safe`,`(self) -> {\n\t\t(key, fn) -> {\n\t\t\tkey = ${TTPP}0____to_data(key);\n\t\t\t__helios__common__map(\n\t\t\t\tself,\n\t\t\t\t(pair) -> {\n\t\t\t\t\toldKey = __core__fstPair(pair);\n\t\t\t\t\toldValue = __core__sndPair(pair);\n\t\t\t\t\tnewValue = __core__ifThenElse(\n\t\t\t\t\t\t__core__equalsData(oldKey, key),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t${TTPP}1____to_data(fn(${TTPP}1__from_data(oldValue)))\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\toldValue\n\t\t\t\t\t\t}\n\t\t\t\t\t)();\n\t\t\t\t\t__core__mkPairData(oldKey, newValue)\n\t\t\t\t},\n\t\t\t\t__core__mkNilPairData(())\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__map[${TTPP}0@${TTPP}1]__sort`,`(self) -> {\n\t\t(comp) -> {\n\t\t\t__helios__common__sort(\n\t\t\t\tself,\n\t\t\t\t(a, b) -> {\n\t\t\t\t\tcomp(\n\t\t\t\t\t\t${TTPP}0__from_data(__core__fstPair(a)),\n\t\t\t\t\t\t${TTPP}1__from_data(__core__sndPair(a)),\n\t\t\t\t\t\t${TTPP}0__from_data(__core__fstPair(b)),\n\t\t\t\t\t\t${TTPP}1__from_data(__core__sndPair(b))\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc(`__helios__option[${TTPP}0]__is_valid_data`,`(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\tpair = __core__unConstrData__safe(data);\n\t\t\t\tindex = __core__fstPair(pair);\n\t\t\t\tfields = __core__sndPair(pair);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(index, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t__core__tailList__safe(fields),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t${TTPP}0__is_valid_data(__core__headList__safe(fields))\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(index, 1),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}`)),l(`__helios__option[${TTPP}0]`,{from_data:`(data) -> {\n\t\t\t_ = __core__ifThenElse(\n\t\t\t\t__helios__option[${TTPP}0]__is_valid_data(data),\n\t\t\t\t() -> {\n\t\t\t\t\t()\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__trace("Warning: invalid option data", ())\n\t\t\t\t}\n\t\t\t)();\n\t\t\tdata\n\t\t}`,from_data_safe:"(data) -> {\n\t\t\t__core__chooseData(\n\t\t\t\tdata,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__option__SOME_FUNC(data)\n\t\t\t\t},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t\t)()\n\t\t}"}),r(new RawFunc(`__helios__option[${TTPP}0]__map[${FTPP}0]`,`(self) -> {\n\t\t(fn) -> {\n\t\t\tpair = __core__unConstrData(self);\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 0),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__option[${FTPP}0]__some__new(\n\t\t\t\t\t\tfn(\n\t\t\t\t\t\t\t${TTPP}0__from_data(\n\t\t\t\t\t\t\t\t__core__headList(__core__sndPair(pair))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__option[${FTPP}0]__none__new()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc(`__helios__option[${TTPP}0]__unwrap`,`(self) -> {\n\t\t() -> {\n\t\t\t${TTPP}0__from_data(__helios__common__enum_field_0(self))\n\t\t}\n\t}`)),r(new RawFunc(`__helios__option[${TTPP}0]__show`,`(self) -> {\n\t\t__core__chooseData(\n\t\t\tself,\n\t\t\t() -> {\n\t\t\t\tpair = __core__unConstrData__safe(self);\n\t\t\t\tindex = __core__fstPair(pair);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(index, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tfields = __core__sndPair(pair);\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t"Option::Some{<n/a>}"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tsome = ${TTPP}0__from_data_safe(__core__headList__safe(fields));\n\t\t\t\t\t\t\t\tsome(\n\t\t\t\t\t\t\t\t\t(valid, value) -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\tvalid,\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t"Option::Some{",\n\t\t\t\t\t\t\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t${TTPP}0__show(value)(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t"}"\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t"Option::Some{<n/a>}"\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t"Option::None"\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {"Option{<n/a>}"},\n\t\t\t() -> {"Option{<n/a>}"},\n\t\t\t() -> {"Option{<n/a>}"},\n\t\t\t() -> {"Option{<n/a>}"}\n\t\t)\n\t}`)),u(`__helios__option[${TTPP}0]__some`,0),r(new RawFunc("__helios__option__SOME_FUNC","(some) -> {\n\t\t(callback) -> {callback(true, some)}\n\t}")),r(new RawFunc(`__helios__option[${TTPP}0]__some____new`,`(some) -> {\n\t\t__core__constrData(0, __helios__common__list_1(${TTPP}0____to_data(some)))\n\t}`)),r(new RawFunc(`__helios__option[${TTPP}0]__some__new`,`__helios__option[${TTPP}0]__some____new`)),r(new RawFunc(`__helios__option[${TTPP}0]__some__cast`,"(data) -> {\n\t\t__helios__common__assert_constr_index(data, 0)\n\t}")),r(new RawFunc(`__helios__option[${TTPP}0]__some__some`,`(self) -> {\n\t\t${TTPP}0__from_data(__helios__common__enum_field_0(self))\n\t}`)),r(new RawFunc("__helios__option__is_some","(data) -> {\n\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(data)), 0)\n\t}")),u(`__helios__option[${TTPP}0]__none`,1),r(new RawFunc("__helios__option__NONE","__core__constrData(1, __helios__common__list_0)")),r(new RawFunc("__helios__option__NONE_FUNC","(callback) -> {callback(false, ())}")),r(new RawFunc(`__helios__option[${TTPP}0]__none____new`,"() -> {\n\t\t__helios__option__NONE\n\t}")),r(new RawFunc(`__helios__option[${TTPP}0]__none__new`,`__helios__option[${TTPP}0]__none____new`)),r(new RawFunc(`__helios__option[${TTPP}0]__none__cast`,"(data) -> {\n\t\t__helios__common__assert_constr_index(data, 1)\n\t}")),_("__helios__scripthash"),r(new RawFunc("__helios__scripthash__is_valid_data","(data) -> {__helios__bytearray__is_valid_data_fixed_length(data, 28)}"));for(let t of["pubkeyhash","validatorhash","mintingpolicyhash","stakingvalidatorhash","datumhash"])_(`__helios__${t}`),r(new RawFunc(`__helios__${t}__is_valid_data`,`(data) -> {\n\t\t\t__helios__bytearray__is_valid_data_fixed_length(data, ${"datumhash"==t?32:28})\n\t\t}`)),r(new RawFunc(`__helios__${t}__from_script_hash`,"__helios__common__identity"));return _("__helios__pubkey"),r(new RawFunc("__helios__pubkey__is_valid_data","(data) -> {__helios__bytearray__is_valid_data_fixed_length(data, 32)}")),r(new RawFunc("__helios__pubkey__verify","(self) -> {\n\t\t(message, signature) -> {\n\t\t\t__core__verifyEd25519Signature(self, message, signature)\n\t\t}\n\t}")),l("__helios__scriptcontext"),r(new RawFunc("__helios__scriptcontext__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__scriptcontext__new_spending","(tx, output_id) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(1, __helios__common__list_1(output_id))\n\t\t))\n\t}")),r(new RawFunc("__helios__scriptcontext__new_minting","(tx, mph) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(\n\t\t\t\t0,\n\t\t\t\t__helios__common__list_1(\n\t\t\t\t\t__helios__mintingpolicyhash____to_data(mph)\n\t\t\t\t)\n\t\t\t)\n\t\t))\n\t}")),r(new RawFunc("__helios__scriptcontext__new_rewarding","(tx, cred) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(2, __helios__common__list_1(cred))\n\t\t))\n\t}")),r(new RawFunc("__helios__scriptcontext__new_certifying","(tx, dcert) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\ttx,\n\t\t\t__core__constrData(3, __helios__common__list_1(dcert))\n\t\t))\n\t}")),r(new RawFunc("__helios__scriptcontext__tx","__helios__common__enum_field_0")),r(new RawFunc("__helios__scriptcontext__purpose","__helios__common__enum_field_1")),r(new RawFunc("__helios__scriptcontext__get_current_input",'(self) -> {\n\t\t() -> {\n\t\t\tid = __helios__scriptcontext__get_spending_purpose_output_id(self)();\n\t\t\trecurse = (recurse, lst) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tlst,\n\t\t\t\t\t() -> {__helios__error("not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\titem = __core__headList__safe(lst);\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__helios__txinput__output_id(item), id),\n\t\t\t\t\t\t\t() -> {item},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(lst))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, __helios__tx__inputs(__helios__scriptcontext__tx(self)))\n\t\t}\n\t}')),r(new RawFunc("__helios__scriptcontext__get_cont_outputs","(self) -> {\n\t\t() -> {\n\t\t\tvh = __helios__scriptcontext__get_current_validator_hash(self)();\n\t\t\toutputs = __helios__tx__outputs(__helios__scriptcontext__tx(self));\n\t\t\t__helios__common__filter_list(\n\t\t\t\toutputs,\n\t\t\t\t(output) -> {\n\t\t\t\t\tcredential = __helios__address__credential(__helios__txoutput__address(output));\n\t\t\t\t\tpair = __core__unConstrData(credential);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__equalsByteString(__core__unBData(__core__headList(__core__sndPair(pair))), vh)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__scriptcontext__get_spending_purpose_output_id","(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__enum_field_0(__helios__common__enum_field_1(self))\n\t\t}\n\t}")),r(new RawFunc("__helios__scriptcontext__get_current_validator_hash","(self) -> {\n\t\t() -> {\n\t\t\t__helios__credential__validator__hash(\n\t\t\t\t__helios__credential__validator__cast(\n\t\t\t\t\t__helios__address__credential(\n\t\t\t\t\t\t__helios__txoutput__address(\n\t\t\t\t\t\t\t__helios__txinput__output(\n\t\t\t\t\t\t\t\t__helios__scriptcontext__get_current_input(self)()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__scriptcontext__get_current_minting_policy_hash","(self) -> {\n\t\t() -> {\n\t\t\t__helios__mintingpolicyhash__from_data(__helios__scriptcontext__get_spending_purpose_output_id(self)())\n\t\t}\n\t}")),r(new RawFunc("__helios__scriptcontext__get_staking_purpose","(self) -> {\n\t\t() -> {\n\t\t\t__helios__scriptcontext__purpose(self)\n\t\t}\n\t}")),r(new RawFunc("__helios__scriptcontext__get_script_purpose","(self) -> {\n\t\t() -> {\n\t\t\t__helios__scriptcontext__purpose(self)\n\t\t}\n\t}")),l("__helios__contractcontext"),r(new RawFunc("__helios__contractcontext__now","(self) -> {\n\t\t() -> {\n\t\t\t__core__macro__now(())\n\t\t}\n\t}")),r(new RawFunc("__helios__contractcontext__agent","(self) -> {self}")),r(new RawFunc("__helios__contractcontext__network","(self) -> {()}")),r(new RawFunc("__helios__contractcontext__new_tx_builder","(self) -> {__helios__txbuilder__new_empty}")),r(new RawFunc("__helios__network__pick","(self) -> {\n\t\t(address, value) -> {\n\t\t\t__core__macro__pick(__helios__address____to_data(address), __helios__value____to_data(value), ())\n\t\t}\n\t}")),r(new RawFunc("__helios__network__get","(self) -> {\n\t\t(id) -> {\n\t\t\t__core__macro__get_utxo(__helios__txoutputid____to_data(id), ())\n\t\t}\n\t}")),r(new RawFunc("__helios__network__utxos_at","(self) -> {\n\t\t(addr) -> {\n\t\t\t__helios__list[__helios__data]__to_iterator(\n\t\t\t\t__core__macro__utxos_at(__helios__address____to_data(addr), ())\n\t\t\t)()\n\t\t}\n\t}")),l("__helios__wallet"),r(new RawFunc("__helios__wallet__address","(self) -> {__helios__common__enum_field_1(self)}")),r(new RawFunc("__helios__wallet__hash","(self) -> {\n\t\t__helios__credential__pubkey__hash(\n\t\t\t__helios__credential__pubkey__cast(\n\t\t\t\t__helios__address__credential(\n\t\t\t\t\t__helios__common__enum_field_0(self)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t}")),r(new RawFunc("__helios__wallet__pick","(self) -> {\n\t\t(value) -> {\n\t\t\t__core__macro__pick(__helios__common__enum_field_0(self), __helios__value____to_data(value), ())\n\t\t}\n\t}")),l("__helios__stakingpurpose"),r(new RawFunc("__helios__stakingpurpose__testdata","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),u("__helios__stakingpurpose__rewarding",2),r(new RawFunc("__helios__stakingpurpose__rewarding__credential","__helios__common__enum_field_0")),u("__helios__stakingpurpose__certifying",3),r(new RawFunc("__helios__stakingpurpose__certifying__dcert","__helios__common__enum_field_0")),l("__helios__scriptpurpose"),r(new RawFunc("__helios__scriptpurpose__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__scriptpurpose__new_minting","(mph) -> {\n\t\t__core__constrData(0, __helios__common__list_1(__helios__mintingpolicyhash____to_data(mph)))\n\t}")),r(new RawFunc("__helios__scriptpurpose__new_spending","(output_id) -> {\n\t\t__core__constrData(1, __helios__common__list_1(output_id))\n\t}")),r(new RawFunc("__helios__scriptpurpose__new_rewarding","(cred) -> {\n\t\t__core__constrData(2, __helios__common__list_1(cred))\n\t}")),r(new RawFunc("__helios__scriptpurpose__new_certifying","(action) -> {\n\t\t__core__constrData(3, __helios__common__list_1(action))\n\t}")),u("__helios__scriptpurpose__minting",0),r(new RawFunc("__helios__scriptpurpose__minting__policy_hash","(self) -> {\n\t\t__helios__mintingpolicyhash__from_data(__helios__common__enum_field_0(self))\n\t}")),u("__helios__scriptpurpose__spending",1),r(new RawFunc("__helios__scriptpurpose__spending__output_id","__helios__common__enum_field_0")),u("__helios__scriptpurpose__rewarding",2),r(new RawFunc("__helios__scriptpurpose__rewarding__credential","__helios__common__enum_field_0")),u("__helios__scriptpurpose__certifying",3),r(new RawFunc("__helios__scriptpurpose__certifying__dcert","__helios__common__enum_field_0")),l("__helios__dcert"),r(new RawFunc("__helios__dcert__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__dcert__new_register","(cred) -> {\n\t\t__core__constrData(0, __helios__common__list_1(cred))\n\t}")),r(new RawFunc("__helios__dcert__new_deregister","(cred) -> {\n\t\t__core__constrData(1, __helios__common__list_1(cred))\n\t}")),r(new RawFunc("__helios__dcert__new_delegate","(cred, pool_id) -> {\n\t\t__core__constrData(2, __helios__common__list_2(cred, __helios__pubkeyhash____to_data(pool_id)))\n\t}")),r(new RawFunc("__helios__dcert__new_register_pool","(id, vrf) -> {\n\t\t__core__constrData(3, __helios__common__list_2(__helios__pubkeyhash____to_data(id), __helios__pubkeyhash____to_data(vrf)))\n\t}")),r(new RawFunc("__helios__dcert__new_retire_pool","(id, epoch) -> {\n\t\t__core__constrData(4, __helios__common__list_2(__helios__pubkeyhash____to_data(id), __helios__int____to_data(epoch)))\n\t}")),u("__helios__dcert__register",0),r(new RawFunc("__helios__dcert__register__credential","__helios__common__enum_field_0")),u("__helios__dcert__deregister",1),r(new RawFunc("__helios__dcert__deregister__credential","__helios__common__enum_field_0")),u("__helios__dcert__delegate",2),r(new RawFunc("__helios__dcert__delegate__delegator","__helios__common__enum_field_0")),r(new RawFunc("__helios__dcert__delegate__pool_id","(self) -> {\n\t\t__helios__pubkeyhash__from_data(__helios__common__enum_field_1(self))\n\t}")),u("__helios__dcert__registerpool",3),r(new RawFunc("__helios__dcert__registerpool__pool_id","(self) -> {\n\t\t__helios__pubkeyhash__from_data(__helios__common__enum_field_0(self))\n\t}")),r(new RawFunc("__helios__dcert__registerpool__pool_vrf","(self) -> {\n\t\t__helios__pubkeyhash__from_data(__helios__common__enum_field_1(self))\n\t}")),u("__helios__dcert__retirepool",4),r(new RawFunc("__helios__dcert__retirepool__pool_id","(self) -> {\n\t\t__helios__pubkeyhash__from_data(__helios__common__enum_field_0(self))\n\t}")),r(new RawFunc("__helios__dcert__retirepool__epoch","(self) -> {\n\t\t__helios__int__from_data(__helios__common__enum_field_1(self))\n\t}")),l("__helios__txbuilder"),r(new RawFunc("__helios__txbuilder__new","(inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t__core__constrData(0, __helios__common__list_12(\n\t\t\t__core__listData(inputs),\n\t\t\t__core__listData(ref_inputs),\n\t\t\t__core__listData(outputs),\n\t\t\t__core__mapData(fee),\n\t\t\t__core__mapData(minted),\n\t\t\t__core__listData(dcerts),\n\t\t\t__core__mapData(withdrawals),\n\t\t\t__helios__timerange____to_data(validity),\n\t\t\t__core__listData(signatories),\n\t\t\t__core__mapData(redeemers),\n\t\t\t__core__mapData(datums),\n\t\t\t__helios__txid__new(#00010203040506070809101112131415161718192021222324252627)\n\t\t))\n\t}")),r(new RawFunc("__helios__txbuilder__new_empty","() -> {\n\t\t__helios__txbuilder__new(\n\t\t\t__core__mkNilData(()),\n\t\t\t__core__mkNilData(()),\n\t\t\t__core__mkNilData(()),\n\t\t\t__core__mkNilPairData(()),\n\t\t\t__core__mkNilPairData(()),\n\t\t\t__core__mkNilData(()),\n\t\t\t__core__mkNilPairData(()),\n\t\t\t__helios__timerange__ALWAYS,\n\t\t\t__core__mkNilData(()),\n\t\t\t__core__mkNilPairData(()),\n\t\t\t__core__mkNilPairData(())\n\t\t)\n\t}")),r(new RawFunc("__helios__txbuilder__unwrap","(self, callback) -> {\n\t\tfields = __core__sndPair(__core__unConstrData(self));\n\t\tinputs = __core__unListData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tref_inputs = __core__unListData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\toutputs = __core__unListData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tfee = __core__unMapData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tminted = __core__unMapData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tdcerts = __core__unListData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\twithdrawals = __core__unMapData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tvalidity = __helios__timerange__from_data(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tsignatories = __core__unListData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tredeemers = __core__unMapData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tdatums = __core__unMapData(__core__headList(fields));\n\t\tfields = __core__tailList(fields);\n\t\tcallback(inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums)\n\t}")),r(new RawFunc("__helios__txbuilder__spend","(self) -> {\n\t\t(input) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\t__helios__list[__helios__data]__append(inputs)(__helios__txinput____to_data(input)),\n\t\t\t\t\tref_inputs,\n\t\t\t\t\toutputs,\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc("__helios__txbuilder__spend_many","(self) -> {\n\t\t(extra_inputs) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\t__helios__common__concat(inputs, extra_inputs),\n\t\t\t\t\tref_inputs,\n\t\t\t\t\toutputs,\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc(`__helios__txbuilder__redeem[${FTPP}0]`,`(self) -> {\n\t\t(input, redeemer) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\t__helios__list[__helios__data]__append(inputs)(\n\t\t\t\t\t\t__helios__txinput____to_data(input)\n\t\t\t\t\t),\n\t\t\t\t\tref_inputs,\n\t\t\t\t\toutputs,\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\t__helios__map[__helios__data@__helios__data]__append(redeemers)(\n\t\t\t\t\t\t__helios__scriptpurpose__new_spending(__helios__txinput__output_id(input)),\n\t\t\t\t\t\t${FTPP}0____to_data(redeemer)\n\t\t\t\t\t),\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}`)),r(new RawFunc(`__helios__txbuilder__redeem_many[${FTPP}0]`,`(self) -> {\n\t\t(inputs, redeemer) -> {\n\t\t\trecurse = (recurse, inputs) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tinputs,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tself\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txbuilder__redeem[${FTPP}0](\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(inputs))\n\t\t\t\t\t\t)(\n\t\t\t\t\t\t\t__core__headList__safe(inputs),\n\t\t\t\t\t\t\tredeemer\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, inputs)\n\t\t}\n\t}`)),r(new RawFunc("__helios__txbuilder__add_output","(self) -> {\n\t\t(output) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\tinputs,\n\t\t\t\t\tref_inputs,\n\t\t\t\t\t__helios__list[__helios__data]__append(outputs)(\n\t\t\t\t\t\t__helios__txoutput____to_data(output)\n\t\t\t\t\t),\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc("__helios__txbuilder__add_outputs","(self) -> {\n\t\t(extra_outputs) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\tinputs,\n\t\t\t\t\tref_inputs,\n\t\t\t\t\t__helios__common__concat(outputs, extra_outputs),\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc(`__helios__txbuilder__pay[${FTPP}0]`,`(self) -> {\n\t\t(address, value, datum) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\tinputs,\n\t\t\t\t\tref_inputs,\n\t\t\t\t\t__helios__list[__helios__data]__append(outputs)(\n\t\t\t\t\t\t__helios__txoutput____to_data(\n\t\t\t\t\t\t\t__helios__txoutput__new(\n\t\t\t\t\t\t\t\taddress,\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t__helios__outputdatum__new_inline[__helios__data](\n\t\t\t\t\t\t\t\t\t${FTPP}0____to_data(datum)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}`)),r(new RawFunc(`__helios__txbuilder__pay_if_true[${FTPP}0]`,`(self) -> {\n\t\t(cond, address, value, datum) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tcond,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\t\t\tinputs,\n\t\t\t\t\t\t\tref_inputs,\n\t\t\t\t\t\t\t__helios__list[__helios__data]__append(outputs)(\n\t\t\t\t\t\t\t\t__helios__txoutput____to_data(\n\t\t\t\t\t\t\t\t\t__helios__txoutput__new(\n\t\t\t\t\t\t\t\t\t\taddress,\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t\t__helios__outputdatum__new_inline[__helios__data](\n\t\t\t\t\t\t\t\t\t\t\t${FTPP}0____to_data(datum)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfee,\n\t\t\t\t\t\t\tminted,\n\t\t\t\t\t\t\tdcerts,\n\t\t\t\t\t\t\twithdrawals,\n\t\t\t\t\t\t\tvalidity,\n\t\t\t\t\t\t\tsignatories,\n\t\t\t\t\t\t\tredeemers,\n\t\t\t\t\t\t\tdatums\n\t\t\t\t\t\t)\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tself\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc(`__helios__txbuilder__mint[${FTPP}0]`,`(self) -> {\n\t\t(value, redeemer) -> {\n\t\t\t__core__chooseUnit(\n\t\t\t\t__helios__assert(\n\t\t\t\t\t__core__equalsInteger(__helios__common__length(value), 1),\n\t\t\t\t\t__helios__string____add("expected a single mph in mint value, got ", __helios__int__show(__helios__common__length(value))())\n\t\t\t\t),\n\t\t\t\tmph = __helios__mintingpolicyhash__from_data(__core__fstPair(__core__headList(value)));\n\t\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t\t__core__chooseUnit(\n\t\t\t\t\t\t__helios__assert(\n\t\t\t\t\t\t\t__helios__bool____not(\n\t\t\t\t\t\t\t\t__helios__value__contains_policy(minted)(mph)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t"already minted before"\n\t\t\t\t\t\t),\n\t\t\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\t\t\tinputs,\n\t\t\t\t\t\t\tref_inputs,\n\t\t\t\t\t\t\toutputs,\n\t\t\t\t\t\t\tfee,\n\t\t\t\t\t\t\t__helios__value____add(minted, value),\n\t\t\t\t\t\t\tdcerts,\n\t\t\t\t\t\t\twithdrawals,\n\t\t\t\t\t\t\tvalidity,\n\t\t\t\t\t\t\tsignatories,\n\t\t\t\t\t\t\t__helios__map[__helios__data@__helios__data]__append(redeemers)(\n\t\t\t\t\t\t\t\t__helios__scriptpurpose__new_minting(mph),\n\t\t\t\t\t\t\t\t${FTPP}0____to_data(redeemer)\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tdatums\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc("__helios__txbuilder__add_ref_input","(self) -> {\n\t\t(ref_input) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\tinputs,\n\t\t\t\t\t__helios__list[__helios__data]__append(ref_inputs)(__helios__txinput____to_data(ref_input)),\n\t\t\t\t\toutputs,\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tsignatories,\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc("__helios__txbuilder__add_signer","(self) -> {\n\t\t(pk) -> {\n\t\t\t__helios__txbuilder__unwrap(self, (inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums) -> {\n\t\t\t\t__helios__txbuilder__new(\n\t\t\t\t\tinputs,\n\t\t\t\t\tref_inputs,\n\t\t\t\t\toutputs,\n\t\t\t\t\tfee,\n\t\t\t\t\tminted,\n\t\t\t\t\tdcerts,\n\t\t\t\t\twithdrawals,\n\t\t\t\t\tvalidity,\n\t\t\t\t\t__helios__list[__helios__data]__append(signatories)(__helios__pubkeyhash____to_data(pk)),\n\t\t\t\t\tredeemers,\n\t\t\t\t\tdatums\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc("__helios__txbuilder__finalize","(self) -> {\n\t\t() -> {\n\t\t\t__core__macro__finalize(self, ())\n\t\t}\n\t}")),l("__helios__tx"),r(new RawFunc("__helios__tx__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc(`__helios__tx__new[${FTPP}0@${FTPP}1]`,"(inputs, ref_inputs, outputs, fee, minted, dcerts, withdrawals, validity, signatories, redeemers, datums, txId) -> {\n\t\t__core__constrData(0, __helios__common__list_12(\n\t\t\t__core__listData(inputs),\n\t\t\t__core__listData(ref_inputs),\n\t\t\t__core__listData(outputs),\n\t\t\t__core__mapData(fee),\n\t\t\t__core__mapData(minted),\n\t\t\t__core__listData(dcerts),\n\t\t\t__core__mapData(withdrawals),\n\t\t\t__helios__timerange____to_data(validity),\n\t\t\t__core__listData(signatories),\n\t\t\t__core__mapData(redeemers),\n\t\t\t__core__mapData(datums),\n\t\t\t__helios__txid____to_data(txId)\n\t\t))\n\t}")),r(new RawFunc("__helios__tx__inputs","(self) -> {\n\t\t__core__unListData(__helios__common__enum_field_0(self))\n\t}")),r(new RawFunc("__helios__tx__ref_inputs","(self) -> {\n\t\t__core__unListData(__helios__common__enum_field_1(self))\n\t}")),r(new RawFunc("__helios__tx__outputs","(self) -> {\n\t\t__core__unListData(__helios__common__enum_field_2(self))\n\t}")),r(new RawFunc("__helios__tx__fee","(self) -> {\n\t\t__core__unMapData(__helios__common__enum_field_3(self))\n\t}")),r(new RawFunc("__helios__tx__minted","(self) -> {\n\t\t__core__unMapData(__helios__common__enum_field_4(self))\n\t}")),r(new RawFunc("__helios__tx__dcerts","(self) -> {\n\t\t__core__unListData(__helios__common__enum_field_5(self))\n\t}")),r(new RawFunc("__helios__tx__withdrawals","(self) -> {\n\t\t__core__unMapData(__helios__common__enum_field_6(self))\n\t}")),r(new RawFunc("__helios__tx__time_range","__helios__common__enum_field_7")),r(new RawFunc("__helios__tx__signatories","(self) -> {\n\t\t__core__unListData(__helios__common__enum_field_8(self))\n\t}")),r(new RawFunc("__helios__tx__redeemers","(self) -> {\n\t\t__core__unMapData(__helios__common__enum_field_9(self))\n\t}")),r(new RawFunc("__helios__tx__datums","(self) -> {\n\t\t__core__unMapData(__helios__common__enum_field_10(self))\n\t}")),r(new RawFunc("__helios__tx__id","__helios__common__enum_field_11")),r(new RawFunc(`__helios__tx__find_datum_hash[${FTPP}0]`,"(self) -> {\n\t\t(datum) -> {\n\t\t\t__helios__datumhash__from_data(\n\t\t\t\t__core__fstPair(\n\t\t\t\t\t__helios__common__find(\n\t\t\t\t\t\t__helios__tx__datums(self),\n\t\t\t\t\t\t(pair) -> {\n\t\t\t\t\t\t\t__core__equalsData(__core__sndPair(pair), datum)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__tx__get_datum_data",'(self) -> {\n\t\t(output) -> {\n\t\t\toutput = __core__unConstrData(__helios__txoutput__datum(output));\n\t\t\tidx = __core__fstPair(output);\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(idx, 1),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__common__map_get(\n\t\t\t\t\t\t__helios__tx__datums(self),\n\t\t\t\t\t\t__core__headList(__core__sndPair(output)),\n\t\t\t\t\t\t__helios__common__identity,\n\t\t\t\t\t\t() -> {__helios__error("datumhash not found")}\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(idx, 2),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__headList(__core__sndPair(output))\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {__helios__error("output doesn\'t have a datum")}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),r(new RawFunc("__helios__tx__filter_outputs","(self, fn) -> {\n\t\t__helios__common__filter_list(\n\t\t\t__helios__tx__outputs(self),\n\t\t\tfn\n\t\t)\n\t}")),r(new RawFunc("__helios__tx__outputs_sent_to","(self) -> {\n\t\t(pkh) -> {\n\t\t\t__helios__tx__filter_outputs(self, (output) -> {\n\t\t\t\t__helios__txoutput__is_sent_to(output)(pkh)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc(`__helios__tx__outputs_sent_to_datum[${FTPP}0]`,`(self) -> {\n\t\t(pkh, datum, isInline) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tisInline,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_sent_to_inline_datum[${FTPP}0](self, pkh, datum)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_sent_to_datum_hash[${FTPP}0](self, pkh, datum)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc(`__helios__tx__outputs_sent_to_datum_hash[${FTPP}0]`,`(self, pkh, datum) -> {\n\t\tdatumHash = __helios__common__hash_datum_data[${FTPP}0](datum);\n\t\t__helios__tx__filter_outputs(\n\t\t\tself,\n\t\t\t(output) -> {\n\t\t\t\t__helios__bool__and(\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__is_sent_to(output)(pkh)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__has_datum_hash(output, datumHash)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`)),r(new RawFunc(`__helios__tx__outputs_sent_to_inline_datum[${FTPP}0]`,`(self, pkh, datum) -> {\n\t\t__helios__tx__filter_outputs(\n\t\t\tself,\n\t\t\t(output) -> {\n\t\t\t\t__helios__bool__and(\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__is_sent_to(output)(pkh)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__has_inline_datum[${FTPP}0](output, datum)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`)),r(new RawFunc("__helios__tx__outputs_locked_by","(self) -> {\n\t\t(vh) -> {\n\t\t\t__helios__tx__filter_outputs(self, (output) -> {\n\t\t\t\t__helios__txoutput__is_locked_by(output)(vh)\n\t\t\t})\n\t\t}\n\t}")),r(new RawFunc(`__helios__tx__outputs_locked_by_datum[${FTPP}0]`,`(self) -> {\n\t\t(vh, datum, isInline) -> {\n\t\t\t__core__ifThenElse(\n\t\t\t\tisInline,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_locked_by_inline_datum[${FTPP}0](self, vh, datum)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__tx__outputs_locked_by_datum_hash[${FTPP}0](self, vh, datum)\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc(`__helios__tx__outputs_locked_by_datum_hash[${FTPP}0]`,`(self, vh, datum) -> {\n\t\tdatumHash = __helios__common__hash_datum_data[${FTPP}0](datum);\n\t\t__helios__tx__filter_outputs(\n\t\t\tself,\n\t\t\t(output) -> {\n\t\t\t\t__helios__bool__and(\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__is_locked_by(output)(vh)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__has_datum_hash(output, datumHash)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`)),r(new RawFunc(`__helios__tx__outputs_locked_by_inline_datum[${FTPP}0]`,`(self, vh, datum) -> {\n\t\t__helios__tx__filter_outputs(\n\t\t\tself,\n\t\t\t(output) -> {\n\t\t\t\t__helios__bool__and(\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__is_locked_by(output)(vh)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__txoutput__has_inline_datum[${FTPP}0](output, datum)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}`)),r(new RawFunc(`__helios__tx__outputs_paid_to[${FTPP}0]`,`(self) -> {\n\t\t(addr, datum) -> {\n\t\t\t__helios__tx__filter_outputs(\n\t\t\t\tself,\n\t\t\t\t(output) -> {\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__address____eq(__helios__txoutput__address(output), addr)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__helios__txoutput__has_inline_datum[${FTPP}0](output, datum)\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}`)),r(new RawFunc("__helios__tx__value_sent_to","(self) -> {\n\t\t(pkh) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_sent_to(self)(pkh))\n\t\t}\n\t}")),r(new RawFunc(`__helios__tx__value_sent_to_datum[${FTPP}0]`,`(self) -> {\n\t\t(pkh, datum, isInline) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_sent_to_datum[${FTPP}0](self)(pkh, datum, isInline))\n\t\t}\n\t}`)),r(new RawFunc("__helios__tx__value_locked_by","(self) -> {\n\t\t(vh) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_locked_by(self)(vh))\n\t\t}\n\t}")),r(new RawFunc(`__helios__tx__value_locked_by_datum[${FTPP}0]`,`(self) -> {\n\t\t(vh, datum, isInline) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_locked_by_datum[${FTPP}0](self)(vh, datum, isInline))\n\t\t}\n\t}`)),r(new RawFunc(`__helios__tx__value_paid_to[${FTPP}0]`,`(self) -> {\n\t\t(addr, datum) -> {\n\t\t\t__helios__txoutput__sum_values(__helios__tx__outputs_paid_to[${FTPP}0](self)(addr, datum))\n\t\t}\n\t}`)),r(new RawFunc("__helios__tx__is_signed_by","(self) -> {\n\t\t(hash) -> {\n\t\t\thash = __helios__pubkeyhash____to_data(hash);\n\t\t\t__helios__common__any(\n\t\t\t\t__helios__tx__signatories(self),\n\t\t\t\t(signatory) -> {\n\t\t\t\t\t__core__equalsData(signatory, hash)\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}")),l("__helios__txid"),r(new RawFunc("__helios__txid__bytes","(self) -> {\n\t\t__core__unBData(__core__headList(__core__sndPair(__core__unConstrData(self))))\n\t}")),r(new RawFunc("__helios__txid____lt","(a, b) -> {\n\t\t__helios__bytearray____lt(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}")),r(new RawFunc("__helios__txid____leq","(a, b) -> {\n\t\t__helios__bytearray____leq(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}")),r(new RawFunc("__helios__txid____gt","(a, b) -> {\n\t\t__helios__bytearray____gt(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}")),r(new RawFunc("__helios__txid____geq","(a, b) -> {\n\t\t__helios__bytearray____geq(__helios__txid__bytes(a), __helios__txid__bytes(b))\n\t}")),r(new RawFunc("__helios__txid__new","(bytes) -> {\n\t\t__core__constrData(0, __helios__common__list_1(__core__bData(bytes)))\n\t}")),r(new RawFunc("__helios__txid__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\tpair = __core__unConstrData__safe(data);\n\t\t\t\tindex = __core__fstPair(pair);\n\t\t\t\tfields = __core__sndPair(pair);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(0, index),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t__core__tailList__safe(fields),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__bytearray__is_valid_data_fixed_length(__core__headList__safe(fields), 32)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tfalse\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__txid__show","(self) -> {\n\t\t__helios__bytearray__show(__helios__txid__bytes(self))\n\t}")),l("__helios__txinput"),r(new RawFunc("__helios__txinput__is_valid_data","(data) -> {\n\t\t__helios__common__test_constr_data_2(data 0, __helios__txoutputid__is_valid_data, __helios__txoutput__is_valid_data)\n\t}")),r(new RawFunc("__helios__txinput__new","(output_id, output) -> {\n\t\t__core__constrData(0, __helios__common__list_2(output_id, output))\n\t}")),r(new RawFunc("__helios__txinput__output_id","__helios__common__enum_field_0")),r(new RawFunc("__helios__txinput__output","__helios__common__enum_field_1")),r(new RawFunc("__helios__txinput__address","(self) -> {\n\t\t__helios__txoutput__address(__helios__txinput__output(self))\n\t}")),r(new RawFunc("__helios__txinput__value","(self) -> {\n\t\t__helios__txoutput__value(__helios__txinput__output(self))\n\t}")),r(new RawFunc("__helios__txinput__datum","(self) -> {\n\t\t__helios__txoutput__datum(__helios__txinput__output(self))\n\t}")),l("__helios__txoutput"),r(new RawFunc("__helios__txoutput__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__txoutput__new","(address, value, datum) -> {\n\t\t__core__constrData(0, __helios__common__list_4(address, __core__mapData(value), datum, __helios__option__NONE))\n\t}")),r(new RawFunc("__helios__txoutput__address","__helios__common__enum_field_0")),r(new RawFunc("__helios__txoutput__value","(self) -> {\n\t\t__core__unMapData(__helios__common__enum_field_1(self))\n\t}")),r(new RawFunc("__helios__txoutput__datum","__helios__common__enum_field_2")),r(new RawFunc("__helios__txoutput__ref_script_hash","__helios__common__enum_field_3")),r(new RawFunc("__helios__txoutput__get_datum_hash","(self) -> {\n\t\t() -> {\n\t\t\tpair = __core__unConstrData(__helios__txoutput__datum(self));\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(__core__fstPair(pair), 1),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__datumhash__from_data(\n\t\t\t\t\t\t__core__headList(__core__sndPair(pair))\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t() -> {#}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__txoutput__has_datum_hash","(self, datumHash) -> {\n\t\t__helios__datumhash____eq(__helios__txoutput__get_datum_hash(self)(), datumHash)\n\t}")),r(new RawFunc(`__helios__txoutput__has_inline_datum[${FTPP}0]`,`(self, datum) -> {\n\t\tpair = __core__unConstrData(__helios__txoutput__datum(self));\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__fstPair(pair), 2),\n\t\t\t() -> {\n\t\t\t\t__core__equalsData(\n\t\t\t\t\t${FTPP}0____to_data(datum),\n\t\t\t\t\t__core__headList(__core__sndPair(pair))\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {false}\n\t\t)()\n\t}`)),r(new RawFunc("__helios__txoutput__is_locked_by","(self) -> {\n\t\t(hash) -> {\n\t\t\tcredential = __helios__address__credential(__helios__txoutput__address(self));\n\t\t\t__core__ifThenElse(\n\t\t\t\t__helios__credential__is_validator(credential),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__validatorhash____eq(\n\t\t\t\t\t\thash,\n\t\t\t\t\t\t__helios__credential__validator__hash(\n\t\t\t\t\t\t\t__helios__credential__validator__cast(credential)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t() -> {false}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__txoutput__is_sent_to","(self) -> {\n\t\t(pkh) -> {\n\t\t\tcredential = __helios__address__credential(__helios__txoutput__address(self));\n\t\t\t__core__ifThenElse(\n\t\t\t\t__helios__credential__is_pubkey(credential),\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__pubkeyhash____eq(\n\t\t\t\t\t\tpkh,\n\t\t\t\t\t\t__helios__credential__pubkey__hash(\n\t\t\t\t\t\t\t__helios__credential__pubkey__cast(credential)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t() -> {false}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__txoutput__sum_values","(outputs) -> {\n\t\t__helios__common__fold(\n\t\t\toutputs,\n\t\t\t(prev, txOutput) -> {\n\t\t\t\t__helios__value____add(\n\t\t\t\t\tprev,\n\t\t\t\t\t__helios__txoutput__value(txOutput)\n\t\t\t\t)\n\t\t\t},\n\t\t\t__helios__value__ZERO\n\t\t)\n\t}")),l("__helios__outputdatum"),r(new RawFunc("__helios__outputdatum__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__outputdatum__new_none","() -> {\n\t\t__core__constrData(0, __helios__common__list_0)\n\t}")),r(new RawFunc("__helios__outputdatum__new_hash","(hash) -> {\n\t\t__core__constrData(1, __helios__common__list_1(__helios__datumhash____to_data(hash)))\n\t}")),r(new RawFunc("__helios__outputdatum__new_inline[__helios__data]","(data) -> {\n\t\t__core__constrData(2, __helios__common__list_1(data))\n\t}")),r(new RawFunc(`__helios__outputdatum__new_inline[${FTPP}0]`,`(data) -> {\n\t\t__helios__outputdatum__new_inline[__helios__data](${FTPP}0____to_data(data))\n\t}`)),r(new RawFunc("__helios__outputdatum__get_inline_data",'(self) -> {\n\t\t() -> {\n\t\t\tpair = __core__unConstrData(self);\n\t\t\tindex = __core__fstPair(pair);\n\t\t\tfields = __core__sndPair(pair);\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(index, 2),\n\t\t\t\t() -> {\n\t\t\t\t\t__core__headList(fields)\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__error("not an inline datum")\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}')),u("__helios__outputdatum__none",0),u("__helios__outputdatum__hash",1),r(new RawFunc("__helios__outputdatum__hash__hash","(self) -> {\n\t\t__helios__datumhash__from_data(__helios__common__enum_field_0(self))\n\t}")),u("__helios__outputdatum__inline",2),r(new RawFunc("__helios__outputdatum__inline__data","__helios__common__enum_field_0")),l("__helios__data"),r(new RawFunc("__helios__data__is_valid_data","(data) -> {true}")),r(new RawFunc("__helios__data__tag","(self) -> {\n\t\t__core__fstPair(__core__unConstrData(self))\n\t}")),l("__helios__txoutputid"),r(new RawFunc("__helios__txoutputid__is_valid_data","(data) -> {\n\t\t__helios__common__test_constr_data_2(data, 0, __helios__txid__is_valid_data, __helios__int__is_valid_data)\n\t}")),r(new RawFunc("__helios__txoutputid__tx_id","__helios__common__enum_field_0")),r(new RawFunc("__helios__txoutputid__index","(self) -> {\n\t\t__helios__int__from_data(__helios__common__enum_field_1(self))\n\t}")),r(new RawFunc("__helios__txoutputid__comp","(a, b, comp_txid, comp_index) -> {\n\t\ta_txid = __helios__txoutputid__tx_id(a);\n\t\ta_index = __helios__txoutputid__index(a);\n\t\tb_txid = __helios__txoutputid__tx_id(b);\n\t\tb_index = __helios__txoutputid__index(b);\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsData(a_txid, b_txid),\n\t\t\t() -> {\n\t\t\t\tcomp_index(a_index, b_index)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\tcomp_txid(a_txid, b_txid)\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__txoutputid____lt","(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____lt, __helios__int____lt)\n\t}")),r(new RawFunc("__helios__txoutputid____leq","(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____leq, __helios__int____leq)\n\t}")),r(new RawFunc("__helios__txoutputid____gt","(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____gt, __helios__int____gt)\n\t}")),r(new RawFunc("__helios__txoutputid____geq","(a, b) -> {\n\t\t__helios__txoutputid__comp(a, b, __helios__txid____geq, __helios__int____geq)\n\t}")),r(new RawFunc("__helios__txoutputid__new","(tx_id, idx) -> {\n\t\t__core__constrData(0, __helios__common__list_2(tx_id, __helios__int____to_data(idx)))\n\t}")),r(new RawFunc("__helios__txoutputid__show",'(self) -> {\n\t\t() -> {\n\t\t\t__helios__string____add(\n\t\t\t\t__helios__txid__show(__helios__txoutputid__tx_id(self))(),\n\t\t\t\t__helios__string____add(\n\t\t\t\t\t"#",\n\t\t\t\t\t__helios__int__show(__helios__txoutputid__index(self))()\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}')),l("__helios__address"),r(new RawFunc("__helios__address__to_hex","(self) -> {\n\t\t__helios__bytearray__show(__helios__address__to_bytes(self)())\n\t}")),r(new RawFunc("__helios__address__show","__helios__address__to_hex")),r(new RawFunc("__helios__address__header",`(self) -> {\n\t\t() -> {\n\t\t\tcredential = __helios__address__credential(self);\n\t\t\tstaking_credential = __helios__address__staking_credential(self);\n\t\t\t__core__ifThenElse(\n\t\t\t\t__helios__credential__is_pubkey(credential),\n\t\t\t\t() -> {\n\t\t\t\t\tstaking_option_pair = __core__unConstrData(staking_credential);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(staking_option_pair), 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tstaking_credential = __core__headList(__core__sndPair(__core__unConstrData(__helios__stakingcredential__hash__cast(__core__headList(__core__sndPair(staking_option_pair))))));\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__helios__credential__is_pubkey(staking_credential),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t${e?"0x00":"0x01"}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t${e?"0x20":"0x21"}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t${e?"0x60":"0x61"}\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tstaking_option_pair = __core__unConstrData(staking_credential);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(staking_option_pair), 0)\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tstaking_credential = __core__headList(__core__sndPair(__core__unConstrData(__helios__stakingcredential__hash__cast(__core__headList(__core__sndPair(staking_option_pair))))));\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__helios__credential__is_pubkey(staking_credential),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t${e?"0x10":"0x11"}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t${e?"0x30":"0x31"}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t${e?"0x70":"0x71"}\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc("__helios__address__to_bytes",`(self) -> {\n\t\t() -> {\n\t\t\tcredential = __helios__address__credential(self);\n\t\t\tstaking_credential = __helios__address__staking_credential(self);\n\t\t\t__core__ifThenElse(\n\t\t\t\t__helios__credential__is_pubkey(credential),\n\t\t\t\t() -> {\n\t\t\t\t\tstaking_option_pair = __core__unConstrData(staking_credential);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(staking_option_pair), 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tstaking_credential = __core__headList(__core__sndPair(__core__unConstrData(__helios__stakingcredential__hash__cast(__core__headList(__core__sndPair(staking_option_pair))))));\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__helios__credential__is_pubkey(staking_credential),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t\t${e?"0x00":"0x01"},\n\t\t\t\t\t\t\t\t\t\t__core__appendByteString(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__pubkey__hash(credential),\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__pubkey__hash(staking_credential)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t\t${e?"0x20":"0x21"},\n\t\t\t\t\t\t\t\t\t\t__core__appendByteString(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__pubkey__hash(credential),\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__validator__hash(staking_credential)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t${e?"0x60":"0x61"},\n\t\t\t\t\t\t\t\t__helios__credential__pubkey__hash(credential)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\tstaking_option_pair = __core__unConstrData(staking_credential);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(__core__fstPair(staking_option_pair), 0),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\tstaking_credential = __core__headList(__core__sndPair(__core__unConstrData(__helios__stakingcredential__hash__cast(__core__headList(__core__sndPair(staking_option_pair))))));\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__helios__credential__is_pubkey(staking_credential),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t\t${e?"0x10":"0x11"},\n\t\t\t\t\t\t\t\t\t\t__core__appendByteString(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__validator__hash(credential),\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__pubkey__hash(staking_credential)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t\t\t${e?"0x30":"0x31"},\n\t\t\t\t\t\t\t\t\t\t__core__appendByteString(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__validator__hash(credential),\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__validator__hash(staking_credential)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__consByteString(\n\t\t\t\t\t\t\t\t${e?"0x70":"0x71"},\n\t\t\t\t\t\t\t\t__helios__credential__validator__hash(credential)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}`)),r(new RawFunc("__helios__address__from_bytes",`(bytes) -> {\n\t\theader = __core__indexByteString(bytes, 0);\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(__core__modInteger(header, 2), ${e?"0":"1"}),\n\t\t\t() -> {\n\t\t\t\tis_pubkey_spending = __core__equalsInteger(__core__modInteger(__core__divideInteger(header, 16), 2), 0);\n\t\t\t\tstaking_type = __core__divideInteger(header, 32);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\tis_pubkey_spending,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(staking_type, 0),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__address__new(\n\t\t\t\t\t\t\t\t\t__helios__credential__new_pubkey(__core__sliceByteString(1, 28, bytes)),\n\t\t\t\t\t\t\t\t\t__core__constrData(0, __helios__common__list_1(\n\t\t\t\t\t\t\t\t\t\t__helios__stakingcredential__new_hash(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_pubkey(__core__sliceByteString(29, 28, bytes))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(staking_type, 1),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__address__new(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_pubkey(__core__sliceByteString(1, 28, bytes)),\n\t\t\t\t\t\t\t\t\t\t\t__core__constrData(0, __helios__common__list_1(\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__stakingcredential__new_hash(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_validator(__core__sliceByteString(29, 28, bytes))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(staking_type, 3),\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__address__new(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_pubkey(__core__sliceByteString(1, 28, bytes)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__option__NONE\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__error("unhandled staking type")\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(staking_type, 0),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__address__new(\n\t\t\t\t\t\t\t\t\t__helios__credential__new_validator(__core__sliceByteString(1, 28, bytes)),\n\t\t\t\t\t\t\t\t\t__core__constrData(0, __helios__common__list_1(\n\t\t\t\t\t\t\t\t\t\t__helios__stakingcredential__new_hash(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_pubkey(__core__sliceByteString(29, 28, bytes))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__equalsInteger(staking_type, 1),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__address__new(\n\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_validator(__core__sliceByteString(1, 28, bytes)),\n\t\t\t\t\t\t\t\t\t\t\t__core__constrData(0, __helios__common__list_1(\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__stakingcredential__new_hash(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_validator(__core__sliceByteString(29, 28, bytes))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t))\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t__core__equalsInteger(staking_type, 3),\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__address__new(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__credential__new_validator(__core__sliceByteString(1, 28, bytes)),\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__option__NONE\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__error("unhandled staking type")\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__error(\n\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t"not a ${e?"testnet":"mainnet"} address (header: ",\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t__helios__int__show(header)(),\n\t\t\t\t\t\t\t")"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\t\t)()\n\t}`)),r(new RawFunc("__helios__address__from_hex","(hex) -> {\n\t\t__helios__address__from_bytes(__helios__bytearray__parse(hex))\n\t}")),r(new RawFunc("__helios__address__is_valid_data","(data) -> {\n\t\t__helios__common__test_constr_data_2(data, 0, __helios__credential__is_valid_data, __helios__option[__helios__stakingcredential]__is_valid_data)\n\t}")),r(new RawFunc("__helios__address__new","(cred, staking_cred) -> {\n\t\t__core__constrData(0, __helios__common__list_2(cred, staking_cred))\n\t}")),r(new RawFunc("__helios__address__new_empty","() -> {\n\t\t__core__constrData(0, __helios__common__list_2(__helios__credential__new_pubkey(#), __helios__option__NONE))\n\t}")),r(new RawFunc("__helios__address__credential","__helios__common__enum_field_0")),r(new RawFunc("__helios__address__staking_credential","__helios__common__enum_field_1")),r(new RawFunc("__helios__address__is_staked","(self) -> {\n\t\t() -> {\n\t\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(__helios__common__enum_field_1(self))), 0)\n\t\t}\n\t}")),l("__helios__credential"),r(new RawFunc("__helios__credential__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\tpair = __core__unConstrData__safe(data);\n\t\t\t\tindex = __core__fstPair(pair);\n\t\t\t\tfields = __core__sndPair(pair);\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(index, 0),\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t__core__tailList__safe(fields),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__validatorhash__is_valid_data(__core__headList__safe(fields))\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(index, 1),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\t\t__core__tailList__safe(fields),\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__pubkeyhash__is_valid_data(__core__headList__safe(fields))\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__credential__new_pubkey","(hash) -> {\n\t\t__core__constrData(0, __helios__common__list_1(__helios__pubkeyhash____to_data(hash)))\n\t}")),r(new RawFunc("__helios__credential__new_validator","(hash) -> {\n\t\t__core__constrData(1, __helios__common__list_1(__helios__validatorhash____to_data(hash)))\n\t}")),r(new RawFunc("__helios__credential__is_pubkey","(self) -> {\n\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(self)), 0)\n\t}")),r(new RawFunc("__helios__credential__is_validator","(self) -> {\n\t\t__core__equalsInteger(__core__fstPair(__core__unConstrData(self)), 1)\n\t}")),u("__helios__credential__pubkey",0),r(new RawFunc("__helios__credential__pubkey__cast","(data) -> {\n\t\t__helios__common__assert_constr_index(data, 0)\n\t}")),r(new RawFunc("__helios__credential__pubkey__hash","(self) -> {\n\t\t__helios__pubkeyhash__from_data(__helios__common__enum_field_0(self))\n\t}")),u("__helios__credential__validator",1),r(new RawFunc("__helios__credential__validator____new","__helios__credential__new_validator")),r(new RawFunc("__helios__credential__validator__cast","(data) -> {\n\t\t__helios__common__assert_constr_index(data, 1)\n\t}")),r(new RawFunc("__helios__credential__validator__hash","(self) -> {\n\t\t__helios__validatorhash__from_data(__helios__common__enum_field_0(self))\n\t}")),l("__helios__stakinghash"),r(new RawFunc("__helios__stakinghash__is_valid_data","__helios__credential__is_valid_data")),r(new RawFunc("__helios__stakinghash__new_stakekey","__helios__credential__new_pubkey")),r(new RawFunc("__helios__stakinghash__new_validator","__helios__credential__new_validator")),r(new RawFunc("__helios__stakinghash__is_stakekey","__helios__credential__is_stakekey")),r(new RawFunc("__helios__stakinghash__is_validator","__helios__credential__is_validator")),u("__helios__stakinghash__stakekey",0),r(new RawFunc("__helios__stakinghash__stakekey__is_valid_data","__helios__credential__pubkey__is_valid_data")),r(new RawFunc("__helios__stakinghash__stakekey__cast","__helios__credential__pubkey__cast")),r(new RawFunc("__helios__stakinghash__stakekey__hash","__helios__credential__pubkey__hash")),u("__helios__stakinghash__validator",1),r(new RawFunc("__helios__stakinghash__validator__is_valid_data","__helios__credential__validator__is_valid_data")),r(new RawFunc("__helios__stakinghash__validator__cast","__helios__credential__validator__cast")),r(new RawFunc("__helios__stakinghash__validator__hash","__helios__credential__validator__hash")),l("__helios__stakingcredential"),r(new RawFunc("__helios__stakingcredential__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__stakingcredential__new_hash","(cred) -> {\n\t\t__core__constrData(0, __helios__common__list_1(cred))\n\t}")),r(new RawFunc("__helios__stakingcredential__hash__cast","(data) -> {\n\t\t__helios__common__assert_constr_index(data, 0)\n\t}")),r(new RawFunc("__helios__stakingcredential__new_ptr","(i, j, k) -> {\n\t\t__core__constrData(1, __helios__common__list_3(\n\t\t\t__helios__int____to_data(i),\n\t\t\t__helios__int____to_data(j),\n\t\t\t__helios__int____to_data(k)\n\t\t))\n\t}")),r(new RawFunc("__helios__stakingcredential__ptr__cast","(data) -> {\n\t\t__helios__common__assert_constr_index(data, 1)\n\t}")),u("__helios__stakingcredential__hash",0),r(new RawFunc("__helios__stakingcredential__hash__hash","__helios__common__enum_field_0")),u("__helios__stakingcredential__ptr",1),o("__helios__time"),r(new RawFunc("__helios__time__is_valid_data","__helios__int__is_valid_data")),r(new RawFunc("__helios__time__new","__helios__common__identity")),r(new RawFunc("__helios__time____add","__helios__int____add")),r(new RawFunc("__helios__time____sub","__helios__int____sub")),r(new RawFunc("__helios__time____sub1","__helios__int____sub")),r(new RawFunc("__helios__time____geq","__helios__int____geq")),r(new RawFunc("__helios__time____gt","__helios__int____gt")),r(new RawFunc("__helios__time____leq","__helios__int____leq")),r(new RawFunc("__helios__time____lt","__helios__int____lt")),r(new RawFunc("__helios__time__show","__helios__int__show")),o("__helios__duration"),r(new RawFunc("__helios__duration__is_valid_data","__helios__int__is_valid_data")),r(new RawFunc("__helios__duration__new","__helios__common__identity")),r(new RawFunc("__helios__duration__show","__helios__int__show")),r(new RawFunc("__helios__duration____add","__helios__int____add")),r(new RawFunc("__helios__duration____sub","__helios__int____sub")),r(new RawFunc("__helios__duration____mul","__helios__int____mul")),r(new RawFunc("__helios__duration____div","__helios__int____div")),r(new RawFunc("__helios__duration____div1","__helios__int____div")),r(new RawFunc("__helios__duration____mod","__helios__int____mod")),r(new RawFunc("__helios__duration____geq","__helios__int____geq")),r(new RawFunc("__helios__duration____gt","__helios__int____gt")),r(new RawFunc("__helios__duration____leq","__helios__int____leq")),r(new RawFunc("__helios__duration____lt","__helios__int____lt")),r(new RawFunc("__helios__duration__SECOND","1000")),r(new RawFunc("__helios__duration__MINUTE","60000")),r(new RawFunc("__helios__duration__HOUR","3600000")),r(new RawFunc("__helios__duration__DAY","86400000")),r(new RawFunc("__helios__duration__WEEK","604800000")),l("__helios__timerange"),r(new RawFunc("__helios__timerange__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__timerange__new","\n\t(a, b) -> {\n\t\ta = __helios__time____to_data(a);\n\t\tb = __helios__time____to_data(b);\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(a)),\n\t\t\t\t__helios__bool____to_data(true)\n\t\t\t)),\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(b)),\n\t\t\t\t__helios__bool____to_data(true)\n\t\t\t))\n\t\t))\n\t}")),r(new RawFunc("__helios__timerange__ALWAYS","\n\t__core__constrData(0, __helios__common__list_2(\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_0),\n\t\t\t__helios__bool____to_data(true)\n\t\t)),\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(2, __helios__common__list_0),\n\t\t\t__helios__bool____to_data(true)\n\t\t))\n\t))")),r(new RawFunc("__helios__timerange__NEVER","\n\t__core__constrData(0, __helios__common__list_2(\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(2, __helios__common__list_0),\n\t\t\t__helios__bool____to_data(true)\n\t\t)),\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_0),\n\t\t\t__helios__bool____to_data(true)\n\t\t))\n\t))")),r(new RawFunc("__helios__timerange__from","\n\t(a) -> {\n\t\ta = __helios__time____to_data(a);\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(a)),\n\t\t\t\t__helios__bool____to_data(true)\n\t\t\t)),\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(2, __helios__common__list_0),\n\t\t\t\t__helios__bool____to_data(true)\n\t\t\t))\n\t\t))\n\t}")),r(new RawFunc("__helios__timerange__to","\n\t(b) -> {\n\t\tb = __helios__time____to_data(b);\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(0, __helios__common__list_0),\n\t\t\t\t__helios__bool____to_data(true)\n\t\t\t)),\n\t\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t\t__core__constrData(1, __helios__common__list_1(b)),\n\t\t\t\t__helios__bool____to_data(true)\n\t\t\t))\n\t\t))\n\t}")),r(new RawFunc("__helios__timerange__is_before","(self) -> {\n\t\t(t) -> {\n\t\t\tupper = __helios__common__enum_field_1(self);\n\t\t\textended = __helios__common__enum_field_0(upper);\n\t\t\tclosed = __helios__bool__from_data(__helios__common__enum_field_1(upper));\n\t\t\textType = __core__fstPair(__core__unConstrData(extended));\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(extType, 2),\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(extType, 0),\n\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), t)},\n\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), t)}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__timerange__is_after","(self) -> {\n\t\t(t) -> {\n\t\t\tlower = __helios__common__enum_field_0(self);\n\t\t\textended = __helios__common__enum_field_0(lower);\n\t\t\tclosed = __helios__bool__from_data(__helios__common__enum_field_1(lower));\n\t\t\textType = __core__fstPair(__core__unConstrData(extended));\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(extType, 0),\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(extType, 2),\n\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(t, __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))},\n\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(t, __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__timerange__contains","(self) -> {\n\t\t(t) -> {\n\t\t\tlower = __helios__common__enum_field_0(self);\n\t\t\textended = __helios__common__enum_field_0(lower);\n\t\t\tclosed = __helios__bool__from_data(__helios__common__enum_field_1(lower));\n\t\t\tlowerExtType = __core__fstPair(__core__unConstrData(extended));\n\t\t\tcheckUpper = () -> {\n\t\t\t\tupper = __helios__common__enum_field_1(self);\n\t\t\t\textended = __helios__common__enum_field_0(upper);\n\t\t\t\tclosed = __helios__bool__from_data(__helios__common__enum_field_1(upper));\n\t\t\t\tupperExtType = __core__fstPair(__core__unConstrData(extended));\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(upperExtType, 0),\n\t\t\t\t\t() -> {false},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(upperExtType, 2),\n\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(t, __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))},\n\t\t\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(t, __core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))))}\n\t\t\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__core__ifThenElse(\n\t\t\t\t__core__equalsInteger(lowerExtType, 2),\n\t\t\t\t() -> {false},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsInteger(lowerExtType, 0),\n\t\t\t\t\t\t() -> {checkUpper()},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\tclosed,\n\t\t\t\t\t\t\t\t\t() -> {__core__lessThanEqualsInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), t)},\n\t\t\t\t\t\t\t\t\t() -> {__core__lessThanInteger(__core__unIData(__core__headList(__core__sndPair(__core__unConstrData(extended)))), t)}\n\t\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\t\t() -> {checkUpper()},\n\t\t\t\t\t\t\t\t() -> {false}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t}\n\t}")),r(new RawFunc("__helios__timerange__start","(self) -> {\n\t\t__helios__time__from_data(__helios__common__enum_field_0(__helios__common__enum_field_0(__helios__common__enum_field_0(self))))\n\t}")),r(new RawFunc("__helios__timerange__end","(self) -> {\n\t\t__helios__time__from_data(__helios__common__enum_field_0(__helios__common__enum_field_0(__helios__common__enum_field_1(self))))\n\t}")),r(new RawFunc("__helios__timerange__show",'(self) -> {\n\t\t() -> {\n\t\t\tshow_extended = (extended) -> {\n\t\t\t\textType = __core__fstPair(__core__unConstrData(extended));\n\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t__core__equalsInteger(extType, 0),\n\t\t\t\t\t() -> {"-inf"},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(extType, 2),\n\t\t\t\t\t\t\t() -> {"+inf"},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tfields = __core__sndPair(__core__unConstrData(extended));\n\t\t\t\t\t\t\t\t__helios__int__show(\n\t\t\t\t\t\t\t\t\t__helios__int__from_data(__core__headList(fields))\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\t__helios__string____add(\n\t\t\t\tlower = __helios__common__enum_field_0(self);\n\t\t\t\textended = __helios__common__enum_field_0(lower);\n\t\t\t\tclosed = __helios__bool__from_data(__helios__common__enum_field_1(lower));\n\t\t\t\t__helios__string____add(\n\t\t\t\t\t__core__ifThenElse(closed, "[", "("),\n\t\t\t\t\tshow_extended(extended)\n\t\t\t\t),\n\t\t\t\t__helios__string____add(\n\t\t\t\t\t",",\n\t\t\t\t\tupper = __helios__common__enum_field_1(self);\n\t\t\t\t\textended = __helios__common__enum_field_0(upper);\n\t\t\t\t\tclosed = __helios__bool__from_data(__helios__common__enum_field_1(upper));\n\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\tshow_extended(extended),\n\t\t\t\t\t\t__core__ifThenElse(closed, "]", ")")\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\t}')),l("__helios__assetclass"),r(new RawFunc("__helios__assetclass__is_valid_data","(data) -> {\n\t\t__helios__common__test_constr_data_2(data, 0, __helios__mintingpolicyhash__is_valid_data, __helios__bytearray__is_valid_data)\n\t}")),r(new RawFunc("__helios__assetclass__ADA","__helios__assetclass__new(#, #)")),r(new RawFunc("__helios__assetclass__new","(mph, token_name) -> {\n\t\t__core__constrData(0, __helios__common__list_2(\n\t\t\t__helios__mintingpolicyhash____to_data(mph),\n\t\t\t__helios__bytearray____to_data(token_name)\n\t\t))\n\t}")),r(new RawFunc("__helios__assetclass__mph","(self) -> {\n\t\t__helios__mintingpolicyhash__from_data(__helios__common__enum_field_0(self))\n\t}")),r(new RawFunc("__helios__assetclass__token_name","(self) -> {\n\t\t__helios__bytearray__from_data(__helios__common__enum_field_1(self))\n\t}")),r(new RawFunc("__helios__assetclass__show",'(self) -> {\n\t\t__core__chooseData(\n\t\t\tself,\n\t\t\t() -> {\n\t\t\t\tfields = __core__sndPair(__core__unConstrData__safe(self));\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tfields,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t"N/A"\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tmph = __core__headList__safe(fields);\n\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t__core__chooseData(\n\t\t\t\t\t\t\t\tmph,\n\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__helios__bytearray__show(__core__unBData__safe(mph))()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)(),\n\t\t\t\t\t\t\t__core__appendString(\n\t\t\t\t\t\t\t\t".",\n\t\t\t\t\t\t\t\tfields = __core__tailList__safe(fields);\n\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\tfields,\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t"N/A"\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\ttoken_name = __core__headList__safe(fields);\n\t\t\t\t\t\t\t\t\t\t__core__chooseData(\n\t\t\t\t\t\t\t\t\t\t\ttoken_name,\n\t\t\t\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t\t\t\t() -> {"N/A"},\n\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__bytearray__show(__core__unBData__safe(token_name))()\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t},\n\t\t\t() -> {"N/A"},\n\t\t\t() -> {"N/A"},\n\t\t\t() -> {"N/A"},\n\t\t\t() -> {"N/A"}\n\t\t)\n\t}')),r(new RawFunc("__helios__assetclass____lt","(a, b) -> {\n\t\tmpha = __helios__assetclass__mph(a);\n\t\tmphb = __helios__assetclass__mph(b);\n\t\t__core__ifThenElse(\n\t\t\t__helios__bytearray____eq(mpha, mphb),\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____lt(\n\t\t\t\t\t__helios__assetclass__token_name(a),\n\t\t\t\t\t__helios__assetclass__token_name(b)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____lt(mpha, mphb)\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__assetclass____leq","(a, b) -> {\n\t\tmpha = __helios__assetclass__mph(a);\n\t\tmphb = __helios__assetclass__mph(b);\n\t\t__core__ifThenElse(\n\t\t\t__helios__bytearray____eq(mpha, mphb),\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____leq(\n\t\t\t\t\t__helios__assetclass__token_name(a),\n\t\t\t\t\t__helios__assetclass__token_name(b)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____lt(mpha, mphb)\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__assetclass____gt","(a, b) -> {\n\t\tmpha = __helios__assetclass__mph(a);\n\t\tmphb = __helios__assetclass__mph(b);\n\t\t__core__ifThenElse(\n\t\t\t__helios__bytearray____eq(mpha, mphb),\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____gt(\n\t\t\t\t\t__helios__assetclass__token_name(a),\n\t\t\t\t\t__helios__assetclass__token_name(b)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____gt(mpha, mphb)\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__assetclass____geq","(a, b) -> {\n\t\tmpha = __helios__assetclass__mph(a);\n\t\tmphb = __helios__assetclass__mph(b);\n\t\t__core__ifThenElse(\n\t\t\t__helios__bytearray____eq(mpha, mphb),\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____geq(\n\t\t\t\t\t__helios__assetclass__token_name(a),\n\t\t\t\t\t__helios__assetclass__token_name(b)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__bytearray____gt(mpha, mphb)\n\t\t\t}\n\t\t)()\n\t}")),i("__helios__value"),r(new RawFunc("__helios__value__is_valid_data","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {false},\n\t\t\t() -> {\n\t\t\t\tmap = __core__unMapData__safe(data);\n\t\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\tmap,\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\thead = __core__headList__safe(map);\n\t\t\t\t\t\t\tkey = __core__fstPair(head);\n\t\t\t\t\t\t\tvalue = __core__sndPair(head);\n\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t__helios__mintingpolicyhash__is_valid_data(key),\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t__core__chooseData(\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\tinner = __core__unMapData__safe(value);\n\t\t\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\t\t\tinner,\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\trecurse_inner = (recurse_inner, inner) -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinner,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thead = __core__headList__safe(inner);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey = __core__fstPair(head);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue = __core__sndPair(head);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__bytearray__is_valid_data(key),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__int__is_valid_data(value),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\t\trecurse_inner(recurse_inner, inner)\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t\t\t\t\t() -> {false}\n\t\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t};\n\t\t\t\trecurse(recurse, map)\n\t\t\t},\n\t\t\t() -> {false},\n\t\t\t() -> {false},\n\t\t\t() -> {false}\n\t\t)()\n\t}")),r(new RawFunc("__helios__value__from_data","__core__unMapData")),r(new RawFunc("__helios__value__from_data_safe","(data) -> {\n\t\t__core__chooseData(\n\t\t\tdata,\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {\n\t\t\t\t__helios__option__SOME_FUNC(__core__unMapData__safe(data))\n\t\t\t},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC},\n\t\t\t() -> {__helios__option__NONE_FUNC}\n\t\t)()\n\t}")),r(new RawFunc("__helios__value____to_data","__core__mapData")),r(new RawFunc("__helios__value__value","__helios__common__identity")),r(new RawFunc("__helios__value__ZERO","__core__mkNilPairData(())")),r(new RawFunc("__helios__value__lovelace","(i) -> {\n\t\t__helios__value__new(__helios__assetclass__ADA, i)\n\t}")),r(new RawFunc("__helios__value__new","(assetClass, i) -> {\n\t\t__core__ifThenElse(\n\t\t\t__core__equalsInteger(0, i),\n\t\t\t() -> {\n\t\t\t\t__helios__value__ZERO\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\tmph = __helios__common__enum_field_0(assetClass);\n\t\t\t\ttokenName = __helios__common__enum_field_1(assetClass);\n\t\t\t\t__core__mkCons(\n\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\tmph,\n\t\t\t\t\t\t__core__mapData(\n\t\t\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t\t\t__core__mkPairData(tokenName, __helios__int____to_data(i)),\n\t\t\t\t\t\t\t\t__core__mkNilPairData(())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\t__core__mkNilPairData(())\n\t\t\t\t)\n\t\t\t}\n\t\t)()\n\t}")),r(new RawFunc("__helios__value__from_map","__helios__common__identity")),r(new RawFunc("__helios__value__to_map","(self) -> {\n\t\t() -> {\n\t\t\tself\n\t\t}\n\t}")),r(new RawFunc("__helios__value__get_map_keys","(map) -> {\n\t\trecurse = (recurse, map) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {__helios__common__list_0},\n\t\t\t\t() -> {__core__mkCons(__core__fstPair(__core__headList__safe(map)), recurse(recurse, __core__tailList__safe(map)))}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, map)\n\t}")),r(new RawFunc("__helios__value__merge_map_keys","(a, b) -> {\n\t\taKeys = __helios__value__get_map_keys(a);\n\t\trecurse = (recurse, keys, map) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {__helios__common__list_0},\n\t\t\t\t() -> {\n\t\t\t\t\tkey = __core__fstPair(__core__headList__safe(map));\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__helios__common__is_in_bytearray_list(aKeys, key),\n\t\t\t\t\t\t() -> {recurse(recurse, keys, __core__tailList__safe(map))},\n\t\t\t\t\t\t() -> {__core__mkCons(key, recurse(recurse, keys, __core__tailList__safe(map)))}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\tuniqueBKeys = recurse(recurse, aKeys, b);\n\t\t__helios__common__concat(aKeys, uniqueBKeys)\n\t}")),r(new RawFunc("__helios__value__get_inner_map","(map, mph) -> {\n\t\trecurse = (recurse, map) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {__core__mkNilPairData(())},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), mph),\n\t\t\t\t\t\t() -> {__core__unMapData(__core__sndPair(__core__headList__safe(map)))},\n\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(map))}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, map)\n\t}")),r(new RawFunc("__helios__value__get_inner_map_int","(map, key) -> {\n\t\trecurse = (recurse, map, key) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tmap,\n\t\t\t\t() -> {0},\n\t\t\t\t() -> {\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), key),\n\t\t\t\t\t\t() -> {__core__unIData(__core__sndPair(__core__headList__safe(map)))},\n\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(map), key)}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, map, key)\n\t}")),r(new RawFunc("__helios__value__add_or_subtract_inner","(op) -> {\n\t\t(a, b) -> {\n\t\t\trecurse = (recurse, keys, result) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tkeys,\n\t\t\t\t\t() -> {result},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\tkey = __core__headList__safe(keys);\n\t\t\t\t\t\ttail = recurse(recurse, __core__tailList__safe(keys), result);\n\t\t\t\t\t\tsum = op(__helios__value__get_inner_map_int(a, key), __helios__value__get_inner_map_int(b, key));\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsInteger(sum, 0),\n\t\t\t\t\t\t\t() -> {tail},\n\t\t\t\t\t\t\t() -> {__core__mkCons(__core__mkPairData(key, __core__iData(sum)), tail)}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, __helios__value__merge_map_keys(a, b), __core__mkNilPairData(()))\n\t\t}\n\t}")),r(new RawFunc("__helios__value__add_or_subtract","(a, b, op) -> {\n\t\trecurse = (recurse, keys, result) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tkeys,\n\t\t\t\t() -> {result},\n\t\t\t\t() -> {\n\t\t\t\t\tkey = __core__headList__safe(keys);\n\t\t\t\t\ttail = recurse(recurse, __core__tailList__safe(keys), result);\n\t\t\t\t\titem = __helios__value__add_or_subtract_inner(op)(__helios__value__get_inner_map(a, key), __helios__value__get_inner_map(b, key));\n\t\t\t\t\t__core__chooseList(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\t() -> {tail},\n\t\t\t\t\t\t() -> {__core__mkCons(__core__mkPairData(key, __core__mapData(item)), tail)}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, __helios__value__merge_map_keys(a, b), __core__mkNilPairData(()))\n\t}")),r(new RawFunc("__helios__value__map_quantities","(self, op) -> {\n\t\trecurseInner = (recurseInner, inner) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tinner,\n\t\t\t\t() -> {__core__mkNilPairData(())},\n\t\t\t\t() -> {\n\t\t\t\t\thead = __core__headList__safe(inner);\n\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\t\t__core__fstPair(head),\n\t\t\t\t\t\t\t__core__iData(op(__core__unIData(__core__sndPair(head))))\n\t\t\t\t\t\t),\n\t\t\t\t\t\trecurseInner(recurseInner, __core__tailList__safe(inner))\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurseOuter = (recurseOuter, outer) -> {\n\t\t\t__core__chooseList(\n\t\t\t\touter,\n\t\t\t\t() -> {__core__mkNilPairData(())},\n\t\t\t\t() -> {\n\t\t\t\t\thead = __core__headList__safe(outer);\n\t\t\t\t\t__core__mkCons(\n\t\t\t\t\t\t__core__mkPairData(\n\t\t\t\t\t\t\t__core__fstPair(head),\n\t\t\t\t\t\t\t__core__mapData(recurseInner(recurseInner, __core__unMapData(__core__sndPair(head))))\n\t\t\t\t\t\t),\n\t\t\t\t\t\trecurseOuter(recurseOuter, __core__tailList__safe(outer))\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurseOuter(recurseOuter, self)\n\t}")),r(new RawFunc("__helios__value__compare_inner","(comp, a, b) -> {\n\t\trecurse = (recurse, keys) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tkeys,\n\t\t\t\t() -> {true},\n\t\t\t\t() -> {\n\t\t\t\t\tkey = __core__headList__safe(keys);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__helios__bool____not(\n\t\t\t\t\t\t\tcomp(\n\t\t\t\t\t\t\t\t__helios__value__get_inner_map_int(a, key),\n\t\t\t\t\t\t\t\t__helios__value__get_inner_map_int(b, key)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t),\n\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(keys))}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, __helios__value__merge_map_keys(a, b))\n\t}")),r(new RawFunc("__helios__value__compare","(a, b, comp) -> {\n\t\trecurse = (recurse, keys) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tkeys,\n\t\t\t\t() -> {true},\n\t\t\t\t() -> {\n\t\t\t\t\tkey = __core__headList__safe(keys);\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t__helios__bool____not(\n\t\t\t\t\t\t\t__helios__value__compare_inner(\n\t\t\t\t\t\t\t\tcomp,\n\t\t\t\t\t\t\t\t__helios__value__get_inner_map(a, key),\n\t\t\t\t\t\t\t\t__helios__value__get_inner_map(b, key)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t),\n\t\t\t\t\t\t() -> {false},\n\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(keys))}\n\t\t\t\t\t)()\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, __helios__value__merge_map_keys(a, b))\n\t}")),r(new RawFunc("__helios__value____eq","(a, b) -> {\n\t\t__helios__value__compare(a, b, __core__equalsInteger)\n\t}")),r(new RawFunc("__helios__value____neq","(a, b) -> {\n\t\t__helios__bool____not(__helios__value____eq(a, b))\n\t}")),r(new RawFunc("__helios__value____add","(a, b) -> {\n\t\t__helios__value__add_or_subtract(a, b, __core__addInteger)\n\t}")),r(new RawFunc("__helios__value____sub","(a, b) -> {\n\t\t__helios__value__add_or_subtract(a, b, __core__subtractInteger)\n\t}")),r(new RawFunc("__helios__value____mul","(a, scale) -> {\n\t\t__helios__value__map_quantities(a, (qty) -> {__core__multiplyInteger(qty, scale)})\n\t}")),r(new RawFunc("__helios__value____div","(a, den) -> {\n\t\t__helios__value__map_quantities(a, (qty) -> {__core__divideInteger(qty, den)})\n\t}")),r(new RawFunc("__helios__value____geq","(a, b) -> {\n\t\t__helios__value__compare(\n\t\t\ta,\n\t\t\tb,\n\t\t\t(a_qty, b_qty) -> {\n\t\t\t\t__helios__bool____not(\n\t\t\t\t\t__core__lessThanInteger(a_qty, b_qty)\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__value__contains","\n\t(self) -> {\n\t\t(value) -> {\n\t\t\t__helios__value____geq(self, value)\n\t\t}\n\t}")),r(new RawFunc("__helios__value____gt","(a, b) -> {\n\t\t__helios__bool__and(\n\t\t\t() -> {\n\t\t\t\t__helios__bool____not(\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t__helios__value__is_zero(a),\n\t\t\t\t\t\t__helios__value__is_zero(b)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__value__compare(\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\t(a_qty, b_qty) -> {\n\t\t\t\t\t\t__helios__bool____not(__core__lessThanEqualsInteger(a_qty, b_qty))\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__value____leq","(a, b) -> {\n\t\t__helios__value__compare(a, b, __core__lessThanEqualsInteger)\n\t}")),r(new RawFunc("__helios__value____lt","(a, b) -> {\n\t\t__helios__bool__and(\n\t\t\t() -> {\n\t\t\t\t__helios__bool____not(\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t__helios__value__is_zero(a),\n\t\t\t\t\t\t__helios__value__is_zero(b)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t},\n\t\t\t() -> {\n\t\t\t\t__helios__value__compare(\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\t(a_qty, b_qty) -> {\n\t\t\t\t\t\t__core__lessThanInteger(a_qty, b_qty)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\t}")),r(new RawFunc("__helios__value__is_zero_inner","(tokens) -> {\n\t\trecurse = (recurse, tokens) -> {\n\t\t\t__core__chooseList(\n\t\t\t\ttokens,\n\t\t\t\t() -> {\n\t\t\t\t\ttrue\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__equalsInteger(__core__unIData(__core__sndPair(__core__headList__safe(tokens))), 0)\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(tokens))\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, tokens)\n\t}")),r(new RawFunc("__helios__value__is_zero","(self) -> {\n\t\t() -> {\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\ttrue\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__bool__and(\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__helios__value__is_zero_inner(__core__unMapData(__core__sndPair(__core__headList__safe(map))))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}")),r(new RawFunc("__helios__value__get",'(self) -> {\n\t\t(assetClass) -> {\n\t\t\tmph = __helios__common__enum_field_0(assetClass);\n\t\t\ttokenName = __helios__common__enum_field_1(assetClass);\n\t\t\touter = (outer, inner, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__helios__error(\n\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t"policy ",\n\t\t\t\t\t\t\t\t\t__helios__mintingpolicyhash__show(__core__unBData(mph))()\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t" not found"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), mph),\n\t\t\t\t\t\t\t() -> {inner(inner, __core__unMapData(__core__sndPair(__core__headList__safe(map))))},\n\t\t\t\t\t\t\t() -> {outer(outer, inner, __core__tailList__safe(map))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\tinner = (inner, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {__helios__error("tokenName not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), tokenName),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__unIData(__core__sndPair(__core__headList__safe(map)))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tinner(inner, __core__tailList__safe(map))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\touter(outer, inner, self)\n\t\t}\n\t}')),r(new RawFunc("__helios__value__get_safe","(self) -> {\n\t\t(assetClass) -> {\n\t\t\tmintingPolicyHash = __helios__common__enum_field_0(assetClass);\n\t\t\ttokenName = __helios__common__enum_field_1(assetClass);\n\t\t\touter = (outer, inner, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {0},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), mintingPolicyHash),\n\t\t\t\t\t\t\t() -> {inner(inner, __core__unMapData(__core__sndPair(__core__headList__safe(map))))},\n\t\t\t\t\t\t\t() -> {outer(outer, inner, __core__tailList__safe(map))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\tinner = (inner, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {0},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), tokenName),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__unIData(__core__sndPair(__core__headList__safe(map)))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\tinner(inner, __core__tailList__safe(map))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\touter(outer, inner, self)\n\t\t}\n\t}")),r(new RawFunc("__helios__value__get_lovelace","(self) -> {\n\t\t() -> {\n\t\t\t__helios__value__get_safe(self)(__helios__assetclass__ADA)\n\t\t}\n\t}")),r(new RawFunc("__helios__value__get_assets","(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__filter_map(\n\t\t\t\tself,\n\t\t\t\t(pair) -> {\n\t\t\t\t\t__helios__bool____not(__core__equalsByteString(__core__unBData(__core__fstPair(pair)), #))\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\t}")),r(new RawFunc("__helios__value__get_policy",'(self) -> {\n\t\t(mph) -> {\n\t\t\tmph = __helios__mintingpolicyhash____to_data(mph);\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {__helios__error("policy not found")},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), mph),\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t__core__unMapData(__core__sndPair(__core__headList__safe(map)))\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(map))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}')),r(new RawFunc("__helios__value__contains_policy","(self) -> {\n\t\t(mph) -> {\n\t\t\tmph = __helios__mintingpolicyhash____to_data(mph);\n\t\t\trecurse = (recurse, map) -> {\n\t\t\t\t__core__chooseList(\n\t\t\t\t\tmap,\n\t\t\t\t\t() -> {false},\n\t\t\t\t\t() -> {\n\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t__core__equalsData(__core__fstPair(__core__headList__safe(map)), mph),\n\t\t\t\t\t\t\t() -> {true},\n\t\t\t\t\t\t\t() -> {recurse(recurse, __core__tailList__safe(map))}\n\t\t\t\t\t\t)()\n\t\t\t\t\t}\n\t\t\t\t)()\n\t\t\t};\n\t\t\trecurse(recurse, self)\n\t\t}\n\t}")),r(new RawFunc("__helios__value__show",'(self) -> {\n\t\t() -> {\n\t\t\t__helios__common__fold(\n\t\t\t\tself,\n\t\t\t\t(prev, pair) -> {\n\t\t\t\t\tmph = __core__unBData__safe(__core__fstPair(pair));\n\t\t\t\t\ttokens = __core__unMapData__safe(__core__sndPair(pair));\n\t\t\t\t\t__helios__common__fold(\n\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t(prev, pair) -> {\n\t\t\t\t\t\t\ttoken_name = __core__unBData__safe(__core__fstPair(pair));\n\t\t\t\t\t\t\tqty = __core__unIData__safe(__core__sndPair(pair));\n\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\tprev,\n\t\t\t\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t\t\t\t__helios__mintingpolicyhash____eq(mph, #),\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t"lovelace: ",\n\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__int__show(qty)(),\n\t\t\t\t\t\t\t\t\t\t\t\t"\\n"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t__helios__mintingpolicyhash__show(mph)(),\n\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t".",\n\t\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__bytearray__show(token_name)(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t": ",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__string____add(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t__helios__int__show(qty)(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"\\n"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t},\n\t\t\t\t\t\tprev\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t""\n\t\t\t)\n\t\t}\n\t}')),r(new RawFunc(`__helios__value__sum[${FTPP}0]`,`(self) -> {\n\t\trecurse = (recurse, lst) -> {\n\t\t\t__core__chooseList(\n\t\t\t\tlst,\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__value__ZERO\n\t\t\t\t},\n\t\t\t\t() -> {\n\t\t\t\t\t__helios__value____add(\n\t\t\t\t\t\t${FTPP}0__value(${FTPP}0__from_data(__core__headList__safe(lst))),\n\t\t\t\t\t\trecurse(recurse, __core__tailList__safe(lst))\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t)()\n\t\t};\n\t\trecurse(recurse, self)\n\t}`)),n}export class ToIRContext{simplify;indent;#ae;constructor(t,e="",n=new Map){this.simplify=t,this.indent=e,this.#ae=n}tab(){return new ToIRContext(this.simplify,this.indent+TAB,this.#ae)}get db(){return 0==this.#ae.size&&(this.#ae=makeRawFunctions(this.simplify)),this.#ae}}export function fetchRawGenerics(t){const e=new Map;for(let[n,r]of t.db)if(IRParametricName.matches(n)){const t=(t,e)=>r.toIR(t,e);e.set(n,t)}return e}export function fetchRawFunctions(t,e,n=null){if(null!==onNotifyRawUsage)for(let[e,n]of t.db)IRParametricName.isTemplate(e)||onNotifyRawUsage(e,0);let[r,s]=e.generateSource(),a=r.match(RE_BUILTIN);const i=new Map;if(null!==a)for(let e of a)if(!(IRParametricName.matches(e)||i.has(e)||n&&n.has(e))){const n=t.db.get(e);if(!n)throw console.log(r),new Error(`builtin ${e} not found`);n.load(t.db,i)}return i}export function wrapWithRawFunctions(t,e){const n=fetchRawFunctions(t,e);return IR.wrapWithDefinitions(e,n)}export class Expr extends Token{#ie;constructor(t){super(t),this.#ie=null}get cache(){return this.#ie}set cache(t){this.#ie=t}evalInternal(t){throw new Error("not yet implemented")}eval(t){return this.#ie=this.evalInternal(t),this.#ie}evalAsDataType(t){const e=this.eval(t);if(!e)return null;const n=e.asDataType;return n||(this.typeError("not a data type"),null)}evalAsType(t){const e=this.eval(t);if(!e)return null;const n=e.asType;return n||(this.typeError(`${e.toString()} isn't a type`),null)}evalAsTyped(t){const e=this.eval(t);if(!e)return null;const n=e.asTyped;return n||(this.typeError(`${e.toString()} isn't a value`),null)}isLiteral(){return!1}toIR(t){throw new Error("not yet implemented")}toString(){throw new Error("not yet implemented")}}export class RefExpr extends Expr{#i;constructor(t){super(t.site),this.#i=t}evalInternal(t){return t.get(this.#i)}toIR(t){const e=this.cache?.asNamed?this.cache.asNamed.path:this.#i.value;return new IR(e,this.site)}toString(){return this.#i.toString()}}export class PathExpr extends Expr{#oe;#_e;constructor(t,e,n){super(t),this.#oe=e,this.#_e=n}get baseExpr(){return this.#oe}evalInternal(t){const e=this.#oe.eval(t);if(!e)return null;let n=null;if(e.asNamespace)n=e.asNamespace.namespaceMembers[this.#_e.value];else if(e.asType){n=e.asType.typeMembers[this.#_e.value]}return n?n.asType?.toTyped().asFunc?n.asType.toTyped():n:(this.#_e.referenceError(`${e.toString()}::${this.#_e.value} not found`),null)}toIR(t){const e=this.cache;if(e?.asNamed)return new IR(`${e.asNamed.path}`,this.site);if(this.#oe.cache?.asNamed)return new IR(`${this.#oe.cache.asNamed.path}__${this.#_e.value}`,this.site);throw new Error(`expected named value, ${e?.toString()}`)}toString(){return`${this.#oe.toString()}::${this.#_e.toString()}`}}export class ValuePathExpr extends PathExpr{constructor(t,e,n){super(t,e,n)}evalInternal(t){const e=super.evalInternal(t);return e?e.asEnumMemberType&&0==e.asEnumMemberType.fieldNames.length?new DataEntity(e.asEnumMemberType):e:null}isLiteral(){return 0==(this.cache?.asTyped?.type.asEnumMemberType?.fieldNames?.length??-1)}toIR(t){const e=this.cache;return e?.asTyped?.type?.asEnumMemberType&&0==e.asTyped.type.asEnumMemberType.fieldNames.length?new IR([new IR(`${e.asTyped.type.asEnumMemberType.path}____new`,this.site),new IR("()")]):super.toIR(t)}}export class ListTypeExpr extends Expr{#le;constructor(t,e){super(t),this.#le=e}evalInternal(t){const e=this.#le.eval(t);if(!e)return null;const n=e.asType;return n?ListType$(n):(this.#le.typeError(`'${e.toString()}' isn't a type`),null)}toString(){return`[]${this.#le.toString()}`}}export class MapTypeExpr extends Expr{#ue;#ce;constructor(t,e,n){super(t),this.#ue=e,this.#ce=n}evalInternal(t){const e=this.#ue.eval(t);if(!e)return null;const n=e.asType;if(!n)return this.#ue.typeError("map key type not a type"),null;const r=this.#ce.eval(t);if(!r)return null;const s=r.asType;return s?MapType$(n,s):(this.#ce.typeError("map value type not a type"),null)}toString(){return`Map[${this.#ue.toString()}]${this.#ce.toString()}`}}export class IteratorTypeExpr extends Expr{#pe;constructor(t,e){super(t),this.#pe=e}evalInternal(t){const e=reduceNull(this.#pe.map((e=>{const n=e.eval(t);if(!n)return null;const r=n.asType;return r||(e.typeError("not a type"),null)})));return null===e?null:e.length>10?(this.site.typeError("too many Iterator type args (limited to 10)"),null):IteratorType$(e)}toString(){return`Iterator[${this.#pe.map((t=>t.toString())).join(", ")}]`}}export class OptionTypeExpr extends Expr{#he;constructor(t,e){super(t),this.#he=e}evalInternal(t){const e=this.#he.evalAsType(t);return e?OptionType$(e):null}toString(){return`Option[${this.#he.toString()}]`}}export class VoidTypeExpr extends Expr{constructor(t){super(t)}evalInternal(t){return new VoidType}toString(){return"()"}}export class TupleTypeExpr extends Expr{#pe;constructor(t,e){super(t),this.#pe=e}evalInternal(t){const e=reduceNull(this.#pe.map((e=>{const n=e.eval(t);if(!n)return null;const r=n.asType;return r||(e.typeError("not a type"),null)})));return null===e?null:e.length>10?(this.site.typeError("too many Type type args (limited to 10)"),null):TupleType$(e)}toString(){return`(${this.#pe.map((t=>t.toString())).join(", ")})`}}export class FuncArgTypeExpr extends Token{#i;#de;optional;constructor(t,e,n,r){super(t),this.#i=e,this.#de=n,this.optional=r}isNamed(){return null==this.#i}isOptional(){return this.optional}eval(t){const e=this.#de.eval(t);if(!e)return null;const n=e.asType;return n?new ArgType(this.#i,n,this.optional):(this.#de.typeError(`'${e.toString()}' isn't a type`),null)}toString(){return[null!=this.#i?`${this.#i.toString()}: `:"",this.optional?"?":"",this.#de.toString()].join("")}}export class FuncTypeExpr extends Expr{#me;#fe;constructor(t,e,n){super(t),this.#me=e,this.#fe=n}evalInternal(t){const e=this.#me.map((e=>e.eval(t))),n=this.#fe.eval(t);if(!n)return null;const r=n.asType;if(!r)return this.#fe.typeError("return type isn't a type"),null;const s=reduceNull(e);return null===s?null:new FuncType(s,r)}toString(){return`(${this.#me.map((t=>t.toString())).join(", ")}) -> ${this.#fe.toString()}`}}export class ChainExpr extends Expr{upstreamExpr;downstreamExpr;constructor(t,e,n){super(t),this.upstreamExpr=e,this.downstreamExpr=n}toString(){return`${this.upstreamExpr.toString()}; ${this.downstreamExpr.toString()}`}evalInternal(t){const e=this.upstreamExpr.eval(t);if(e){const t=e.asTyped;t?(new ErrorType).isBaseOf(t.type)?this.downstreamExpr.typeError("unreachable code (upstream always throws error)"):(new VoidType).isBaseOf(t.type)||this.upstreamExpr.typeError("unexpected return value (hint: use '='"):this.upstreamExpr.typeError("upstream isn't typed")}return this.downstreamExpr.eval(t)}toIR(t){return new IR([new IR("__core__chooseUnit(",this.site),this.upstreamExpr.toIR(t),new IR(", "),this.downstreamExpr.toIR(t),new IR(")")])}}export class AssignExpr extends ChainExpr{#ye;constructor(t,e,n,r){super(t,assertDefined(n),assertDefined(r)),this.#ye=assertDefined(e)}evalInternal(t){const e=new Scope(t,t.allowShadowing);let n=this.upstreamExpr.eval(t);if(n&&n.asTyped)if(this.#ye.hasType()||this.#ye.isTuple())this.#ye.evalInAssignExpr(e,assertDefined(n.asTyped.type.asType),0);else if(this.upstreamExpr.isLiteral()||t.has(this.#ye.name)){if(this.upstreamExpr instanceof CallExpr&&this.upstreamExpr.fnExpr instanceof PathExpr||this.upstreamExpr instanceof PathExpr&&!this.upstreamExpr.isLiteral()){const t=n.asTyped.type;t.asEnumMemberType&&(n=new DataEntity(t.asEnumMemberType.parentType))}e.set(this.#ye.name,n)}else this.typeError("unable to infer type of assignment rhs");else this.#ye.hasType()?this.#ye.evalInAssignExpr(e,null,0):(this.upstreamExpr.typeError("rhs isn't an instance"),e.set(this.#ye.name,new DataEntity(new AnyType)));const r=this.downstreamExpr.eval(e);return e.assertAllUsed(),r}toIR(t){let e=this.downstreamExpr.toIR(t.tab());if(this.#ye.isTuple()&&this.#ye.isIgnored()){for(let n=this.#ye.children.length-1;n>=0;n--)e=this.#ye.children[n].wrapDestructIR(t,e,n);return new IR([this.upstreamExpr.toIR(t),new IR(`(\n${t.indent+TAB}(`),new IR(this.#ye.children.map(((t,e)=>t.toNameIR(e)))).join(", "),new IR(") ->",this.site),new IR(` {\n${t.indent}${TAB}${TAB}`),e,new IR(`\n${t.indent+TAB}}\n${t.indent})`)])}{e=this.#ye.wrapDestructIR(t,e,0);let n=this.upstreamExpr.toIR(t);if(this.#ye.hasType()){const t=assertDefined(this.#ye.type);t.asEnumMemberType&&(n=new IR([new IR("__helios__common__assert_constr_index("),n,new IR(`, ${t.asEnumMemberType.constrIndex})`)]))}return new IR([new IR("("),this.#ye.toNameIR(0),new IR(") "),new IR("->",this.site),new IR(` {\n${t.indent}${TAB}`),e,new IR(`\n${t.indent}}(`),n,new IR(")")])}}toString(){let t=this.downstreamExpr.toString();return assert(null!=t),`${this.#ye.toString()} = ${this.upstreamExpr.toString()}; ${t}`}}export class VoidExpr extends Expr{constructor(t){super(t)}evalInternal(t){return new VoidEntity}toIR(t){return new IR("()",this.site)}toString(){return"()"}}export class PrimitiveLiteralExpr extends Expr{#ge;constructor(t){super(t.site),this.#ge=t}get type(){if(this.#ge instanceof IntLiteral)return IntType;if(this.#ge instanceof RealLiteral)return RealType;if(this.#ge instanceof BoolLiteral)return BoolType;if(this.#ge instanceof StringLiteral)return StringType;if(this.#ge instanceof ByteArrayLiteral)return ByteArrayType;throw new Error("unhandled primitive type")}evalInternal(t){return new DataEntity(this.type)}isLiteral(){return!0}toIR(t){return new IR(this.#ge.toString(),this.#ge.site)}toString(){return this.#ge.toString()}}export class LiteralDataExpr extends Expr{#f;#mt;constructor(t,e,n){super(t),this.#f=e,this.#mt=n}get type(){return this.#f}isLiteral(){return!0}evalInternal(t){return new DataEntity(this.#f)}get cache(){return new DataEntity(this.#f)}toIR(t){return new IR(this.toString(),this.site)}toString(){return`##${bytesToHex(this.#mt.toCbor())}`}}export class StructLiteralField{#i;#m;constructor(t,e){this.#i=t,this.#m=e}get name(){if(null===this.#i)throw new Error("name of field not given");return this.#i}get site(){return null===this.#i?this.#m.site:this.#i.site}eval(t){return this.#m.eval(t)}isNamed(){return null!==this.#i}toIR(t){return this.#m.toIR(t)}toString(){return null===this.#i?this.#m.toString():`${this.#i.toString()}: ${this.#m.toString()}`}}export class StructLiteralExpr extends Expr{#de;#y;constructor(t,e){super(t.site),this.#de=t,this.#y=e}evalInternal(t){const e=this.#de.eval(t);if(!e)return null;const n=e.asDataType;if(!n)return this.#de.typeError(`'${this.#de.toString()}' doesn't evaluate to a data type`),null;if(n.fieldNames.length!=this.#y.length)return this.typeError(`wrong number of fields for ${n.toString()}, expected ${n.fieldNames.length}, got ${this.#y.length}`),null;const r=t=>{const e=n.instanceMembers[t.value];if(!e)return t.typeError(`member '${t.value}' not defined`),null;const r=e.asType;return r||(t.typeError(`member '${t.value}' isn't a type`),null)};for(let e=0;e<this.#y.length;e++){const s=this.#y[e],a=s.eval(t);if(!a)return null;const i=a.asTyped;if(!i)return s.site.typeError("not typed"),null;if(s.isNamed()){if(-1==n.fieldNames.findIndex((t=>t==s.name.value)))return s.name.site.typeError("not a valid field"),null;const t=r(s.name);if(!t)continue;if(!t.isBaseOf(i.type))return s.site.typeError(`wrong field type for '${s.name.toString()}', expected ${t.toString()}, got ${i.type.toString()}`),null}else{const t=r(new Word(s.site,n.fieldNames[e]));if(!t)continue;if(!t.isBaseOf(i.type))return s.site.typeError(`wrong field type for field ${e.toString()}, expected ${t.toString()}, got ${i.type.toString()}`),null}}return new DataEntity(n)}isLiteral(){return!0}isNamed(){return this.#y.length>0&&this.#y[0].isNamed()}static toIRInternal(t,e,n,r){return new IR([new IR(`${n}____new`),new IR("("),new IR(r).join(", "),new IR(")")],e)}toIR(t){const e=assertDefined(this.#de.cache?.asDataType),n=this.#y.slice();this.isNamed()&&n.sort(((t,n)=>e.fieldNames.findIndex((e=>e==t.name.value))-e.fieldNames.findIndex((t=>t==n.name.value))));const r=n.map((e=>e.toIR(t)));return StructLiteralExpr.toIRInternal(t,this.site,e.path,r)}toString(){return`${this.#de.toString()}{${this.#y.map((t=>t.toString())).join(", ")}}`}}export class ListLiteralExpr extends Expr{#le;#we;constructor(t,e,n){super(t),this.#le=e,this.#we=n}get itemType(){return assertDefined(this.#le.cache?.asDataType)}evalInternal(t){const e=this.#le.eval(t);if(!e)return null;const n=e.asDataType;if(!n)return this.#le.typeError("content of list can't be func"),null;for(let e of this.#we){const r=e.eval(t);if(!r)continue;const s=r.asTyped;s?n.isBaseOf(s.type)||e.typeError(`expected ${n.toString()}, got ${s.type.toString()}`):e.typeError("not typed")}return new DataEntity(ListType$(n))}isLiteral(){return!0}toIR(t){let e=new IR("__core__mkNilData(())");for(let n=this.#we.length-1;n>=0;n--){let r=new IR([new IR(`${this.itemType.path}____to_data`),new IR("("),this.#we[n].toIR(t),new IR(")")]);e=new IR([new IR("__core__mkCons"),new IR("("),r,new IR(", "),e,new IR(")")])}return e}toString(){return`[]${this.#le.toString()}{${this.#we.map((t=>t.toString())).join(", ")}}`}}export class MapLiteralExpr extends Expr{#ue;#ce;#Te;constructor(t,e,n,r){super(t),this.#ue=e,this.#ce=n,this.#Te=r}get keyType(){return assertDefined(this.#ue.cache?.asDataType)}get valueType(){return assertDefined(this.#ce.cache?.asDataType)}evalInternal(t){const e=this.#ue.eval(t);if(!e)return null;const n=e.asDataType;if(!n)return this.#ue.typeError("key-type of Map can't be func"),null;const r=this.#ce.eval(t);if(!r)return null;const s=r.asDataType;if(!s)return this.#ce.typeError("value-type of Map can't be func"),null;for(let[e,r]of this.#Te){const a=e.eval(t);if(!a)continue;const i=a.asTyped;if(!i){e.typeError("not typed");continue}const o=r.eval(t);if(!o)continue;const _=o.asTyped;_?n.isBaseOf(i.type)?s.isBaseOf(_.type)||r.typeError(`expected ${s.toString()} for map value, got ${_.toString()}`):e.typeError(`expected ${n.toString()} for map key, got ${i.toString()}`):r.typeError("not typed")}return new DataEntity(MapType$(n,s))}isLiteral(){return!0}toIR(t){let e=new IR("__core__mkNilPairData(())");for(let n=this.#Te.length-1;n>=0;n--){let[r,s]=this.#Te[n],a=new IR([new IR(`${this.keyType.path}____to_data`),new IR("("),r.toIR(t),new IR(")")]),i=new IR([new IR(`${this.valueType.path}____to_data`),new IR("("),s.toIR(t),new IR(")")]);e=new IR([new IR("__core__mkCons("),new IR("__core__mkPairData("),a,new IR(","),i,new IR(")"),new IR(", "),e,new IR(")")],this.site)}return e}toString(){return`Map[${this.#ue.toString()}]${this.#ce.toString()}{${this.#Te.map((([t,e])=>`${t.toString()}: ${e.toString()}`)).join(", ")}}`}}export class NameTypePair{#i;#de;constructor(t,e){this.#i=t,this.#de=e}get site(){return this.#i.site}get name(){return this.#i}get type(){if(this.isIgnored())return new AllType;if(null===this.#de)throw new Error("typeExpr not set in "+this.site.src.raw.split("\n")[0]);return this.#de.cache?.asType??new AllType}get typeExpr(){return this.#de}get typeName(){return null===this.#de?"":this.#de.toString()}isIgnored(){return"_"===this.name.value}hasType(){return null!==this.#de}evalType(t){if(this.isIgnored())return new AllType;if(null===this.#de)throw new Error("typeExpr not set in "+this.site.src.raw.split("\n")[0]);{const e=this.#de.eval(t);return e?e.asType?e.asType:(this.#de.typeError(`'${e.toString()} isn't a valid type`),null):null}}toIR(){return new IR(this.#i.toString(),this.#i.site)}toString(){return null===this.#de?this.name.toString():`${this.name.toString()}: ${this.#de.toString()}`}}export class ParametricExpr extends Expr{#oe;#Xt;constructor(t,e,n){super(t),this.#oe=e,this.#Xt=n}get paramTypes(){return this.#Xt.map((t=>{const e=t.cache?.asType;if(!e)throw new Error("not a type");return e}))}evalInternal(t){const e=reduceNull(this.#Xt.map((e=>e.evalAsType(t)))),n=this.#oe.eval(t);return n?n.asParametric?null===e?null:n.asParametric.apply(e,this.site):(this.site.typeError(`'${n.toString()}' isn't a parametric type`),null):null}static toApplicationIR(t){return`[${t.map((t=>t instanceof FuncType?"__fn":assertDefined(t.asNamed).path)).join("@")}]`}toIR(t){const e=ParametricExpr.toApplicationIR(this.paramTypes);return this.#oe instanceof MemberExpr?this.#oe.toIR(t,e):IR.new`${this.#oe.toIR(t).toString()}${e}${this.site}`}toString(){return`${this.#oe.toString()}[${this.#Xt.map((t=>t.toString())).join(", ")}]`}}export class UnaryExpr extends Expr{#be;#V;constructor(t,e){super(t.site),this.#be=t,this.#V=e}translateOp(){const t=this.#be.toString(),e=this.#be.site;if("+"==t)return new Word(e,"__pos");if("-"==t)return new Word(e,"__neg");if("!"==t)return new Word(e,"__not");throw new Error("unhandled unary op")}evalInternal(t){const e=this.#V.eval(t);if(!e)return null;const n=e.asInstance;if(!n)return this.#V.site.typeError("not an instance"),null;const r=this.translateOp().value,s=n.type.typeMembers[r]?.asType?.toTyped()?.asFunc;return s?s.asFunc.call(this.#be.site,[n]):(this.#V.site.typeError(`'${this.#be.toString()} ${n.type.toString()}' undefined`),null)}toIR(t){const e=assertDefined(this.cache?.asTyped?.type?.asNamed).path;return IR.new`${e}__${this.translateOp().value}${this.site}(${this.#V.toIR(t)})`}toString(){return`${this.#be.toString()}${this.#V.toString()}`}}export const BINARY_SYMBOLS_MAP={"||":"__or","&&":"__and","==":"__eq","!=":"__neq","<":"__lt","<=":"__leq",">":"__gt",">=":"__geq","+":"__add","-":"__sub","*":"__mul","/":"__div","%":"__mod"};export class BinaryExpr extends Expr{#be;#V;#O;#xe;#Ie;constructor(t,e,n){super(t.site),this.#be=t,this.#V=e,this.#O=n,this.#xe=!1,this.#Ie=0}get first(){return this.#xe?this.#O:this.#V}get second(){return this.#xe?this.#V:this.#O}toString(){return`${this.#V.toString()} ${this.#be.toString()} ${this.#O.toString()}`}translateOp(t=0){const e=this.#be.toString(),n=this.#be.site;let r=BINARY_SYMBOLS_MAP[e];if(!r)throw new Error("unhandled");return t>0&&(r+=t.toString()),new Word(n,r)}isCommutative(){switch(this.#be.toString()){case"+":case"*":case"==":case"!=":return!0;default:return!1}}evalInternal(t){const e=this.#V.eval(t),n=this.#O.eval(t);if(!e||!n)return null;const r=e.asInstance;if(!r)return this.#V.typeError(`lhs of ${this.#be.toString()} not an instance`),null;const s=n.asInstance;if(!s)return this.#O.typeError(`rhs of ${this.#be.toString()} not an instance`),null;for(let t of this.isCommutative()?[!1,!0]:[!1])for(let e of[0,1,2]){let n=t?s:r,a=t?r:s;const i=n.type.typeMembers[this.translateOp(e).value];let o=i?.asType?.toTyped()?.asFunc;if(o&&(o.funcType.argTypes[0].isBaseOf(n.type)&&o.funcType.argTypes[1].isBaseOf(a.type))){let r=o.call(this.#be.site,[n,a]);return this.#xe=t,this.#Ie=e,r}}return this.typeError(`'${r.type.toString()} ${this.#be.toString()} ${s.type.toString()}' undefined`),null}toIR(t){let e=assertDefined(this.first.cache?.asTyped?.type.asNamed).path,n=this.translateOp(this.#Ie).value;return new IR("__and"==n||"__or"==n?[new IR(`${e}${n}`,this.site),new IR(`(\n${t.indent}${TAB}() -> {`),this.first.toIR(t.tab()),new IR(`},\n${t.indent}${TAB}() -> {`),this.second.toIR(t.tab()),new IR(`}\n${t.indent})`)]:[new IR(`${e}__${n}`,this.site),new IR("(",this.site),this.first.toIR(t),new IR(", "),this.second.toIR(t),new IR(")")])}}export class ParensExpr extends Expr{#Ee;constructor(t,e){super(t),this.#Ee=e}isLiteral(){return this.#Ee.every((t=>t.isLiteral()))}evalInternal(t){if(1===this.#Ee.length)return this.#Ee[0].eval(t);{const e=reduceNull(this.#Ee.map((e=>{const n=e.eval(t);if(!n)return null;const r=n.asTyped;return r?(new ErrorType).isBaseOf(r.type)?(e.site.typeError("unexpected error call in multi-valued expression"),null):r.type:(e.site.typeError("not typed"),null)})));return null===e?null:TupleType$(e).toTyped()}}toIR(t){return 1===this.#Ee.length?this.#Ee[0].toIR(t):new IR([new IR(`(callback) -> {\n${t.indent+TAB}callback(\n${t.indent+TAB+TAB}`,this.site)].concat(new IR(this.#Ee.map((e=>e.toIR(t.tab().tab())))).join(`,\n${t.indent+TAB+TAB}`)).concat([new IR(`\n${t.indent+TAB})\n${t.indent}}`)]))}toString(){return`(${this.#Ee.map((t=>t.toString())).join(", ")})`}}export class CallArgExpr extends Token{#i;#Ce;constructor(t,e,n){super(t),this.#i=e,this.#Ce=n}get name(){return this.#i?.toString()??""}get valueExpr(){return this.#Ce}get value(){return assertDefined(this.#Ce.cache)}isNamed(){return null!=this.#i}isLiteral(){return this.#Ce.isLiteral()}toString(){return[null!=this.#i?`${this.#i.toString()}: `:"",this.#Ce.toString()].join("")}eval(t){return this.#Ce.eval(t)}}export class CallExpr extends Expr{#Se;#ve;#Re;#Pe;constructor(t,e,n){super(t),this.#Se=e,this.#ve=n,this.#Re=[],this.#Pe=null}get fnExpr(){return this.#Se}toString(){return`${this.#Se.toString()}(${this.#ve.map((t=>t.toString())).join(", ")})`}isLiteral(){return!!(this.#Se instanceof PathExpr&&this.cache?.asTyped&&this.#Se.baseExpr.cache?.asType?.isBaseOf(this.cache.asTyped.type))}evalInternal(t){const e=this.#Se.eval(t),n=reduceNull(this.#ve.map(((e,n)=>{const r=e.eval(t);if(!r)return null;const s=r.asTyped;return s||(e.typeError(`arg ${n+1} not an instance`),null)})));if(!e||null===n)return null;const r=[];this.#ve.forEach(((t,e)=>{t.isNamed()||r.push(n[e])}));const s={};return this.#ve.forEach(((t,e)=>{if(t.isNamed()){const r=n[e];if(!r.asTyped)throw new Error("unexpected");s[t.name]=r.asTyped}})),assert(r.every((t=>null!=t))),e.asParametric?(this.#Re=[],this.#Pe=e.asParametric.inferCall(this.site,r,s,this.#Re),this.#Pe.call(this.site,r,s)):e.asFunc?e.asFunc.call(this.site,r,s):(this.#Se.typeError(`unable to call ${e.toString()} (returned by ${this.#Se.toString()})`),null)}get fn(){return this.#Se.cache?.asParametric?assertClass(this.#Pe?.type?.asType,FuncType):assertClass(this.#Se.cache?.asTyped?.type.asType,FuncType)}expandArgs(t){const e=this.fn,n=e.nNonOptArgs,r=[];this.#ve.forEach((t=>{t.isNamed()||r.push(t.valueExpr)}));const s=[];this.#ve.forEach((a=>{if(a.isNamed()){const i=e.getNamedIndex(a.site,a.name);i<n?r[i]=a.valueExpr:s[i-n]=new IR([new IR("true"),new IR(", "),a.valueExpr.toIR(t)])}}));for(let t=n;t<e.nArgs;t++)null==s[t-n]&&(s[t-n]=new IR([new IR("false"),new IR(", "),new IR("()")]));return[r.filter((t=>null!=t)),s]}toFnExprIR(t){if(this.#Se.cache?.asParametric instanceof ParametricFunc){assert(this.#Re.length>0);const e=ParametricExpr.toApplicationIR(this.#Re);return this.#Se instanceof MemberExpr?this.#Se.toIR(t,e):new IR(`${this.#Se.toIR(t).toString()}${e}`,this.#Se.site)}return this.#Se.toIR(t)}detectExpandedTuples(t){const e=new Map,n=reduceNull(t.map((t=>t.cache?.asTyped??null)));if(!n)return t.forEach((t=>{e.set(t,0)})),e;const r=this.fn.expandTuplesInPosArgs(n);let s=0;for(let a=0;a<n.length;a++){if(s>=r.length)throw new Error("unexpected");if(n[a]==r[s])e.set(t[a],0),s++;else{const r=getTupleItemTypes(n[a].type);if(!r)throw new Error("unexpected");e.set(t[a],r.length),s+=r.length}}return e}toIR(t){let e=this.toFnExprIR(t);const n=this.fn,[r,s]=this.expandArgs(t),a=this.detectExpandedTuples(r);if(r.some((t=>(a.get(t)??0)>0))){let i=0;r.forEach(((t,e)=>{(a.get(t)??0)>0?i+=assertDefined(a.get(t)):i+=1})),i+=s.length,i>n.nArgs&&s.splice(0,i-n.nArgs);let o=[];for(let t=0;t<n.nArgs;t++)t>=n.nNonOptArgs&&o.push(`__useopt__x${t}`),o.push(`x${t}`);let _=new IR([e,new IR("("),new IR(o.map((t=>new IR(t)))).join(", "),new IR(")",this.site)]);for(let t of s.slice().reverse()){const e=assertDefined(o.pop()),n=assertDefined(o.pop());assert(n.startsWith("__useopt__")),_=new IR([new IR("("),new IR(n),new IR(", "),new IR(e),new IR(") -> {"),_,new IR("}("),assertDefined(t),new IR(")")])}for(let e=r.length-1;e>=0;e--){const n=r[e];if((a.get(n)??0)>0){const e=assertDefined(a.get(n)),r=[],s=[];for(;r.length<e;)r.unshift(assertDefined(o.pop())),o.length>0&&o[o.length-1]==`__useopt__${r[0]}`&&s.unshift(assertDefined(o.pop()));s.length>0&&(_=new IR([new IR("("),new IR(s.map((t=>new IR(t)))).join(", "),new IR(") -> {"),_,new IR("}("),new IR(s.map((t=>new IR("true")))).join(", "),new IR(")")])),_=new IR([n.toIR(t),new IR("(("),new IR(r.map((t=>new IR(t)))).join(", "),new IR(") -> {"),_,new IR("})")])}else{const e=assertDefined(o.pop());o.length>0&&o[o.length-1]==`__useopt__${e}`&&(_=new IR([new IR("("),new IR(assertDefined(o.pop())),new IR(") -> {"),new IR("}(true)")])),_=new IR([new IR("("),new IR(e),new IR(") -> {"),_,new IR("}("),n.toIR(t),new IR(")")])}}return _}{r.length+s.length>n.nArgs&&s.splice(0,r.length+s.length-n.nArgs);let a=r.map(((e,r)=>{let s=e.toIR(t);return r>=n.nNonOptArgs&&(s=new IR([new IR("true, "),s])),s})).concat(s);return new IR([e,new IR("(",this.site),new IR(a).join(", "),new IR(")")])}}}export class MemberExpr extends Expr{#De;#_e;constructor(t,e,n){super(t),this.#De=e,this.#_e=n}evalInternal(t){const e=this.#De.eval(t);if(!e)return null;const n=e.asInstance;if(!n)return this.#De.site.typeError("lhs of '.' not an instance"),null;let r=n.instanceMembers[this.#_e.value];if(!r&&(n?.type?.asEnumMemberType&&(r=n.type.asEnumMemberType.parentType.instanceMembers[this.#_e.value]),!r))return this.#_e.referenceError(`'${n.type.toString()}.${this.#_e.value}' undefined`),null;if(r.asParametric)return r;if(r.asType){return r.asType.toTyped()}throw new Error("expected type or parametric")}toIR(t,e=""){const n=assertDefined(this.#De.cache?.asTyped?.type?.asNamed);let r=n.path;n.asEnumMemberType&&void 0===n.asEnumMemberType.instanceMembers[this.#_e.value]&&(r=n.asEnumMemberType.parentType.path);let s=new IR(`${r}__${this.#_e.toString()}${e}`,this.site);return new IR([s,new IR("("),this.#De.toIR(t),new IR(")")])}toString(){return`${this.#De.toString()}.${this.#_e.toString()}`}}export class IfElseExpr extends Expr{#Fe;#$e;constructor(t,e,n){assert(n.length==e.length+1),assert(n.length>1),super(t),this.#Fe=e,this.#$e=n}toString(){let t="";for(let e=0;e<this.#Fe.length;e++)t+=`if (${this.#Fe[e].toString()}) {${this.#$e[e].toString()}} else `;return t+=`{${this.#$e[this.#Fe.length].toString()}}`,t}static reduceBranchType(t,e,n){if(null===e||e instanceof ErrorType)return n;if(n instanceof ErrorType)return e;if(e.isBaseOf(n))return e;if(n.isBaseOf(e))return n;{if(n.asEnumMemberType){const t=n.asEnumMemberType.parentType;if(t.isBaseOf(e)&&t.isBaseOf(n))return t}const r=getTupleItemTypes(e),s=getTupleItemTypes(n);if(r&&s&&r.length==s.length){const e=reduceNull(r.map(((e,n)=>IfElseExpr.reduceBranchType(t,e,s[n]))));if(e)return TupleType$(e)}return t.typeError("inconsistent types"),null}}static reduceBranchMultiType(t,e,n){if(n.asTyped&&(new ErrorType).isBaseOf(n.asTyped.type))return e;const r=assertDefined(n.asTyped).type;return null===e?r:IfElseExpr.reduceBranchType(t,e,r)}evalInternal(t){for(let e of this.#Fe){const n=e.eval(t);if(!n)continue;const r=n.asTyped;r&&BoolType.isBaseOf(r.type)||e.typeError("expected bool")}let e=null;for(let n of this.#$e){const r=new Scope(t,!1),s=n.evalAsTyped(r);s&&(e=IfElseExpr.reduceBranchMultiType(n.site,e,s))}return null===e?new ErrorEntity:e.toTyped()}toIR(t){let e=this.#Fe.length,n=new IR([new IR("() -> {"),this.#$e[e].toIR(t),new IR("}")]);for(let r=e-1;r>=0;r--)n=new IR([new IR("__core__ifThenElse("),this.#Fe[r].toIR(t),new IR(", () -> {"),this.#$e[r].toIR(t),new IR("}, () -> {"),n,new IR("()})")]);return new IR([n,new IR("()",this.site)])}}export class DestructExpr{#i;#de;#ke;#Be;constructor(t,e,n=[],r=!1){this.#i=assertDefined(t),this.#de=e,this.#ke=n,this.#Be=r,r?assert(this.#ke.length>0&&null==this.#de):assert(!(null==this.#de&&this.#ke.length>0),`unexpected syntax: ${this.toString()}`)}get site(){return this.#i.site}get name(){return this.#i}get children(){return this.#ke}isTuple(){return this.#Be}hasDestructExprs(){return this.#ke.length>0}isIgnored(){return"_"===this.name.value}hasType(){return null!==this.#de}get type(){if(null===this.#de){if(this.#Be){const t=reduceNull(this.#ke.map((t=>t.type)));return t?TupleType$(t):(this.site.typeError("invalid nested tuple in in destruct expression"),null)}return this.isIgnored()?new AllType:null}return this.#de.cache?.asType?this.#de.cache.asType:(this.#de.typeError(`invalid type '${assertDefined(this.#de.cache,"cache unset").toString()}'`),null)}get typeName(){return null===this.#de?new Word(this.site,""):new Word(this.#de.site,this.#de.toString())}toString(){if(null===this.#de)return this.#ke.length>0&&this.#Be?`${this.name.toString()}: (${this.#ke.map((t=>t.toString())).join(", ")})`:this.name.toString();{let t="";return this.#ke.length>0&&(t=`{${this.#ke.map((t=>t.toString())).join(", ")}}`),this.isIgnored()?`${this.#de.toString()}${t}`:`${this.name.toString()}: ${this.#de.toString()}${t}`}}evalType(t,e=null){if(null===this.#de){if(this.#Be){const n=e?getTupleItemTypes(e):null,r=reduceNull(this.#ke.map(((e,r)=>e.evalType(t,n?n[r]:null))));return r?TupleType$(r):(this.site.typeError("invalid nested tuple in in destruct expression"),null)}if(this.isIgnored())return new AllType;throw new Error("typeExpr not set in "+this.site.src.raw.split("\n")[0])}{const n=this.#de.evalAsType(t);return n&&e&&!e.asEnumMemberType&&n.asEnumMemberType?n.asEnumMemberType.parentType:n}}evalDestructExprs(t,e){if(this.#ke.length>0)if(this.#Be){const n=getTupleItemTypes(e);if(!n)return void this.site.typeError("upstream value isn't a tuple, can't destruct");if(n.length!=this.#ke.length)return void this.site.typeError(`wrong number of destruct tuple fields, expected ${n.length}, got ${this.#ke.length}`);for(let e=0;e<this.#ke.length;e++)this.#ke[e].evalInternal(t,n[e],e)}else{if(!e.asDataType)return void this.site.typeError("can't destruct a function");const n=e.asDataType.fieldNames;if(n.length!=this.#ke.length)return void this.site.typeError(`wrong number of destruct fields, expected ${n.length}, got ${this.#ke.length}`);for(let r=0;r<this.#ke.length;r++)this.#ke[r].evalInternal(t,assertDefined(e.instanceMembers[n[r]].asDataType),r)}}evalInternal(t,e,n){if(this.hasType()){const r=this.evalType(t);if(!r)return;let s=r;if(r.asEnumMemberType&&!e.asEnumMemberType&&(s=r.asEnumMemberType.parentType),!s.isBaseOf(e))return this.site.typeError(`expected ${s.toString()} for destructure field ${n+1}, got ${e.toString()}`),null;this.isIgnored()||t.set(this.name,r.toTyped()),this.evalDestructExprs(t,r)}else this.isIgnored()||t.set(this.name,e.toTyped()),this.evalDestructExprs(t,e)}evalInSwitchCase(t,e){this.isIgnored()||t.set(this.#i,e.toTyped()),this.#de&&(this.#de.cache=e),this.evalDestructExprs(t,e)}evalInAssignExpr(t,e,n){const r=this.evalType(t);if(!r)return void t.set(this.name,new DataEntity(new AnyType));const s=this.evalType(t,e);s&&e&&(s.isBaseOf(e)||this.site.typeError(`expected ${s.toString()} for rhs ${n+1}, got ${e.toString()}`)),this.isIgnored()||t.set(this.name,r.toTyped()),this.evalDestructExprs(t,r)}toNameIR(t){return this.isIgnored()?new IR(`__lhs_${t}`):new IR(this.#i.toString(),this.#i.site)}getFieldFn(t){const e=assertDefined(this.type);return e.asDataType?`${e.asDataType.path}__${e.asDataType.fieldNames[t]}`:""}wrapDestructIRInternal(t,e,n,r,s){if(this.isIgnored()&&0==this.#ke.length)return e;{const a=this.isIgnored()?`${n}_${r}`:this.#i.toString();for(let n=this.#ke.length-1;n>=0;n--){const r=this.#ke[n],s=this.#Be?r.toNameIR(n).toString():`${this.getFieldFn(n)}(${a})`;e=r.wrapDestructIRInternal(t.tab(),e,a,n,s)}this.#Be&&(e=IR.new`${a}(
					(${new IR(this.#ke.map(((t,e)=>t.toNameIR(e)))).join(", ")}) -> {
						${e}
					}
				)`);let i=s;const o=this.type;if(this.#de&&o&&o.asEnumMemberType){i=`__helios__common__assert_constr_index(${i}, ${o.asEnumMemberType.constrIndex})`}return new IR([new IR("("),new IR(a,this.#i.site),new IR(") "),new IR("->",this.site),new IR(` {\n${t.indent}${TAB}`),e,new IR(`\n${t.indent}}(${i})`)])}}wrapDestructIR(t,e,n){if(0==this.#ke.length)return e;{const r=this.isIgnored()?`__lhs_${n}`:this.#i.toString();for(let n=this.#ke.length-1;n>=0;n--){const s=this.#ke[n],a=this.#Be?s.toNameIR(n).toString():`${this.getFieldFn(n)}(${r})`;e=s.wrapDestructIRInternal(t.tab(),e,r,n,a)}return this.#Be?IR.new`${r}(
					(${new IR(this.#ke.map(((t,e)=>t.toNameIR(e)))).join(", ")}) -> {
						${e}
					}
				)`:e}}toIR(){return new IR(this.#i.toString(),this.#i.site)}}export class SwitchCase extends Token{#Ae;#Me;#Ot;constructor(t,e,n){super(t),this.#Ae=e,this.#Me=n,this.#Ot=null}get body(){return this.#Me}get memberName(){return this.#Ae.typeName}isDataMember(){switch(this.memberName.value){case"Int":case"[]Data":case"ByteArray":case"Map[Data]Data":return!0;default:return!1}}get constrIndex(){if(null===this.#Ot)throw new Error("constrIndex not yet set");return this.#Ot}toString(){return`${this.#Ae.toString()} => ${this.#Me.toString()}`}evalEnumMember(t,e){const n=e.typeMembers[this.memberName.value]?.asEnumMemberType;if(!n)return this.memberName.typeError(`${this.memberName.value} isn't a valid enum member of ${e.toString()}`),null;this.#Ot=n.constrIndex,assert(this.#Ot>=0);const r=new Scope(t,!1);this.#Ae.evalInSwitchCase(r,n);const s=this.#Me.eval(r);if(!s)return null;const a=s.asTyped;return a?(r.assertAllUsed(),a):(this.#Me.typeError("not typed"),null)}evalDataMember(t){let e;switch(this.memberName.value){case"Int":e=IntType;break;case"ByteArray":e=ByteArrayType;break;case"[]Data":e=ListType$(RawDataType);break;case"Map[Data]Data":e=MapType$(RawDataType,RawDataType);break;default:const n=t.get(this.memberName);if(!n)return null;let r=n.asDataType;if(!r)return this.memberName.typeError("expected a data type"),null;if(e=r,!Common.isEnum(e))return this.memberName.typeError("expected an enum type"),null}const n=new Scope(t,!1);this.#Ae.evalInSwitchCase(n,e);const r=this.#Me.eval(n);if(!r)return null;n.assertAllUsed();const s=r.asTyped;return s||(this.#Me.typeError("not typed"),null)}toIR(t){let e=this.#Me.toIR(t.tab());return e=this.#Ae.wrapDestructIR(t,e,0),new IR([new IR("("),this.#Ae.toNameIR(0),new IR(") "),new IR("->",this.site),new IR(` {\n${t.indent}${TAB}`),e,new IR(`\n${t.indent}}`)])}}export class UnconstrDataSwitchCase extends SwitchCase{#Ue;#Ne;constructor(t,e,n,r){super(t,new DestructExpr(new Word(t,"_"),new RefExpr(new Word(t,"(Int, []Data)"))),r),this.#Ue=e,this.#Ne=n}isDataMember(){return!0}toString(){return`(${null===this.#Ue?"":this.#Ue.value+": "}Int, ${null===this.#Ne?"":this.#Ne.value+": "} []Data) => ${this.body.toString()}`}evalEnumMember(t,e){throw new Error("not available")}evalDataMember(t){let e=null;if(null!==this.#Ue||null!==this.#Ne){let n=new Scope(t,!1);null!==this.#Ue&&n.set(this.#Ue,new DataEntity(IntType)),null!==this.#Ne&&n.set(this.#Ne,new DataEntity(ListType$(RawDataType)));const r=this.body.eval(n);if(!r)return null;e=r.asTyped,n.assertAllUsed()}else{const n=this.body.eval(t);if(!n)return null;e=n.asTyped}return e||(this.body.typeError("not typed"),null)}toIR(t){return new IR([new IR(`(data) -> {\n${t.indent}${TAB}`),new IR(`(pair) -> {\n${t.indent}${TAB}${TAB}`),new IR(`(${null!==this.#Ue?this.#Ue.toString():"_"}, ${null!==this.#Ne?this.#Ne.toString():"_"}) `),new IR("->",this.site),new IR(` {\n${t.indent}${TAB}${TAB}${TAB}`),this.body.toIR(t.tab().tab().tab()),new IR(`\n${t.indent}${TAB}${TAB}}(__core__fstPair(pair), __core__sndPair(pair))`),new IR(`\n${t.indent}${TAB}}(__core__unConstrData(data))`),new IR(`\n${t.indent}}`)])}}export class SwitchDefault extends Token{#Me;constructor(t,e){super(t),this.#Me=e}toString(){return`else => ${this.#Me.toString()}`}eval(t){const e=this.#Me.eval(t);if(!e)return null;const n=e.asTyped;return n||(this.#Me.typeError("not typed"),null)}toIR(t){return new IR([new IR("(_) "),new IR("->",this.site),new IR(` {\n${t.indent}${TAB}`),this.#Me.toIR(t.tab()),new IR(`\n${t.indent}}`)])}}class SwitchExpr extends Expr{#Le;#Ve;#Oe;constructor(t,e,n,r=null){super(t),this.#Le=e,this.#Ve=n,this.#Oe=r}get controlExpr(){return this.#Le}get cases(){return this.#Ve}get defaultCase(){return this.#Oe}setDefaultCaseToVoid(){this.#Oe=new SwitchDefault(this.site,new VoidExpr(this.site))}toString(){return`${this.#Le.toString()}.switch{${this.#Ve.map((t=>t.toString())).join(", ")}${null===this.#Oe?"":", "+this.#Oe.toString()}}`}}export class EnumSwitchExpr extends SwitchExpr{evalInternal(t){const e=this.controlExpr.eval(t);if(!e)return null;const n=e.asTyped;if(!n)return this.controlExpr.typeError("not typed"),null;let r=n.type.asDataType;if(!r)return this.controlExpr.typeError("not an enum"),null;n.type.asEnumMemberType&&(this.controlExpr.typeError(`${n.type.toString()} is an enum variant, not an enum`),r=n.type.asEnumMemberType.parentType);const s=Common.countEnumMembers(r);null===this.defaultCase&&s>this.cases.length&&this.setDefaultCaseToVoid();let a=null;for(let e of this.cases){const n=e.evalEnumMember(t,r);n&&(a=IfElseExpr.reduceBranchMultiType(e.site,a,n))}if(null!==this.defaultCase){const e=this.defaultCase.eval(t);e&&(a=IfElseExpr.reduceBranchMultiType(this.defaultCase.site,a,e))}return null===a?new ErrorEntity:a.toTyped()}toIR(t){let e,n=this.cases.slice();e=null!==this.defaultCase?this.defaultCase:assertDefined(n.pop());let r=n.length,s=e.toIR(t.tab().tab().tab());for(let e=r-1;e>=0;e--){const r=n[e],a=IR.new`__core__equalsInteger(i, ${r.constrIndex.toString()})`;s=IR.new`__core__ifThenElse(
				${a},
				() -> {
					${r.toIR(t.tab().tab().tab())}
				}, () -> {
					${s}
				}
			)()`}return new IR([new IR("(e) "),new IR("->",this.site),new IR(` {\n${t.indent}${TAB}(\n${t.indent}${TAB}${TAB}(i) -> {\n${t.indent}${TAB}${TAB}${TAB}`),s,new IR(`\n${t.indent}${TAB}${TAB}}(__core__fstPair(__core__unConstrData(e)))\n${t.indent}${TAB})(e)\n${t.indent}}(`),this.controlExpr.toIR(t),new IR(")")])}}export class DataSwitchExpr extends SwitchExpr{evalInternal(t){const e=this.controlExpr.eval(t);if(!e)return null;const n=e.asTyped;if(!n)return this.controlExpr.typeError("not typed"),null;const r=n.type.asDataType;if(!r)return this.controlExpr.typeError("not a data type"),null;if(!RawDataType.isBaseOf(r))return this.controlExpr.typeError(`expected Data type, got ${n.type.toString()}`),null;null===this.defaultCase&&this.cases.length<5&&this.setDefaultCaseToVoid();let s=null;for(let e of this.cases){const n=e.evalDataMember(t);n&&(s=IfElseExpr.reduceBranchMultiType(e.site,s,n))}if(null!==this.defaultCase){const e=this.defaultCase.eval(t);e&&(s=IfElseExpr.reduceBranchMultiType(this.defaultCase.site,s,e))}return null===s?new ErrorEntity:s.toTyped()}toIR(t){let e=[null,null,null,null,null];for(let n of this.cases){let r=n.toIR(t.tab().tab());switch(n.memberName.value){case"ByteArray":e[4]=new IR([new IR("("),new IR("e"),new IR(") -> {"),r,new IR("("),new IR("__helios__bytearray__from_data"),new IR("("),new IR("e"),new IR(")"),new IR(")"),new IR("}")]);break;case"Int":e[3]=new IR([new IR("("),new IR("e"),new IR(") -> {"),r,new IR("("),new IR("__helios__int__from_data"),new IR("("),new IR("e"),new IR(")"),new IR(")"),new IR("}")]);break;case"[]Data":e[2]=new IR([new IR("("),new IR("e"),new IR(") -> {"),r,new IR("("),new IR("__code__unListData"),new IR("("),new IR("e"),new IR(")"),new IR(")"),new IR("}")]);break;case"Map[Data]Data":e[1]=new IR([new IR("("),new IR("e"),new IR(") -> {"),r,new IR("("),new IR("__code__unMapData"),new IR("("),new IR("e"),new IR(")"),new IR(")"),new IR("}")]);break;case"(Int, []Data)":e[0]=r;break;default:if(null!==e[0])throw new Error("should've been caught before");e[0]=r}}if(null!==this.defaultCase)for(let n=0;n<5;n++)null===e[n]&&(e[n]=new IR(`${t.indent}${TAB}def`));let n=new IR([new IR(`${t.indent}__core__chooseData(e, `,this.site),new IR(e.map((t=>assertDefined(t)))).join(", "),new IR(`${t.indent})`)]);return null!==this.defaultCase&&(n=new IR([new IR(`${t.indent}(def) -> {\n`),n,new IR(`\n${t.indent}}(`),this.defaultCase.toIR(t),new IR(")")])),n=new IR([new IR(`${t.indent}(e) -> {\n`),n,new IR("(e)"),new IR(`${t.indent}}(`),this.controlExpr.toIR(t),new IR(")")]),n}}export class Statement extends Token{#i;#He;constructor(t,e){super(t),this.#i=e,this.#He="__user"}get name(){return this.#i}get path(){return`${this.#He}__${this.name.toString()}`}eval(t){throw new Error("not yet implemented")}loopConstStatements(t,e){throw new Error("not yet implemented")}setBasePath(t){this.#He=t}toIR(t,e){throw new Error("not yet implemented")}toString(){throw new Error("not yet implemented")}}export class ImportFromStatement extends Statement{#qe;#ze;constructor(t,e,n,r){super(t,e),this.#qe=n,this.#ze=r}get moduleName(){return this.#ze}evalInternal(t){const e=t.getScope(this.#ze);if(!e)return null;const n=e.get(this.#qe);return n instanceof Scope?(this.#qe.typeError("can't import a module from a module"),null):n}eval(t){const e=this.evalInternal(t);e&&t.set(this.name,e)}loopConstStatements(t,e){}toIR(t,e){}}export class ImportModuleStatement extends Statement{#je;constructor(t,e){super(t,e),this.#je=new Map}get moduleName(){return this.name}evalInternal(t){const e=t.getScope(this.name);if(!e)return null;const n={};for(let[t,r]of e.values)r instanceof Scope||(n[t.value]=r);return new ModuleNamespace(n)}eval(t){let e=this.evalInternal(t);e&&t.set(this.name,e)}loopConstStatements(t,e){}toIR(t,e){}}export class ConstStatement extends Statement{#de;#Ce;constructor(t,e,n,r){super(t,e),this.#de=n,this.#Ce=r}get type(){return assertDefined(this.#de.cache?.asDataType,this.#de.cache?.toString()??this.#de.toString())}get path(){return`__const${super.path}`}isSet(){return null!==this.#Ce}changeValueSafe(t){const e=this.type,n=this.#Ce?this.#Ce.site:this.site;this.#Ce=new LiteralDataExpr(n,e,t)}toString(){return`const ${this.name.toString()}${this.#de.toString()}${this.#Ce?` = ${this.#Ce.toString()}`:""};`}evalType(t){return this.#de.evalAsDataType(t)}evalInternal(t){const e=this.#de.evalAsDataType(t);if(!e)return null;if(this.#Ce){const n=this.#Ce.evalAsTyped(t);if(!n)return null;if(!e.isBaseOf(n.type))return this.#Ce.typeError("wrong type"),null}return new DataEntity(e)}eval(t){const e=this.evalInternal(t);e?t.set(this.name,new NamedEntity(this.name.value,this.path,e)):t.set(this.name,new NamedEntity(this.name.value,this.path,new DataEntity(new AllType)))}loopConstStatements(t,e){e(`${t}${this.name.value}`,this)}toIRInternal(t){let e=assertDefined(this.#Ce).toIR(t);return this.#Ce instanceof LiteralDataExpr&&(e=IR.new`${this.#Ce.type.path}__from_data${null}(${this.site}${e})`),e}toIR(t,e){this.#Ce&&e.set(this.path,this.toIRInternal(t))}}export class TypeParameter{#i;#We;constructor(t,e){this.#i=t,this.#We=e}get name(){return this.#i.value}get typeClass(){return this.#We?assertDefined(this.#We.cache?.asTypeClass):new DefaultTypeClass}eval(t,e){let n=new DefaultTypeClass;if(this.#We){const e=this.#We.eval(t);if(!e)return null;if(!e.asTypeClass)return this.#We?.typeError("not a typeclass"),null;n=e.asTypeClass}const r=new Parameter(this.name,e,n);return t.set(this.#i,n.toType(this.#i.value,e,r)),r}toString(){return this.#We?`${this.#i}: ${this.#We.toString()}`:`${this.#i}`}}export class TypeParameters{#Ge;#Ke;#Xt;constructor(t,e){this.#Ge=t,this.#Ke=e?FTPP:TTPP,this.#Xt=null}hasParameters(){return this.#Ge.length>0}get parameterNames(){return this.#Ge.map((t=>t.name))}getParameters(){return assertDefined(this.#Xt,"parameters not yet evaluated")}genTypePath(t){return`${t}[${this.#Ge.map(((t,e)=>`${this.#Ke}${e}`)).join("@")}]`}genFuncPath(t){return this.hasParameters()?this.genTypePath(t):t}toString(){return this.hasParameters()?`[${this.#Ge.map((t=>t.toString())).join(", ")}]`:""}evalParams(t){const e=new Scope(t);return this.#Xt=[],this.#Ge.forEach(((t,n)=>{const r=t.eval(e,`${this.#Ke}${n}`);r&&this.#Xt?.push(r)})),e}evalParametricFuncType(t,e,n=null){const r=this.evalParams(t),s=e(r);return s?(r.assertAllUsed(),this.hasParameters()?new ParametricFunc(this.getParameters(),s):s):null}evalParametricFunc(t,e){const n=this.evalParametricFuncType(t,e);return n?n.asType?n.asType.toTyped():n:null}createParametricType(t,e,n){const r=this.evalParams(t),s=n(new Scope(r));if(this.hasParameters()){return[new ParametricType({name:s.name,parameters:this.getParameters(),apply:t=>{const n=new Map;t.forEach(((t,e)=>{const r=this.getParameters()[e];n.set(r,t)}));const r=assertDefined(s.infer(e,n,null).asDataType),a=IRParametricName.parse(s.path,!0).toImplementation(t.map((t=>assertDefined(t.asDataType).path))).toString();if(r instanceof GenericType)return r.changeNameAndPath(`${s.name}[${t.map((t=>t.toString())).join(",")}]`,a);throw new Error("unexpected")}}),r]}return[s,r]}}export class DataField extends NameTypePair{#Je;constructor(t,e,n=null){super(t,e),this.#Je=n}get type(){return assertDefined(super.type.asDataType)}hasTag(){return null!==this.#Je}get tag(){return this.#Je?this.#Je.value:this.name.value}eval(t){if(null===this.typeExpr)throw new Error("typeExpr not set in "+this.site.src.raw.split("\n")[0]);{const e=this.typeExpr.eval(t);if(!e)return null;if(e.asDataType){const t=e.asDataType;if(isDataType(t))return t}return this.typeExpr.typeError(`'${e.toString()}' isn't a valid data field type`),null}}}export class DataDefinition{#d;#i;#y;constructor(t,e,n){this.#d=t,this.#i=e,this.#y=n}get site(){return this.#d}get name(){return this.#i}get fields(){return this.#y.slice()}hasTags(){return this.#y.some((t=>t.hasTag()))}findField(t){let e=-1,n=0;for(let r of this.#y){if(r.name.toString()==t.toString()){e=n;break}n++}return e}get fieldNames(){return this.#y.map((t=>t.name.value))}hasField(t){return-1!=this.findField(t)}hasMember(t){return this.hasField(t)||"copy"==t.value}toStringFields(){return`{${this.#y.map((t=>t.toString())).join(", ")}}`}toString(){return`${this.name.toString()} ${this.toStringFields()}`}evalFieldTypes(t){const e={};for(let n of this.#y){const r=n.eval(t);r&&(e[n.name.value]=r)}return e}genCopyType(t){return new FuncType(this.#y.map((t=>new ArgType(t.name,t.type,!0))),t)}get nFields(){return this.#y.length}getFieldType(t){return this.#y[t].type}getFieldIndex(t){const e=this.findField(new Word(Site.dummy(),t));if(-1==e)throw new Error(`field ${t} not find in ${this.toString()}`);return e}getFieldName(t){return this.#y[t].name.toString()}genInstanceMembers(t){const e={...genCommonInstanceMembers(t),copy:new FuncType(this.#y.map((t=>new ArgType(t.name,t.type,!0))),t)};for(let t of this.fields)e[t.name.value]=t.type;return e}genTypeMembers(t){return{...genCommonTypeMembers(t)}}genTypeDetails(){const t=[],e=[],n=[];return this.fieldNames.forEach(((r,s)=>{const a=assertDefined(this.getFieldType(s).typeDetails);t.push(`${r}: ${a.inputType}`),e.push(`${r}: ${a.outputType}`),n.push({...a.internalType,name:r})})),[`{${t.join(", ")}}`,`{${e.join(", ")}}`,n]}async jsFieldsToUplc(t,e){const n=[];if(Object.keys(t).length!=this.nFields||!Object.keys(t).every((t=>this.hasField(new Word(Site.dummy(),t)))))throw new Error(`expected ${this.nFields} args, got ${Object.keys(t).length}`);return this.fieldNames.forEach(((r,s)=>{const a=assertDefined(t[r]),i=this.getFieldType(s);if(!i.typeDetails)throw new Error(`typeDetails for ${i.name} not yet implemented`);n.push(i.jsToUplc(a,e))})),Promise.all(n)}async jsMapToUplc(t,e){const n=[];if(Object.keys(t).length!=this.nFields||!Object.keys(t).every((t=>this.hasField(new Word(Site.dummy(),t)))))throw new Error(`expected ${this.nFields} args, got ${Object.keys(t).length}`);for(let r=0;r<this.nFields;r++){const s=assertDefined(t[this.fieldNames[r]]),a=this.getFieldType(r);if(!a.typeDetails)throw new Error(`typeDetails for ${a.name} not yet implemented`);n.push([new ByteArrayData(textToBytes(this.#y[r].tag)),await a.jsToUplc(s,e)])}return n}async uplcFieldsToJs(t,e){const n={};for(let r=0;r<t.length;r++){const s=t[r];n[this.getFieldName(r)]=await this.getFieldType(r).uplcToJs(s,e)}return n}async uplcMapToJs(t,e){const n={};for(let r=0;r<this.#y.length;r++){const s=this.#y[r],a=this.getFieldName(r),i=t.findIndex((([t,e])=>ByteArrayData.comp(t.bytes,textToBytes(s.tag))));if(-1==i)throw new Error(`couldn't find field ${s.tag}`);n[a]=await this.getFieldType(r).uplcToJs(t[i][1],e)}return n}toIR_new(t,e,n,r){const s=-1!=r;let a;if(this.hasTags()){a=IR.new`__core__mkNilPairData(())`;for(let t=this.nFields-1;t>=0;t--){const e=this.#y[t];a=IR.new`__core__mkCons(
					__core__mkPairData(
						__core__bData(#${bytesToHex(textToBytes(e.tag))}),
						${e.type.path}____to_data(${e.name.value})
					),
					${a}
				)`}a=IR.new`__core__constrData(
				0,
				__core__mkCons(
					__core__mapData(${a}),
					__core__mkCons(
						__core__iData(1),
						__core__mkNilData(())
					)
				)
			)`,a=IR.new`(${new IR(this.#y.map((t=>new IR(t.name.value)))).join(", ")}) -> {${a}}`}else if(1==this.nFields)a=s?IR.new`(self) -> {
					__core__constrData(${r}, __helios__common__list_1(${this.getFieldType(0).path}____to_data(self)))
				}${this.site}`:IR.new`__helios__common__identity`;else{a=IR.new`__core__mkNilData(())`;for(let t=this.nFields-1;t>=0;t--){const e=this.#y[t];a=IR.new`__core__mkCons(${e.type.path}____to_data(${e.name.value}), ${a})`}s&&(a=IR.new`__core__constrData(${r}, ${a})`),a=IR.new`(${new IR(this.#y.map((t=>new IR(t.name.value)))).join(", ")}) -> {${a}}`}const i=`${e}____new`;n.set(i,a)}toIR_copy(t,e,n,r,s=-1){const a=`${e}__copy`;let i=StructLiteralExpr.toIRInternal(t,this.site,e,this.#y.map((t=>new IR(t.name.value))));for(let t=r.length-1;t>=0;t--){const e=this.#y[t].name.toString();i=FuncArg.wrapWithDefaultInternal(i,e,IR.new`${r[t]}(self)`)}const o=new IR(this.#y.map((t=>new IR([new IR(`__useopt__${t.name.toString()}`),new IR(", "),new IR(`${t.name.toString()}`)])))).join(", ");i=IR.new`(self) -> {
			(${o}) -> {
				${i}
			}
		}`,n.set(a,i)}toIR_show(t,e=!1){if(this.hasTags()){assert(!e);let n=IR.new`""`;for(let t=0;t<this.nFields;t++){const e=this.#y[t],r=e.type.path;n=IR.new`__core__appendString(
					${n},
					__core__appendString(
						${t>0?`", ${e.name}: "`:`"${e.name}: "`},
						(opt) -> {
							opt(
								(valid, value) -> {
									__core__ifThenElse(
										valid,
										() -> {
											(opt) -> {
												opt(
													(valid, value) -> {
														__core__ifThenElse(
															valid,
															() -> {
																${r}__show(value)()
															},
															() -> {
																"<n/a>"
															}
														)()
													}
												)
											}(${r}__from_data_safe(value))
										},
										() -> {
											"<n/a>"
										}
									)()
								}
							)
						}(__helios__common__cip68_field_safe(self, #${bytesToHex(textToBytes(e.tag))}))
					)
				)`}return IR.new`(data) -> {
				__core__chooseData(
					data,
					() -> {
						(fields) -> {
							__core__chooseList(
								fields,
								() -> {"${t}{<n/a>}"},
								() -> {
									(data) -> {
										__core__chooseData(
											data,
											() -> {"${t}{<n/a>}"},
											() -> {
												(self) -> {
													__core__appendString(
														"${t}{",
														__core__appendString(
															${n},
															"}"
														)
													)
												}(__core__unMapData(data))
											},
											() -> {"${t}{<n/a>}"},
											() -> {"${t}{<n/a>}"},
											() -> {"${t}{<n/a>}"}
										)()
									}(__core__headList__safe(fields))
								}
							)()
						}(__core__sndPair(__core__unConstrData__safe(data)))
					},
					() -> {"${t}{<n/a>}"},
					() -> {"${t}{<n/a>}"},
					() -> {"${t}{<n/a>}"},
					() -> {"${t}{<n/a>}"}
				)
			}`}if(1!=this.nFields||e){let e=IR.new`(fields) -> {""}`;for(let t=this.nFields-1;t>=0;t--){const n=this.#y[t],r=n.type.path;e=IR.new`(fields) -> {
					__core__chooseList(
						fields,
						() -> {""},
						() -> {
							__core__appendString(
								${t>0?`", ${n.name}: "`:`"${n.name}: "`},
								__core__appendString(
									(opt) -> {
										opt(
											(valid, value) -> {
												__core__ifThenElse(
													valid,
													() -> {
														${r}__show(value)()
													},
													() -> {
														"<n/a>"
													}
												)()
											}
										)
									}(${r}__from_data_safe(__core__headList__safe(fields))),
									${e}(__core__tailList__safe(fields))
								)
							)
						}
					)()
				}`}return IR.new`(self) -> {
				() -> {
					__core__appendString(
						"${t}{",
						__core__appendString(
							${e}(self),
							"}"
						)
					)
				}
			}`}return IR.new`${this.#y[0].type.path}__show`}toIR_is_valid_data(){if(this.hasTags()){const t=this.#y;let e=IR.new``;return t.forEach(((t,n)=>{e=0==n?IR.new`__helios__common__test_cip68_field(
						data,
						__core__bData(#${bytesToHex(textToBytes(t.tag))}),
						${t.type.path}__is_valid_data
					)`:IR.new`__core__ifThenElse(
						__helios__common__test_cip68_field(
							data,
							__core__bData(#${bytesToHex(textToBytes(t.tag))}),
							${t.type.path}__is_valid_data
						),
						() -> {
							${e}
						},
						() -> {
							false
						}
					)()`})),IR.new`(data) -> {
				${e}
			}`}if(1==this.nFields)return IR.new`${this.#y[0].type.path}__is_valid_data`;{const t=this.#y.slice().reverse();let e=IR.new`(fields) -> {
				__core__chooseList(
					fields,
					true,
					false
				)
			}`;return t.forEach((t=>{e=IR.new`(fields) -> {
					__core__chooseList(
						fields,
						() -> {
							false
						},
						() -> {
							(head) -> {
								__core__ifThenElse(
									${t.type.path}__is_valid_data(head),
									() -> {${e}(__core__tailList__safe(fields))},
									() -> {false}
								)()
							}(__core__headList__safe(fields))
						}
					)()
				}`})),IR.new`(data) -> {
				__core__chooseData(
					data,
					() -> {false},
					() -> {false},
					() -> {
						${e}(__core__unListData__safe(data))
					},
					() -> {false},
					() -> {false}
				)()
			}`}}toIR_from_data_fields(t){if(this.hasTags()){return IR.new(`(data) -> {\n\t\t\t\t(ignore) -> {\n\t\t\t\t\tdata\n\t\t\t\t}(\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t${t}__is_valid_data(data),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__trace("Warning: invalid ${this.name.toString()} data", ())\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t)\n\t\t\t}`)}return IR.new(`(fields) -> {\n\t\t\t\t(ignore) -> {\n\t\t\t\t\tfields\n\t\t\t\t}(\n\t\t\t\t\t__core__ifThenElse(\n\t\t\t\t\t\t${t}__is_valid_data(__core__listData(fields)),\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t()\n\t\t\t\t\t\t},\n\t\t\t\t\t\t() -> {\n\t\t\t\t\t\t\t__core__trace("Warning: invalid ${this.name.toString()} data", ())\n\t\t\t\t\t\t}\n\t\t\t\t\t)()\n\t\t\t\t)\n\t\t\t}`)}toIR(t,e,n,r){const s=[];if(this.hasTags())for(let t=0;t<this.#y.length;t++){const r=this.#y[t],a=`${e}__${r.name.value}`,i=IR.new`(self) -> {${r.type.path}__from_data(__helios__common__cip68_field(self, #${bytesToHex(textToBytes(r.tag))}))}`;n.set(a,i),s.push(a)}else{const t=-1!=r,a=t?"__helios__common__enum_field":"__helios__common__struct_field";if(1!=this.fields.length||t)for(let r=0;r<this.#y.length;r++){let i,o=this.#y[r],_=`${e}__${o.name.value}`;if(s.push(_),r<20)i=IR.new`(self) ${null}->${o.site} {
							${o.type.path}__from_data(${a}_${r}(self))
						}`;else{let e=new IR("self");t&&(e=IR.new`__core__sndPair(__core__unConstrData(${e}))`);for(let t=0;t<r;t++)e=IR.new`__core__tailList(${e})`;e=IR.new`${o.type.path}__from_data(__core__headList(${e}))`,i=IR.new`(self) ${null}->${o.site} {${e}}`}n.set(_,i)}else{const t=this.fields[0],r=`${e}__${t.name.value}`,a=IR.new`__helios__common__identity${t.site}`;n.set(r,a),s.push(r)}}this.toIR_new(t,e,n,r),this.toIR_copy(t,e,n,s)}}export class StructStatement extends Statement{#Xt;#Ze;#Ye;constructor(t,e,n,r,s){super(t,e),this.#Xt=n,this.#Ze=new DataDefinition(this.site,e,r),this.#Ye=s}get path(){return this.#Xt.genTypePath(super.path)}setBasePath(t){super.setBasePath(t),this.#Ye.setBasePath(this.path)}genOffChainType(){const t=this;class e extends HeliosData{#y;constructor(...e){if(super(),this.#y=[],1==e.length&&"object"==typeof e[0]&&Object.keys(e[0]).length==t.#Ze.nFields&&Object.keys(e[0]).every((e=>t.#Ze.hasField(new Word(Site.dummy(),e)))))t.#Ze.fieldNames.forEach(((n,r)=>{const s=assertDefined(e[0][n]),a=t.#Ze.getFieldType(r);if(!a.offChainType)throw new Error(`offChainType for ${a.name} not yet implemented`);const i=a.offChainType,o=s instanceof i?s:new i(s);this.#y.push(o),this[n]=o}));else{if(e.length!=t.#Ze.nFields)throw new Error(`expected ${t.#Ze.nFields} args, got ${e.length}`);e.forEach(((e,n)=>{const r=t.#Ze.getFieldName(n),s=t.#Ze.getFieldType(n);if(!s.offChainType)throw new Error(`offChainType for ${s.name} not yet implemented`);const a=s.offChainType,i=e instanceof a?e:new a(e);this.#y.push(i),this[r]=i}))}}static[Symbol.hasInstance](e){return e._structStatement===t&&e instanceof HeliosData}get _structStatement(){return t}get _fields(){return this.#y}_toUplcData(){return 1==this.#y.length?this.#y[0]._toUplcData():new ListData(this.#y.map((t=>t._toUplcData())))}static fromUplcCbor(t){return e.fromUplcData(UplcData.fromCbor(t))}static fromUplcData(n){const r=n.list;if(r.length!=t.#Ze.nFields)throw new Error("unexpected number of fields");const s=r.map(((e,n)=>assertDefined(t.#Ze.getFieldType(n).offChainType).fromUplcData(e)));return new e(...s)}static isBuiltin(){return!1}}return Object.defineProperty(e,"name",{value:this.name,writable:!1}),e}toString(){return`struct ${this.name.toString()}${this.#Xt.toString()} ${this.#Ze.toStringFields()}`}eval(t){const[e,n]=this.#Xt.createParametricType(t,this.site,(t=>{const e={fieldNames:this.#Ze.fieldNames,name:this.name.value,path:this.path,genTypeDetails:t=>{const[e,n,r]=this.#Ze.genTypeDetails();return{inputType:e,outputType:n,internalType:{type:"Struct",fieldTypes:r}}},jsToUplc:async(t,e)=>{if(this.#Ze.hasTags()){const n=await this.#Ze.jsMapToUplc(t,e);return new ConstrData(0,[new MapData(n),new IntData(1n)])}{const n=await this.#Ze.jsFieldsToUplc(t,e);return 1==n.length?n[0]:new ListData(n)}},uplcToJs:async(t,e)=>this.#Ze.hasTags()?this.#Ze.uplcMapToJs(t.fields[0].map,e):1==this.#Ze.nFields?this.#Ze.getFieldType(0).uplcToJs(t,e):this.#Ze.uplcFieldsToJs(t.list,e),genOffChainType:()=>this.genOffChainType(),genInstanceMembers:e=>({...genCommonInstanceMembers(e),...this.#Ze.evalFieldTypes(t),...this.#Ye.genInstanceMembers(t),copy:this.#Ze.genCopyType(e)}),genTypeMembers:e=>({...genCommonTypeMembers(e),...this.#Ye.genTypeMembers(t)})};return this.#Xt.hasParameters()?new GenericParametricType(e):new GenericType(e)})),r=this.#Xt.hasParameters()?super.path:this.path;t.set(this.name,new NamedEntity(this.name.value,r,e)),this.#Ze.evalFieldTypes(n),n.assertAllUsed(),this.#Ye.eval(n)}loopConstStatements(t,e){this.#Ye.loopConstStatements(`${t}${this.name.value}::`,e)}toIR(t,e){if(e.set(`${this.path}__is_valid_data`,this.#Ze.toIR_is_valid_data()),this.#Ze.hasTags())e.set(`${this.path}____eq`,IR.new`__helios__common____eq${this.site}`),e.set(`${this.path}____neq`,IR.new`__helios__common____neq${this.site}`),e.set(`${this.path}__serialize`,IR.new`__helios__common__serialize${this.site}`),e.set(`${this.path}____to_data`,IR.new`__helios__common__identity${this.site}`),config.CHECK_CASTS&&!t.simplify?e.set(`${this.path}__from_data`,IR.new`(data) -> {
					(ignore) -> {
						data
					}(
						__core__ifThenElse(
							${this.path}__is_valid_data(data),
							() -> {
								()
							},
							() -> {
								__core__trace("Warning: invalid ${this.name.toString()} data", ())
							}
						)()
					)
				}${this.site}`):e.set(`${this.path}__from_data`,IR.new`__helios__common__identity${this.site}`),e.set(`${this.path}__from_data_safe`,IR.new`__helios__option__SOME_FUNC${this.site}`);else{const n=1==this.#Ze.nFields?this.#Ze.getFieldType(0).path:"__helios__struct";e.set(`${this.path}____eq`,IR.new`${n}____eq${this.site}`),e.set(`${this.path}____neq`,IR.new`${n}____neq${this.site}`),e.set(`${this.path}__serialize`,IR.new`${n}__serialize${this.site}`),1==this.#Ze.fieldNames.length||!config.CHECK_CASTS||t.simplify?e.set(`${this.path}__from_data`,IR.new`${n}__from_data${this.site}`):e.set(`${this.path}__from_data`,IR.new`(data) -> {
					(ignore) -> {
						__core__unListData(data)
					}(
						__core__ifThenElse(
							${this.path}__is_valid_data(data),
							() -> {
								()
							},
							() -> {
								__core__trace("Warning: invalid ${this.name.toString()} data", ())
							}
						)()
					)
				}${this.site}`),1==this.#Ze.fieldNames.length?e.set(`${this.path}__from_data_safe`,IR.new`${this.#Ze.getFieldType(0).path}__from_data_safe${this.site}`):e.set(`${this.path}__from_data_safe`,IR.new`(data) -> {
					__core__chooseData(
						data,
						() -> {__helios__option__NONE_FUNC},
						() -> {__helios__option__NONE_FUNC},
						() -> {
							__helios__option__SOME_FUNC(__core__unListData__safe(data))
						},
						() -> {__helios__option__NONE_FUNC},
						() -> {__helios__option__NONE_FUNC}
					)()
				}`),e.set(`${this.path}____to_data`,new IR(`${n}____to_data`,this.site))}this.#Ze.toIR(t,this.path,e,-1),e.set(`${this.path}__show`,this.#Ze.toIR_show(this.name.value)),this.#Ye.toIR(t,e)}}export class FuncStatement extends Statement{#Xt;#Xe;constructor(t,e,n,r){super(t,e),this.#Xt=n,this.#Xe=r}get path(){return this.#Xt.genFuncPath(super.path)}get nArgs(){return this.#Xe.nArgs}get argNames(){return this.#Xe.argNames}get argTypes(){return this.#Xe.argTypes}get argTypeNames(){return this.#Xe.argTypeNames}get retType(){return this.#Xe.retType}get retSite(){return this.#Xe.retExpr.site}toString(){return`func ${this.name.toString()}${this.#Xt.toString()}${this.#Xe.toString()}`}evalInternal(t,e=!1){return this.#Xt.evalParametricFunc(t,(t=>{const n=this.#Xe.evalType(t);if(!n)return null;if(e)this.#Xe.evalInternal(t);else{const e=new Scope(t);e.set(this.name,new NamedEntity(this.name.value,super.path,n.toTyped())),this.#Xe.evalInternal(e)}return n}))}evalType(t){return this.#Xt.evalParametricFuncType(t,(t=>this.#Xe.evalType(t)))}eval(t){const e=this.evalInternal(t);e&&(assert(!e.asType),t.set(this.name,new NamedEntity(this.name.value,super.path,e)))}loopConstStatements(t,e){}toIRInternal(t){return this.#Xe.toIR(t)}toIR(t,e){e.set(this.path,this.toIRInternal(t))}static isMethod(t){return t instanceof FuncStatement&&t.#Xe.isMethod()}}export class EnumMember{#ut;#Ot;#Ze;constructor(t,e){this.#ut=null,this.#Ot=null,this.#Ze=new DataDefinition(t.site,t,e)}get constrIndex(){if(null===this.#Ot)throw new Error("constrIndex not set");return this.#Ot}get name(){return this.#Ze.name}registerParent(t,e){this.#ut=t,this.#Ot=e}get parent(){if(null===this.#ut)throw new Error("parent not yet registered");return this.#ut}genOffChainType(){const t=this,e=t.parent,n=t.constrIndex,r=t.#Ze.nFields,s=[];for(let e=0;e<r;e++)s.push([t.#Ze.getFieldName(e),t.#Ze.getFieldType(e)]);class a extends HeliosData{#y;constructor(...t){if(super(),t.length!=r)throw new Error(`expected ${r} args, got ${t.length}`);this.#y=[],t.forEach(((t,e)=>{const[n,r]=s[e],a=assertDefined(r.offChainType),i=t instanceof a?t:new a(t);this.#y.push(i),this[n]=i}))}static[Symbol.hasInstance](e){return e._enumVariantStatement===t&&e instanceof HeliosData}get _enumStatement(){return e}get _enumVariantStatement(){return t}_toUplcData(){return new ConstrData(n,this.#y.map((t=>t._toUplcData())))}static isBuiltin(){return!1}static fromUplcCbor(t){return a.fromUplcData(UplcData.fromCbor(t))}static fromUplcData(t){assert(t.index==n,"wrong index");const e=t.list;if(e.length!=r)throw new Error("unexpected number of fields");const i=e.map(((t,e)=>assertDefined(s[e][1].offChainType).fromUplcData(t)));return new a(...i)}}return Object.defineProperty(a,"name",{value:this.#Ze.name,writable:!1}),a}get dataDefinition(){return this.#Ze}evalDataFields(t){this.#Ze.evalFieldTypes(t)}evalType(t){if(null===this.#ut)throw new Error("parent should've been registered");return e=>{const n=`${e.path}__${this.#Ze.name.value}`,r={name:this.#Ze.name.value,path:n,constrIndex:this.constrIndex,genOffChainType:()=>this.genOffChainType(),parentType:e,fieldNames:this.#Ze.fieldNames,genInstanceMembers:e=>({...genCommonInstanceMembers(e),...this.#Ze.evalFieldTypes(t),copy:this.#Ze.genCopyType(e)}),genTypeMembers:t=>({...genCommonEnumTypeMembers(t,e)})};return this.parent.hasParameters()?new GenericParametricEnumMemberType(r):new GenericEnumMemberType(r)}}get path(){return`${this.parent.path}__${this.#Ze.name.toString()}`}toIR(t,e){e.set(`${this.path}____eq`,IR.new`__helios__common____eq${this.#Ze.site}`),e.set(`${this.path}____neq`,IR.new`__helios__common____neq${this.#Ze.site}`),e.set(`${this.path}__serialize`,IR.new`__helios__common__serialize${this.#Ze.site}`),e.set(`${this.path}__is_valid_data`,IR.new`(data) -> {
			__core__chooseData(
				data,
				() -> {
					(pair) -> {
						__core__ifThenElse(
							__core__equalsInteger(__core__fstPair(pair), ${this.#Ot}),
							() -> {
								${this.#Ze.toIR_is_valid_data()}(__core__listData(__core__sndPair(pair)))
							},
							() -> {
								false
							}
						)()
					}(__core__unConstrData__safe(data))
				},
				() -> {false},
				() -> {false},
				() -> {false},
				() -> {false}
			)()
		}`),config.CHECK_CASTS&&!t.simplify?e.set(`${this.path}__from_data`,IR.new`(data) -> {
				(ignore) -> {
					data
				}(
					__core__ifThenElse(
						${this.path}__is_valid_data(data),
						() -> {
							()
						},
						() -> {
							__core__trace("Warning: invalid ${this.name.toString()} data", ())
						}
					)()
				)
			}`):e.set(`${this.path}__from_data`,new IR(`(data) -> {\n\t\t\t\t__helios__common__assert_constr_index(data, ${this.constrIndex})\n\t\t\t}`,this.#Ze.site)),e.set(`${this.path}__from_data_safe`,IR.new`(data) -> {
			__core__chooseData(
				data,
				() -> {
					(index) -> {
						__core__ifThenElse(
							__core__equalsInteger(index, ${this.constrIndex}),
							() -> {
								__helios__option__SOME_FUNC(data)
							},
							() -> {
								__helios__option__NONE_FUNC
							}
						)()
					}(__core__fstPair(__core__unConstrData__safe(data)))
				},
				() -> {__helios__option__NONE_FUNC},
				() -> {__helios__option__NONE_FUNC},
				() -> {__helios__option__NONE_FUNC},
				() -> {__helios__option__NONE_FUNC}
			)()
		}`),e.set(`${this.path}____to_data`,new IR("__helios__common__identity",this.#Ze.site)),this.#Ze.toIR(t,this.path,e,this.constrIndex);const n=(this.#ut?.name?.value??"")+"::"+this.name.value;e.set(`${this.path}__show`,IR.new`(data) -> {
			__core__chooseData(
				data,
				() -> {
					(fields) -> {
						${this.#Ze.toIR_show(n,!0)}(fields)()
					}(__core__sndPair(__core__unConstrData__safe(data)))
				},
				() -> {"${n}{<n/a>}"},
				() -> {"${n}{<n/a>}"},
				() -> {"${n}{<n/a>}"},
				() -> {"${n}{<n/a>}"}
			)
		}`)}}export class EnumStatement extends Statement{#Xt;#zt;#Ye;constructor(t,e,n,r,s){super(t,e),this.#Xt=n,this.#zt=r,this.#Ye=s;for(let t=0;t<this.#zt.length;t++)this.#zt[t].registerParent(this,t)}get path(){return this.#Xt.genTypePath(super.path)}hasParameters(){return this.#Xt.hasParameters()}setBasePath(t){super.setBasePath(t),this.#Ye.setBasePath(this.path)}genOffChainType(){const t=this,e=t.nEnumMembers,n=[];for(let t=0;t<e;t++)n.push(this.#zt[t].genOffChainType());class r extends HeliosData{constructor(){throw super(),new Error("can't be constructed (hint: construct an enum)")}static[Symbol.hasInstance](e){return e._enumStatement===t&&e instanceof HeliosData}get _enumStatement(){return t}static fromUplcCbor(t){return r.fromUplcData(UplcData.fromCbor(t))}static fromUplcData(t){return assertDefined(n[t.index],"index out of range").fromUplcData(t)}static isBuiltin(){return!1}}Object.defineProperty(r,"name",{value:this.name,writable:!1});for(let t of n)Object.defineProperty(r,t.name,{value:t,writable:!1});return r}findEnumMember(t){let e=-1,n=0;for(let r of this.#zt){if(r.name.toString()==t.toString()){e=n;break}n++}return e}getEnumMember(t){return assertDefined(this.#zt[t])}hasEnumMember(t){return-1!=this.findEnumMember(t)}get nEnumMembers(){return this.#zt.length}eval(t){const[e,n]=this.#Xt.createParametricType(t,this.site,(t=>{const e={};this.#zt.forEach((n=>{e[n.name.value]=n.evalType(t)}));const n={name:this.name.value,path:this.path,genTypeDetails:t=>{const e=[],n=[],r=[];return this.#zt.forEach((t=>{const[s,a,i]=t.dataDefinition.genTypeDetails();e.push(`{"${t.name.value}": ${s}}`),n.push(`{"${t.name.value}": ${a}}`),r.push({name:t.name.value,fieldTypes:i})})),{inputType:e.join(" | "),outputType:n.join(" | "),internalType:{type:"Enum",variantTypes:r}}},jsToUplc:async(t,e)=>{const n=assertDefined(Object.keys(t)[0]),r=this.#zt.findIndex((t=>t.name.value==n));if(-1==r)throw new Error(`invalid ${n} of ${this.name.value}`);const s=this.#zt[r],a=await s.dataDefinition.jsFieldsToUplc(assertDefined(t[n]),e);return new ConstrData(r,a)},uplcToJs:async(t,e)=>{const n=t.index;if(n<0||n>=this.#zt.length)throw new Error(`enum variant index ${n} out of range`);const r=this.#zt[n];return{[r.name.value]:await r.dataDefinition.uplcFieldsToJs(t.fields,e)}},genOffChainType:()=>this.genOffChainType(),genInstanceMembers:e=>({...genCommonInstanceMembers(e),...this.#Ye.genInstanceMembers(t)}),genTypeMembers:n=>{const r={...genCommonTypeMembers(n),...this.#Ye.genTypeMembers(t)};for(let t in e)r[t]=e[t](assertDefined(n.asDataType));return r}};return this.#Xt.hasParameters()?new GenericParametricType(n):new GenericType(n)})),r=this.#Xt.hasParameters()?super.path:this.path;t.set(this.name,new NamedEntity(this.name.value,r,e)),this.#zt.forEach((t=>{t.evalDataFields(n)})),n.assertAllUsed(),this.#Ye.eval(n)}loopConstStatements(t,e){this.#Ye.loopConstStatements(`${t}${this.name.value}::`,e)}toIR_is_valid_data(){let t=IR.new`false`;return this.#zt.forEach((e=>{t=IR.new`__core__ifThenElse(
				${e.path}__is_valid_data(data),
				() -> {
					true
				},
				() -> {
					${t}
				}
			)()`})),IR.new`(data) -> {
			${t}
		}`}toIR_show(){const t=this.name.value,e=this.#zt[this.#zt.length-1];let n=IR.new`${e.path}__show(data)()`;for(let t=this.#zt.length-2;t>=0;t--){const e=this.#zt[t];n=IR.new`__core__ifThenElse(
				__core__equalsInteger(index, ${e.constrIndex}),
				() -> {
					${e.path}__show(data)()
				},
				() -> {
					${n}
				}
			)()`}return IR.new`(data) -> {
			__core__chooseData(
				data,
				() -> {
					(index) -> {
						${n}
					}(__core__fstPair(__core__unConstrData__safe(data)))
				},
				() -> {"${t}{<n/a>}"},
				() -> {"${t}{<n/a>}"},
				() -> {"${t}{<n/a>}"},
				() -> {"${t}{<n/a>}"}
			)
		}`}toIR(t,e){e.set(`${this.path}____eq`,IR.new`__helios__common____eq${this.site}`),e.set(`${this.path}____neq`,IR.new`__helios__common____neq${this.site}`),e.set(`${this.path}__serialize`,IR.new`__helios__common__serialize${this.site}`),e.set(`${this.path}____to_data`,IR.new`__helios__common__identity${this.site}`),e.set(`${this.path}__is_valid_data`,this.toIR_is_valid_data()),e.set(`${this.path}__show`,this.toIR_show()),config.CHECK_CASTS&&!t.simplify?e.set(`${this.path}__from_data`,IR.new`(data) -> {
				(ignore) -> {
					data
				}(
					__core__ifThenElse(
						${this.path}__is_valid_data(data),
						() -> {
							()
						},
						() -> {
							__core__trace("Warning: invalid ${this.name.toString()} data", ())
						}
					)()
				)
			}${this.site}`):e.set(`${this.path}__from_data`,IR.new`__helios__common__identity${this.site}`),e.set(`${this.path}__from_data_safe`,IR.new`__helios__option__SOME_FUNC${this.site}`);for(let n of this.#zt)n.toIR(t,e);this.#Ye.toIR(t,e)}toString(){return`enum ${this.name.toString()}${this.#Xt.toString()} {${this.#zt.map((t=>t.toString())).join(", ")}}`}}export class ImplDefinition{#Qe;#tn;constructor(t,e){this.#Qe=t,this.#tn=e}get site(){return this.#Qe.site}setBasePath(t){for(let e of this.#tn)e.setBasePath(t)}toString(){return`${this.#tn.map((t=>t.toString())).join("\n")}`}genTypeMembers(t){const e={};for(let n of this.#tn)if(n instanceof ConstStatement){const r=n.evalType(t);r&&(e[n.name.value]=r.toTyped())}else if(!FuncStatement.isMethod(n)){const r=n.evalType(t);r&&(e[n.name.value]=r)}return e}genInstanceMembers(t){const e={};for(let n of this.#tn)if(FuncStatement.isMethod(n)){const r=n.evalType(t);r&&(e[n.name.value]=r)}return e}eval(t){this.#Qe.eval(t);for(let e of this.#tn)e instanceof FuncStatement?e.evalInternal(t,!0):e.evalInternal(t)}loopConstStatements(t,e){for(let n of this.#tn)n.loopConstStatements(t,e)}toIR(t,e){for(let n of this.#tn)n.toIR(t,e)}}const AUTOMATIC_METHODS=["__eq","__neq","copy","show","from_data","from_data_safe","is_valid_data","serialize"];let importPathTranslator=null;export function setImportPathTranslator(t){importPathTranslator=t}export function buildProgramStatements(t){let e=[];for(;0!=t.length;){const n=t.shift()?.assertWord();if(!n)continue;const r=n.value;let s=null;if("const"==r?s=buildConstStatement(n.site,t):"struct"==r?s=buildStructStatement(n.site,t):"func"==r?s=buildFuncStatement(n.site,t):"enum"==r?s=buildEnumStatement(n.site,t):"import"==r?s=buildImportStatements(n.site,t):n.syntaxError(`invalid top-level keyword '${r}'`),s)if(Array.isArray(s))for(let t of s)t&&e.push(t);else e.push(s)}return e}export function buildScriptPurpose(t,e=null){if(t.length<2)return 0==t.length?Site.dummy().syntaxError("invalid script purpose syntax"):(t[0].syntaxError("invalid script purpose syntax"),t.splice(0)),null;const n=t.shift()?.assertWord();if(!n)return null;let r=null;if(n.isWord("spending"))r="spending";else if(n.isWord("minting"))r="minting";else if(n.isWord("staking"))r="staking";else if(n.isWord("testing"))r="testing";else if(n.isWord("endpoint"))r="endpoint";else if(n.isWord("module"))r="module";else{if(n.isKeyword())return n.syntaxError("script purpose missing"),t.unshift(n),null;n.syntaxError(`unrecognized script purpose '${n.value}' (expected 'testing', 'spending', 'staking', 'minting', 'endpoint' or 'module')`),r="unknown"}null!==e&&null!==r&&e!=r&&n.syntaxError(`expected '${e}' script purpose`);const s=assertToken(t.shift(),n.site)?.assertWord()?.assertNotKeyword();return s?("main"===s.value&&s.syntaxError(`${n.value} script can't be named 'main'`),[r,s]):null}export function buildScript(t,e=null){const n=t[0],r=buildScriptPurpose(t,e),s=buildProgramStatements(t);let a=-1;const[i,o]=null!==r?r:[null,null];return"module"!=i&&(a=s.findIndex((t=>"main"===t.name.value)),-1==a&&(null!==o?n.site.merge(o.site).syntaxError("entrypoint 'main' not found"):n.site.syntaxError("entrypoint 'main' not found"))),[i,o,s,a]}export function extractScriptPurposeAndName(t){try{let e=new Source(t,""),n=new Tokenizer(e).streamTokens(),r=[];for(let t=0;t<2;t++){let t=n.next();if(t.done)return null;r.push(t.value)}const s=buildScriptPurpose(r);if(e.throwErrors(),null!==s){const[t,e]=s;return[t,e.value]}throw new Error("unexpected")}catch(t){if(t instanceof UserError)return null;throw t}}function buildConstStatement(t,e){if(0==e.length)return t.syntaxError("invalid syntax (expected name after 'const')"),null;const n=assertToken(e.shift(),t)?.assertWord()?.assertNotKeyword();if(!n)return null;if(!(e.length>0&&e[0].isSymbol(":")))return t.merge(n.site).syntaxError(`expected type annotation after 'const ${n.value}'`),e.splice(0),null;const r=assertDefined(e.shift());let s=SymbolToken.find(e,"=");const a=Word.find(e,["const","func","struct","enum","import"]);let i=s,o=!1;if(-1==s&&-1==a)i=e.length;else if(-1!=a&&(-1==s||s>a))i=a;else{if(0==s)return r.site.merge(e[0].site).syntaxError("expected type expression between ':' and '='"),e.shift(),null;o=!0}let _=e[i-1].site;const l=buildTypeExpr(r.site,e.splice(0,i));if(!l)return null;let u=null;if(o){const r=e.shift();if(void 0===r)return t.merge(n.site).syntaxError("expected '=' after 'const'"),e.splice(0),null;if(!r.isSymbol("="))return t.merge(r.site).syntaxError("expected '=' after 'const'"),null;{const t=r.assertSymbol("=");if(!t)return null;const n=Word.find(e,["const","func","struct","enum","import"]),s=-1==n?e.splice(0):e.splice(0,n);if(0==s.length)return t.syntaxError("expected expression after '='"),null;_=s[s.length-1].site,u=buildValueExpr(s)}}return new ConstStatement(t.merge(_),n,l,u)}function buildTypeClassExpr(t,e){const n=assertToken(e.shift(),t,"expected word")?.assertWord()?.assertNotKeyword();return n?new RefExpr(n):null}function buildTypeParameter(t,e){const n=assertToken(e.shift(),t,"expected type parameter name")?.assertWord()?.assertNotKeyword()??null;if(!n)return null;const r=e.shift();if(!r)return new TypeParameter(n,null);if(!r.assertSymbol(":"))return null;const s=buildTypeClassExpr(t,e);return s?e.length>0?(e[0].syntaxError("unexpected token"),null):new TypeParameter(n,s):null}function buildTypeParameters(t,e){if(t.length>0&&t[0].isGroup("[")){const n=assertDefined(t.shift()).assertGroup("[");if(n){const t=reduceNull(n.fields.map((t=>buildTypeParameter(n.site,t))));if(t)return new TypeParameters(t,e)}}return new TypeParameters([],e)}function splitDataImpl(t){const e=Word.find(t,["const","func"]);return-1==e?[t,[]]:[t.slice(0,e),t.slice(e)]}function buildStructStatement(t,e){const n=assertToken(e.shift(),t,"expected name after 'struct'");if(!n)return null;const r=n.assertWord()?.assertNotKeyword();if(!r)return null;const s=buildTypeParameters(e,!1),a=assertToken(e.shift(),r.site,`expected '{...}' after 'struct ${r.toString()}'`);if(!a)return null;if(!a.isGroup("{",1))return a.syntaxError("expected non-empty '{..}' without separators"),null;const i=a.assertGroup("{",1);if(!i)return null;const[o,_]=splitDataImpl(i.fields[0]),l=buildDataFields(o,!0);let u=new RefExpr(r);s.hasParameters()&&(u=new ParametricExpr(u.site,u,s.parameterNames.map((t=>new RefExpr(new Word(u.site,t))))));const c=buildImplDefinition(_,u,l.map((t=>t.name)),i.site.endSite);return null===c?null:new StructStatement(t.merge(i.site),r,s,l,c)}function buildDataFields(t,e=!1){const n=[];function r(t){-1!=n.findIndex((e=>e.name.toString()==t.toString()))&&t.typeError(`duplicate field '${t.toString()}'`)}const s=new Map;for(;t.length>0;){const a=SymbolToken.find(t,":");if(-1==a)return t[0].site.merge(t[t.length-1].site).syntaxError("expected ':' in data field"),n;const i=t[a],o=t.slice(0,a),_=t.slice(a+1),l=o.shift();if(void 0!==l){const a=l?.assertWord()?.assertNotKeyword();if(!a)return n;if(r(a),0==_.length)return i.syntaxError("expected type expression after ':'"),n;const o=SymbolToken.find(_,":");if(-1!=o){if(0==o)return _[o].syntaxError("expected word before ':'"),n;_[o-1].assertWord(),t=_.splice(o-1)}else t=[];let u=null;if(e&&_.length>0&&_[_.length-1]instanceof StringLiteral){if(u=assertClass(_.pop(),StringLiteral),s.has(u.value))return u.syntaxError(`duplicate field tag "${u.value}"`),n;s.set(u.value,u)}else{if(s.has(a.value))return a.syntaxError(`duplicate field tag "${a.value}" (default taken from field name)`),n;s.set(a.value,new StringLiteral(a.site,a.value))}const c=buildTypeExpr(i.site,_);if(!c)return n;n.push(new DataField(a,c,u))}else i.syntaxError("expected word before ':'")}return n}function buildFuncStatement(t,e,n=null){const r=assertToken(e.shift(),t)?.assertWord()?.assertNotKeyword();if(!r)return null;if(0==e.length)return r.site.syntaxError("invalid syntax"),null;const s=buildTypeParameters(e,!0),a=buildFuncLiteralExpr(e,n,!1);return a?new FuncStatement(t.merge(a.site),r,s,a):null}function buildFuncLiteralExpr(t,e=null,n=!1){const r=assertDefined(t.shift()).assertGroup("(");if(!r)return null;const s=r.site,a=buildFuncArgs(r,e),i=assertToken(t.shift(),s)?.assertSymbol("->");if(!i)return null;const o=Group.find(t,"{");if(-1==o)return s.syntaxError("no function body"),null;0!=o||n||s.syntaxError("no return type specified");const _=buildFuncRetTypeExpr(i.site,t.splice(0,o),n),l=assertToken(t.shift(),s)?.assertGroup("{",1);if(!l)return null;const u=buildValueExpr(l.fields[0]);return u?new FuncLiteralExpr(i.site,a,_,u):null}function buildFuncArgs(t,e=null){const n=[];let r=!1;for(let s=0;s<t.fields.length;s++){const a=t.fields[s].slice(),i=assertToken(a.shift(),t.site)?.assertWord();if(i)if("self"==i.toString())0!=s||null===e?i.syntaxError("'self' is reserved"):a.length>0?a[0].isSymbol(":")?a[0].syntaxError("unexpected type expression after 'self'"):a[0].syntaxError("unexpected token"):n.push(new FuncArg(i,e));else if("_"==i.toString())a.length>0?a[0].isSymbol(":")?a[0].syntaxError("unexpected type expression after '_'"):a[0].syntaxError("unexpected token"):n.push(new FuncArg(i,e));else{i.isKeyword()&&i.syntaxError("unexpected keyword");for(let t of n)t.name.toString()==i.toString()&&i.syntaxError(`duplicate argument '${i.toString()}'`);const t=a.shift();if(void 0===t)i.syntaxError(`expected ':' after '${i.toString()}'`);else{const e=t.assertSymbol(":");if(!e)continue;const s=SymbolToken.find(a,"=");let o=null;if(-1!=s)if(s==a.length-1)a[s].syntaxError("expected expression after '='");else{const t=a.splice(s);t.shift()?.assertSymbol("="),o=buildValueExpr(t),r=!0}else r&&i.syntaxError("positional args must come before default args");let _=null;0==a.length?e.syntaxError("expected type expression after ':'"):_=buildTypeExpr(e.site,a),n.push(new FuncArg(i,_,o))}}}return n}function buildEnumStatement(t,e){const n=assertToken(e.shift(),t,"expected word after 'enum'")?.assertWord()?.assertNotKeyword();if(!n)return null;const r=buildTypeParameters(e,!1),s=assertToken(e.shift(),n.site,`expected '{...}' after 'enum ${n.toString()}'`)?.assertGroup("{",1);if(!s)return null;const[a,i]=splitDataImpl(s.fields[0]);0==a.length&&s.syntaxError("expected at least one enum member");const o=[];for(;a.length>0;){const t=buildEnumMember(a);t&&o.push(t)}let _=new RefExpr(n);r.hasParameters()&&(_=new ParametricExpr(_.site,_,r.parameterNames.map((t=>new RefExpr(new Word(_.site,t))))));const l=buildImplDefinition(i,_,o.map((t=>t.name)),s.site.endSite);return l?new EnumStatement(t.merge(s.site),n,r,o,l):null}function buildImportStatements(t,e){const n=assertToken(e.shift(),t,"expected '{...}' or Word after 'import'");if(!n)return null;if(n.isWord()){const e=buildImportModuleStatement(t,n);return e?[e]:null}return buildImportFromStatements(t,n,e)}function buildImportModuleStatement(t,e){let n=null;if(e instanceof StringLiteral&&importPathTranslator){const t=importPathTranslator(e);if(!t)return null;n=new Word(e.site,t)}else n=e.assertWord()?.assertNotKeyword()??null;return n?new ImportModuleStatement(t,n):null}function buildImportFromStatements(t,e,n){const r=e.assertGroup("{");if(!r)return null;const s=assertToken(n.shift(),e.site,"expected 'from' after 'import {...}'")?.assertWord("from");if(!s)return null;const a=assertToken(n.shift(),s.site,"expected module name after 'import {...} from'");if(!a)return null;let i=null;if(a instanceof StringLiteral&&importPathTranslator){const t=importPathTranslator(a);if(!t)return null;i=new Word(a.site,t)}else i=a.assertWord()?.assertNotKeyword();if(!i)return null;const o=i;return 0===r.fields.length&&r.syntaxError("expected at least 1 import field"),r.fields.map((e=>{const n=e.slice(),s=n.shift();if(void 0===s)return r.syntaxError("empty import field"),null;{const e=s.assertWord();if(e){if(0===n.length)return new ImportFromStatement(t,e,e,o);{const r=n.shift();if(void 0===r)return s.syntaxError(`expected 'as' or nothing after '${e.value}'`),null;{r.assertWord("as");const s=n.shift();if(void 0===s)return r.syntaxError("expected word after 'as'"),null;{const r=s.assertWord();if(!r)return null;const a=n.shift();return void 0!==a?(a.syntaxError("unexpected token"),null):new ImportFromStatement(t,r,e,o)}}}}return null}})).filter((t=>null!==t))}function buildEnumMember(t){const e=assertDefined(t.shift()).assertWord()?.assertNotKeyword();if(e){if(0==t.length||t[0].isWord())return new EnumMember(e,[]);{const n=assertToken(t.shift(),e.site)?.assertGroup("{",1);if(n){const t=buildDataFields(n.fields[0]);return new EnumMember(e,t)}return null}}return null}function buildImplDefinition(t,e,n,r){function s(t){return-1==AUTOMATIC_METHODS.findIndex((e=>e==t.toString()))||(t.syntaxError(`'${t.toString()}' is a reserved member`),!1)}for(let t of n)if(!s(t))return null;const a=buildImplMembers(t,e);function i(t){let e=a[t];s(e.name);for(let t of n)if(t.toString()==e.name.toString())return e.name.syntaxError(`'${e.name.toString()}' is duplicate`),!1;for(let n=t+1;n<a.length;n++)if(a[n].name.toString()==e.name.toString())return a[n].name.syntaxError(`'${e.name.toString()}' is duplicate`),!1;return!0}const o=a.length;for(let t=0;t<o;t++)if(!i(t))return null;return o>0&&null!==r&&a[o-1].site.setEndSite(r),new ImplDefinition(e,a)}function buildImplMembers(t,e){const n=[];for(;0!=t.length;){const r=assertDefined(t.shift()).assertWord();if(!r)continue;const s=r.value;let a=null;"const"==s?a=buildConstStatement(r.site,t):"func"==s?a=buildFuncStatement(r.site,t,e):r.syntaxError("invalid impl syntax"),a&&n.push(a)}return n}function buildTypeExpr(t,e){return 0==e.length?(t.syntaxError("expected token"),null):e[0].isGroup("[")?buildListTypeExpr(t,e):e[0].isWord("Map")?buildMapTypeExpr(t,e):e[0].isWord("Option")?buildOptionTypeExpr(t,e):e[0].isWord("Iterator")?buildIteratorTypeExpr(t,e):e.length>1&&e[0].isGroup("(")&&e[1].isSymbol("->")||e.length>2&&e[0].isGroup("[")&&e[1].isGroup("(")&&e[2].isSymbol("->")?buildFuncTypeExpr(t,e):SymbolToken.find(e,"::")>Group.find(e,"[")?buildTypePathExpr(t,e):Group.find(e,"[")>SymbolToken.find(e,"::")?buildParametricTypeExpr(t,e):1==e.length&&e[0].isWord()?buildTypeRefExpr(t,e):1==e.length&&e[0].isGroup("(")?buildTupleTypeExpr(e[0]):(e[0].syntaxError("invalid type syntax"),null)}function buildParametricTypeExpr(t,e){const n=assertToken(e.pop(),t)?.assertGroup("[");if(!n)return null;const r=buildTypeExpr(n.site,e);if(!r)return null;const s=reduceNull(n.fields.map((t=>buildTypeExpr(n.site,t))));return s?new ParametricExpr(n.site,r,s):null}function buildListTypeExpr(t,e){const n=assertToken(e.shift(),t)?.assertGroup("[",0);if(!n)return null;const r=buildTypeExpr(n.site,e);return r?new ListTypeExpr(n.site,r):null}function buildMapTypeExpr(t,e){const n=assertToken(e.shift(),t)?.assertWord("Map");if(!n)return null;const r=assertToken(e.shift(),n.site,"missing Map key-type");if(!r)return null;const s=r.assertGroup("[",1)?.fields[0];if(null==s)return null;if(0==s.length)return n.syntaxError("missing Map key-type (brackets can't be empty)"),null;const a=buildTypeExpr(n.site,s);if(!a)return null;if(0==e.length)return n.syntaxError("missing Map value-type"),null;const i=buildTypeExpr(n.site,e);return i?new MapTypeExpr(n.site,a,i):null}function buildOptionTypeExpr(t,e){const n=assertToken(e.shift(),t)?.assertWord("Option");if(!n)return null;const r=assertToken(e.shift(),n.site)?.assertGroup("[",1)?.fields[0];if(!r)return null;const s=buildTypeExpr(n.site,r);if(!s)return null;const a=new OptionTypeExpr(n.site,s);if(e.length>0){if(e[0].isSymbol("::")&&e[1].isWord(["Some","None"])){if(e.length>2)return e[2].syntaxError("unexpected token"),null;{const t=e[1].assertWord();return t?new PathExpr(e[0].site,a,t):null}}return e[0].syntaxError("invalid option type syntax"),null}return a}function buildIteratorTypeExpr(t,e){const n=assertToken(e.shift(),t)?.assertWord("Iterator");if(!n)return null;const r=assertToken(e.shift(),n.site,"missing Map key-type");if(!r)return null;const s=r.assertGroup("[");if(!s)return null;const a=reduceNull(s.fields.map((t=>buildTypeExpr(s.site,t))));if(!a)return null;if(a.length<1)throw s.site.typeError("expected at least one type arg for Iterator[...]");return new IteratorTypeExpr(n.site,a)}function buildFuncTypeExpr(t,e){const n=assertToken(e.shift(),t)?.assertGroup("(");if(!n)return null;let r=!1;const s=reduceNull(n.fields.map((t=>{const e=t.slice();if(0==e.length)return n.syntaxError("expected func arg type"),null;const s=buildFuncArgTypeExpr(e[0].site,e);if(!s)return null;if(r){if(!s.isOptional())return s.syntaxError("optional arguments must come last"),null}else s.isOptional()&&(r=!0);return s})));if(!s)return null;if(s.some((t=>t.isNamed()))&&s.some((t=>!t.isNamed())))return s[0].syntaxError("can't mix named and unnamed args in func type"),null;const a=assertToken(e.shift(),n.site)?.assertSymbol("->");if(!a)return null;const i=buildFuncRetTypeExpr(a.site,e,!1);return i?new FuncTypeExpr(n.site,s,i):null}function buildFuncArgTypeExpr(t,e){const n=SymbolToken.find(e,":");if(-1!=n&&1!=n)return e[0].syntaxError("invalid syntax"),null;let r=null;if(-1!=n){if(r=assertToken(e.shift(),t)?.assertWord()?.assertNotKeyword()??null,!r)return null;const n=assertToken(e.shift(),t)?.assertSymbol(":");if(!n)return null;if(0==e.length)return n.syntaxError("expected type expression after ':'"),null}const s=assertToken(e[0],t);if(!s)return null;const a=s.isSymbol("?");if(a){const n=assertToken(e.shift(),t);if(!n)return null;if(0==e.length)return n.syntaxError("invalid type expression after '?'"),null}const i=buildTypeExpr(s.site,e);return i?new FuncArgTypeExpr(null!==r?r.site:i.site,r,i,a):null}function buildFuncRetTypeExpr(t,e,n=!1){if(0===e.length)return n||t.syntaxError("expected type expression after '->'"),null;if(!e[0].isGroup("(")||1!=e.length&&e[1].isSymbol("->"))return buildTypeExpr(t,e);{const n=assertToken(e.shift(),t)?.assertGroup("(");if(n){if(0==n.fields.length)return new VoidTypeExpr(n.site);if(1==n.fields.length)return n.syntaxError("expected 0 or 2 or more types in multi return type"),null;{const t=reduceNull(n.fields.map((t=>(t=t.slice(),buildTypeExpr(n.site,t)))));return t?new TupleTypeExpr(n.site,t):null}}return null}}function buildTypePathExpr(t,e){const n=SymbolToken.findLast(e,"::");assert(-1!=n);const r=buildTypeExpr(e[0].site,e.splice(0,n));if(!r)return null;const s=assertToken(e.shift(),t)?.assertSymbol("::");if(!s)return null;const a=assertToken(e.shift(),s.site)?.assertWord()?.assertNotKeyword();return a?new PathExpr(s.site,r,a):null}function buildTypeRefExpr(t,e){const n=assertToken(e.shift(),t)?.assertWord()?.assertNotKeyword();return n?e.length>0?(e[0].syntaxError("invalid type syntax"),null):new RefExpr(n):null}function buildTupleTypeExpr(t){const e=t.assertGroup("(");if(!e)return null;if(e.fields.length<2)return e.syntaxError("expected at least two items for tuple type"),null;const n=reduceNull(e.fields.map((t=>buildTypeExpr(e.site,t))));return n?new TupleTypeExpr(e.site,n):null}function buildValueExpr(t,e=0){assert(t.length>0);return[function(t,e){return buildMaybeAssignOrChainExpr(t,e)},function(t,e){return buildPipedExpr(t,e)},makeBinaryExprBuilder("||"),makeBinaryExprBuilder("&&"),makeBinaryExprBuilder(["==","!="]),makeBinaryExprBuilder(["<","<=",">",">="]),makeBinaryExprBuilder(["+","-"]),makeBinaryExprBuilder(["*","/","%"]),makeUnaryExprBuilder(["!","+","-"]),function(t,e){return buildChainedValueExpr(t,e)}][e](t,e)}function buildMaybeAssignOrChainExpr(t,e){let n=SymbolToken.find(t,";");const r=SymbolToken.find(t,"=");if(-1==n)return-1!=r?(t[r].syntaxError("invalid assignment syntax, expected ';' after '...=...'"),null):buildValueExpr(t,e+1);if(-1==r||r>n){const r=buildValueExpr(t.splice(0,n),e+1),s=assertDefined(t.shift()).site;if(0==t.length)return s.syntaxError("expected expression after ';'"),null;if(null===r)return null;{const n=buildValueExpr(t,e);return null===n?null:new ChainExpr(s,r,n)}}if(-1!=r&&r<n){const s=t[r].assertSymbol("=");if(!s)return null;const a=s.site,i=buildAssignLhs(a,t.splice(0,r));assertDefined(t.shift()).assertSymbol("="),n=SymbolToken.find(t,";"),assert(-1!=n);let o=t.splice(0,n);if(0==o.length)return a.syntaxError("expected expression between '=' and ';'"),null;const _=buildValueExpr(o,e+1),l=assertToken(t.shift(),a)?.assertSymbol(";");if(!l)return null;const u=l.site;if(0==t.length)return u.syntaxError("expected expression after ';'"),null;const c=buildValueExpr(t,e);return null===c||null===_||null===i?null:new AssignExpr(a,i,_,c)}return t[0].syntaxError("unhandled"),null}function buildDestructExpr(t,e,n=!1){if(0==e.length)return t.syntaxError("expected token inside destructuring braces"),null;let r=assertToken(e.shift(),t);if(!r)return null;if(r.isWord("_"))return 0!=e.length?(r.syntaxError("unexpected tokens after '_'"),null):new DestructExpr(new Word(r.site,"_"),null);{let s=new Word(r.site,"_");if(e.length>=1&&e[0].isSymbol(":")){let t=r.assertWord()?.assertNotKeyword();if(!t)return null;s=t;const n=assertToken(e.shift(),s.site)?.assertSymbol(":");if(!n)return null;if(0==e.length)return n.syntaxError("expected type expression after ':'"),null;if(e[0].isGroup("(")&&!e[0].assertGroup("(")?.fields.some((t=>t.some((t=>t.isSymbol(":")))))){const t=buildTypeExpr(n.site,e);return new DestructExpr(s,t)}const a=buildDestructExprs(e);if(!a)return null;const[i,o]=a;let _=null;if(o)e.length>0&&e[0].syntaxError("unexpected tokens");else if(_=buildTypeExpr(n.site,e),!_)return null;return new DestructExpr(s,_,i,o)}if(0==e.length){if(n){const t=r.assertWord()?.assertNotKeyword();if(!t)return null;const e=new RefExpr(t);return e?new DestructExpr(s,e):null}if(r.isGroup("(")){const t=buildDestructExprs([r]);if(!t)return null;const[e,n]=t;return new DestructExpr(new Word(r.site,"_"),null,e,n)}{const t=r.assertWord()?.assertNotKeyword();return t?new DestructExpr(t,null):null}}{e.unshift(r);const n=buildDestructExprs(e);if(!n)return null;const[a,i]=n;let o=null;if(i)0!=e.length&&e[0].syntaxError("unexpected tokens");else if(o=buildTypeExpr(t,e),!o)return null;return new DestructExpr(s,o,a,i)}}}function buildDestructExprs(t){if(0==t.length)return[[],!1];if(t[t.length-1].isGroup("{")){const e=assertDefined(t.pop()).assertGroup("{");if(!e)return null;const n=e.fields.map((t=>buildDestructExpr(e.site,t)));if(n.every((t=>null!==t&&t.isIgnored()&&!t.hasDestructExprs())))return e.syntaxError("expected at least one used field while destructuring"),null;const r=reduceNull(n);return r?[r,!1]:null}if(t[t.length-1].isGroup("(")){const e=assertDefined(t.pop()).assertGroup("(");if(!e)return null;const n=e.fields.map((t=>buildDestructExpr(e.site,t)));if(n.every((t=>null!==t&&t.isIgnored()&&!t.hasDestructExprs())))return e.syntaxError("expected at least one used field while destructuring a tuple"),null;const r=reduceNull(n);return r?[r,!0]:null}return[[],!1]}function buildAssignLhs(t,e){const n=e.shift();if(void 0===n)return t.syntaxError("expected a name or destruct expression before '='"),null;if(n.isWord()){e.unshift(n);const t=buildDestructExpr(n.site,e);return null===t?null:t.isIgnored()&&!t.hasDestructExprs()?(n.syntaxError(`unused assignment ${n.toString()}`),null):t}if(n.isGroup("(")){const t=[],e=n.assertGroup("(");if(!e)return null;if(e.fields.length<2)return e.syntaxError("expected at least 2 lhs' for multi-assign"),null;let r=!1;for(let n of e.fields){if(0==n.length)return e.syntaxError("unexpected empty field for multi-assign"),null;n=n.slice();const s=buildDestructExpr(e.site,n);if(!s)return null;s.isIgnored()&&!s.hasDestructExprs()||(r=!0),t.forEach((t=>{s.isIgnored()||t.name.value!==s.name.value||s.name.syntaxError(`duplicate name '${s.name.value}' in tuple destruct expr`)})),t.push(s)}return r?new DestructExpr(new Word(e.site,"_"),null,t,!0):(e.syntaxError("expected at least one non-underscore in lhs of multi-assign"),null)}return n.syntaxError("unexpected syntax for lhs of ="),null}function buildPipedExpr(t,e){const n=SymbolToken.findLast(t,["|"]);if(n==t.length-1)return t[n].syntaxError(`invalid syntax, '${t[n].toString()}' can't be used as a post-unary operator`),null;if(0==n)return t[n].syntaxError(`invalid syntax, '${t[n].toString()}' can't be used as a pre-unary operator`),null;if(n>0){if(t[n+1].isSymbol()){const r=assertDefined(t[n+1].assertSymbol());if("."!=r.value&&!(r.value in BINARY_SYMBOLS_MAP))return r.syntaxError("invalid pipe syntax"),null;const s=t.splice(0,n),a=t.shift()?.assertSymbol("|");if(!a)return null;let i=[new Group(a.site,"(",[s])];return i=i.concat(t),buildValueExpr(i,e+1)}{const r=t[n].assertSymbol(),s=buildValueExpr(t.slice(0,n),e);if(!s||!r)return null;const a=buildValueExpr(t.slice(n+1),e+1);return a?new CallExpr(r.site,a,[new CallArgExpr(s.site,null,s)]):null}}return buildValueExpr(t,e+1)}function makeBinaryExprBuilder(t){return function(e,n){const r=SymbolToken.findLast(e,t);if(r==e.length-1)return e[r].syntaxError(`invalid syntax, '${e[r].toString()}' can't be used as a post-unary operator`),null;if(r>0){const t=buildValueExpr(e.slice(0,r),n),s=buildValueExpr(e.slice(r+1),n+1),a=e[r].assertSymbol();return t&&s&&a?new BinaryExpr(a,t,s):null}return buildValueExpr(e,n+1)}}function makeUnaryExprBuilder(t){return function(e,n){if(e[0].isSymbol(t)){const t=buildValueExpr(e.slice(1),n),r=e[0].assertSymbol();return t&&r?new UnaryExpr(r,t):null}return buildValueExpr(e,n+1)}}function buildChainedValueExpr(t,e){return buildRemainingChainedValueExpr(buildChainStartValueExpr(t),t,e)}function buildRemainingChainedValueExpr(t,e,n){for(;e.length>0;){if(null===t)return null;const n=assertDefined(e.shift());if(n.isGroup("("))t=buildCallExpr(n.site,t,assertDefined(n.assertGroup()));else if(n.isGroup("["))t=buildParametricValueExpr(t,assertDefined(n.assertGroup("[")));else if(n.isSymbol(".")&&e.length>0&&e[0].isWord("switch"))t=buildSwitchExpr(t,e);else{if(!n.isSymbol("."))return n.isGroup("{")||n.isSymbol("::")?(n.syntaxError("invalid syntax"),null):(n.syntaxError(`invalid syntax '${n.toString()}'`),null);{const r=assertToken(e.shift(),n.site)?.assertWord()?.assertNotKeyword();if(!r)return null;t=new MemberExpr(n.site,t,r)}}}return t}function buildParametricValueExpr(t,e){const n=reduceNull(e.fields.map((t=>{if(0==t.length)return e.site.syntaxError("unexpected empty field"),null;{const n=buildTypeExpr(e.site,t);return 0!=t.length?(t[0].syntaxError("unexpected token"),null):n}})));return n?new ParametricExpr(e.site,t,n):null}function buildCallExpr(t,e,n){const r=buildCallArgs(n);return null===r?null:new CallExpr(t,e,r)}function buildChainStartValueExpr(t){if(t.length>1&&t[0].isGroup("(")&&t[1].isSymbol("->"))return buildFuncLiteralExpr(t,null,!0);if(t[0].isWord("if"))return buildIfElseExpr(t);if(t[0].isWord("switch"))return t[0].syntaxError("expected '... .switch' instead of 'switch'"),null;if(t[0].isLiteral())return new PrimitiveLiteralExpr(assertDefined(t.shift()));if(t[0].isGroup("("))return buildParensExpr(t);if(-1!=Group.find(t,"{")){if(t[0].isGroup("["))return buildListLiteralExpr(t);if(t[0].isWord("Map")&&t[1].isGroup("["))return buildMapLiteralExpr(t);if(t[0].isWord("Option")&&t[1].isGroup("[")&&t[2].isSymbol("::")&&t[3].isWord("Some"))return buildOptionSomeLiteralExpr(t);{const e=Group.find(t,"{"),n=Word.find(t,"switch"),r=SymbolToken.find(t,".");return-1!=n&&-1!=r&&n<e&&r<e&&n>r?buildValueExpr(t.splice(0,r)):buildStructLiteralExpr(t)}}if(-1!=SymbolToken.find(t,"::"))return buildValuePathExpr(t);if(t[0].isWord()){if(t[0].isWord("const")||t[0].isWord("struct")||t[0].isWord("enum")||t[0].isWord("func")||t[0].isWord("import"))return t[0].syntaxError(`invalid use of '${assertDefined(t[0].assertWord()).value}', can only be used as top-level statement`),null;{const e=assertDefined(t.shift()?.assertWord());if("self"==e.value)return new RefExpr(e);{const t=e.assertNotKeyword();return t?new RefExpr(t):null}}}return t[0].syntaxError("invalid syntax"),null}function buildParensExpr(t){const e=assertDefined(t.shift()).assertGroup("(");if(!e)return null;const n=e.site;if(0===e.fields.length)return e.syntaxError("expected at least one expr in parens"),null;{const t=e.fields.map((t=>buildValueExpr(t))),r=[];return t.forEach((t=>{null!==t&&r.push(t)})),0==r.length?null:new ParensExpr(n,r)}}function buildCallArgs(t){const e=new Set,n=reduceNull(t.fields.map((n=>{const r=buildCallArgExpr(t.site,n);return null!==r&&r.isNamed()&&(e.has(r.name)&&r.syntaxError(`duplicate named call arg ${r.name}`),e.add(r.name)),r})));return null===n?null:n.some((t=>t.isNamed()))&&n.some((t=>!t.isNamed()))?(n[0].syntaxError("can't mix positional and named args"),null):n}function buildCallArgExpr(t,e){if(0==e.length)return t.syntaxError("invalid syntax"),null;let n=null;if(e.length>=2&&e[0].isWord()&&e[1].isSymbol(":")){if(n=assertDefined(e.shift()).assertWord()?.assertNotKeyword(),!n)return null;const t=assertDefined(e.shift());if(0==e.length)return t.syntaxError("expected value expressions after ':'"),null}const r=buildValueExpr(e);return r?new CallArgExpr(null!=n?n.site:r.site,n,r):null}function buildIfElseExpr(t){const e=assertDefined(t.shift()).assertWord("if");if(!e)return null;const n=e.site,r=[],s=[];for(;;){const e=assertToken(t.shift(),n)?.assertGroup("(");if(!e)return null;const a=assertToken(t.shift(),n)?.assertGroup("{");if(!a)return null;if(1!=e.fields.length)return e.syntaxError("expected single if-else condition"),null;if(0==a.fields.length)return a.syntaxError("branch body can't be empty"),null;if(1!=a.fields.length)return a.syntaxError("expected single if-else branch expession"),null;const i=buildValueExpr(e.fields[0]),o=buildValueExpr(a.fields[0]);if(null===i||null===o)continue;r.push(i),s.push(o);const _=t.shift();if(void 0===_){s.push(new VoidExpr(a.site));break}{const e=_.assertWord("else");if(!e)return null;const n=assertToken(t.shift(),e.site);if(n){if(n.isGroup("{")){const t=n.assertGroup();if(!t)return null;if(1!=t.fields.length)return t.syntaxError("expected single expession for if-else branch"),null;const e=buildValueExpr(t.fields[0]);if(!e)return null;s.push(e);break}if(n.isWord("if"))continue;return n.syntaxError("unexpected token"),null}return null}}return new IfElseExpr(n,r,s)}function buildSwitchExpr(t,e){const n=assertDefined(e.shift()).assertWord("switch");if(!n)return null;const r=n.site,s=assertToken(e.shift(),r)?.assertGroup("{");if(!s)return null;const a=[];let i=null;for(let t of s.fields)if(t[0].isWord("else")||t[0].isWord("_")){if(null!==i)return i.syntaxError("duplicate default case in switch"),null;i=buildSwitchDefault(t)}else{if(null!==i)return i.syntaxError("switch default case must come last"),null;const e=buildSwitchCase(t);if(null===e)return null;a.push(e)}const o=new Set;for(let t of a){let e=t.memberName.toString();if(o.has(e))return t.memberName.syntaxError(`duplicate switch case '${e}')`),null;o.add(e)}if(a.length<1)return r.syntaxError("expected at least one switch case"),null;if(a.some((t=>t.isDataMember()))){if(a.length+(null===i?0:1)>5)return r.syntaxError(`too many cases for data switch, expected 5 or less, got ${a.length.toString()}`),null;{let e=0;return a.forEach((t=>{t.isDataMember()||e++})),e>1?(r.syntaxError(`expected at most 1 enum case in data switch, got ${e}`),null):1===e&&a.some((t=>t instanceof UnconstrDataSwitchCase))?(r.syntaxError("can't have both enum and (Int, []Data) in data switch"),null):new DataSwitchExpr(r,t,a,i)}}return new EnumSwitchExpr(r,t,a,i)}function buildSwitchCaseName(t,e,n){const r=e.shift();if(void 0===r)return n?(t.syntaxError("invalid switch case syntax, expected member name after ':'"),null):(t.syntaxError("invalid switch case syntax"),null);if(r.isWord("Map")){const n=e.shift();if(!n)return t.syntaxError("expected token after 'Map'"),null;const s=n.assertGroup("[]",1)?.fields[0];if(null==s)return null;const a=s.shift();if(void 0===a)return n.syntaxError("expected 'Map[Data]Data'"),null;if(a.assertWord("Data"),s.length>0)return s[0].syntaxError("unexpected token after 'Data'"),null;const i=e.shift();return void 0===i?(t.syntaxError("expected token after 'Map[Data]"),null):(i.assertWord("Data"),e.length>0?(e[0].syntaxError("unexpected token after 'Map[Data]Data'"),null):new Word(r.site,"Map[Data]Data"))}if(r.isWord())return e.length>0?(e[0].syntaxError("unexpected token"),null):r?.assertWord()?.assertNotKeyword()??null;if(r.isGroup("[")){r.assertGroup("[",0);const n=e.shift();return void 0===n?(t.syntaxError("expected token after '[]'"),null):e.length>0?(e[0].syntaxError("unexpected token"),null):(n.assertWord("Data"),new Word(r.site,"[]Data"))}return r.syntaxError("invalid switch case name syntax"),null}function buildSwitchCase(t){const e=SymbolToken.find(t,"=>");if(-1==e)return t[0].syntaxError("expected '=>' in switch case"),null;if(0==e)return t[0].syntaxError("expected '<word>' or '<word>: <word>' to the left of '=>'"),null;const n=t.splice(0,e);return 1===n.length&&n[0].isGroup("(")?buildMultiArgSwitchCase(n,t):buildSingleArgSwitchCase(n,t)}function buildSwitchCaseNameType(t){let e=null,n=null;if(-1!=SymbolToken.find(t,":")){const r=assertDefined(t.shift()).assertWord()?.assertNotKeyword();if(!r)return null;e=r;const s=t.shift();if(void 0===s)return e.syntaxError("invalid switch case syntax, expected '(<name>: <enum-member>)', got '(<name>)'"),null;s.assertSymbol(":"),n=buildSwitchCaseName(s.site,t,!0)}else n=buildSwitchCaseName(t[0].site,t,!1);return 0!==t.length?(t[0].syntaxError("unexpected token"),null):null===n?null:[e,n]}function buildMultiArgSwitchCase(t,e){const n=assertDefined(t.shift()).assertGroup("(");if(!n)return null;const r=reduceNull(n.fields.map((t=>buildSwitchCaseNameType(t))));if(null===r)return null;if(assert(0===t.length),2!==r.length)return n.syntaxError(`expected (Int, []Data) case, got (${r.map((t=>t[1].value)).join(", ")}`),null;if("Int"!=r[0][1].value||"[]Data"!=r[1][1].value)return n.syntaxError(`expected (Int, []Data) case, got (${r[0][1].value}, ${r[1][1].value})`),null;{const t=e.shift();if(void 0===t)return n.syntaxError("expected '=>'"),null;{const n=t.assertSymbol("=>");if(!n)return null;const s=buildSwitchCaseBody(n.site,e);return null===s?null:new UnconstrDataSwitchCase(n.site,r[0][0],r[1][0],s)}}}function buildSingleArgSwitchCase(t,e){const n=t[t.length-1].site,r=buildDestructExpr(n,t,!0);if(null===r)return null;if(!r.hasType())return r.site.syntaxError("invalid switch case syntax"),null;const s=e.shift();if(void 0===s)return n.syntaxError("expected '=>'"),null;{const t=s.assertSymbol("=>");if(!t)return null;const n=buildSwitchCaseBody(t.site,e);return null===n?null:new SwitchCase(t.site,r,n)}}function buildSwitchCaseBody(t,e){let n=null;if(0==e.length)return t.syntaxError("expected expression after '=>'"),null;if(e[0].isGroup("{")){if(e.length>1)return e[1].syntaxError("unexpected token"),null;const t=e[0].assertGroup("{",1)?.fields[0];if(null==t)return null;n=buildValueExpr(t)}else n=buildValueExpr(e);return n}function buildSwitchDefault(t){const e=assertDefined(t.shift()).assertWord();if(!e)return null;if(!e.isWord("else")&&!e.isWord("_"))return e.syntaxError("expected 'else' or '_'"),null;const n=e.site,r=t.shift();if(void 0===r)return n.syntaxError(`expected '=>' after '${e.value}'`),null;{const e=r.assertSymbol("=>");if(!e)return null;let n=null;if(0==t.length)return e.syntaxError("expected expression after '=>'"),null;if(t[0].isGroup("{")){if(t.length>1)return t[1].syntaxError("unexpected token"),null;{const e=t[0].assertGroup("{",1)?.fields[0];if(null==e)return null;n=buildValueExpr(e)}}else n=buildValueExpr(t);return n?new SwitchDefault(e.site,n):(e.syntaxError("empty switch default case body"),null)}}function buildListLiteralExpr(t){const e=assertDefined(t.shift()).assertGroup("[",0);if(!e)return null;const n=e.site,r=Group.find(t,"{");if(-1==r)return n.syntaxError("invalid list literal expression syntax"),null;const s=t.splice(0,r),a=buildTypeExpr(n,s.slice());if(!a)return null;const i=assertToken(t.shift(),n)?.assertGroup("{");if(!i)return null;const o=reduceNull(i.fields.map((t=>buildValueExpr(t[0]?.isGroup("{")?s.concat(t):t))));return null===o?null:new ListLiteralExpr(n,a,o)}function buildOptionSomeLiteralExpr(t){const e=t[0].site,n=Group.find(t,"{");if(-1==n)return e.syntaxError("invalid Option[]::Some literal expression syntax"),null;const r=t.splice(0,n),s=assertToken(r[1],e)?.assertGroup("[",1);if(!s)return null;const a=s.fields[0].slice(),i=assertToken(t.shift(),e)?.assertGroup("{",1);if(!i)return null;if(i.fields[0][0]?.isGroup("{")){const e=new Group(i.site,"{",[a.concat(i.fields[0])]);return buildStructLiteralExpr(r.concat(e).concat(t))}return buildStructLiteralExpr(r.concat([i]).concat(t))}function buildMapLiteralExpr(t){const e=assertDefined(t.shift()).assertWord("Map");if(!e)return null;const n=e.site,r=assertDefined(t.shift()).assertGroup("[",1);if(!r)return null;const s=r.fields[0],a=buildTypeExpr(n,s.slice());if(!a)return null;const i=Group.find(t,"{");if(-1==i)return n.syntaxError("invalid map literal expression syntax"),null;const o=t.splice(0,i),_=buildTypeExpr(n,o.slice());if(!_)return null;const l=assertDefined(t.shift()).assertGroup("{");if(!l)return null;const u=reduceNullPairs(l.fields.map((t=>{const e=SymbolToken.find(t,":");if(-1==e)0==t.length?l.syntaxError("unexpected empty field"):t[0].syntaxError("expected ':' in map literal field");else if(0==e)t[e].syntaxError("expected expression before ':' in map literal field");else{if(e!=t.length-1){const n=t.slice(0,e),r=buildValueExpr(n[0]?.isGroup("{")?s.concat(n):n),a=t.slice(e+1);return[r,buildValueExpr(a[0]?.isGroup("{")?o.concat(a):a)]}t[e].syntaxError("expected expression after ':' in map literal field")}return[null,null]})));return null===u?null:new MapLiteralExpr(n,a,_,u)}function buildStructLiteralExpr(t){const e=Group.find(t,"{");assert(-1!=e);const n=t[e].site;if(0==e)return n.syntaxError("expected struct type before braces"),null;const r=buildTypeExpr(n,t.splice(0,e));if(!r)return null;const s=assertDefined(t.shift()).assertGroup("{");if(!s)return null;const a=reduceNull(s.fields.map((t=>buildStructLiteralField(s.site,t))));return null===a?null:a.every((t=>t.isNamed()))||a.every((t=>!t.isNamed()))?new StructLiteralExpr(r,a):(s.site.syntaxError("mangled literal struct (hint: specify all fields positionally or all with keys)"),null)}function buildStructLiteralField(t,e){return e.length>2&&e[0].isWord()&&e[1].isSymbol(":")?buildStructLiteralNamedField(t,e):buildStructLiteralUnnamedField(t,e)}function buildStructLiteralNamedField(t,e){const n=assertToken(e.shift(),t,"empty struct literal field")?.assertWord()?.assertNotKeyword();if(!n)return null;const r=assertToken(e.shift(),n.site,"expected ':' after struct field name")?.assertSymbol(":");if(!r)return null;if(0==e.length)return r.syntaxError("expected expression after ':'"),null;const s=buildValueExpr(e);return s?new StructLiteralField(n,s):null}function buildStructLiteralUnnamedField(t,e){const n=buildValueExpr(e);return n?new StructLiteralField(null,n):null}function buildValuePathExpr(t){const e=SymbolToken.findLast(t,"::");assert(-1!=e);const n=buildTypeExpr(t[e].site,t.splice(0,e));if(!n)return null;const r=assertDefined(t.shift()?.assertSymbol("::")),s=assertToken(t.shift(),r.site)?.assertWord()?.assertNotKeyword();return s?new ValuePathExpr(n.site,n,s):null}export class IRScope{#ut;#en;constructor(t,e){this.#ut=t,this.#en=e}getInternal(t,e){if(null!==this.#en&&t instanceof Word&&this.#en.toString()==t.toString()||t instanceof IRVariable&&this.#en==t)return[e,this.#en];if(null===this.#ut)throw t.referenceError(`variable ${t.toString()} not found`);return this.#ut.getInternal(t,e+1)}get(t){return this.getInternal(t,1)}static isBuiltin(t,e=!1){return!!t.startsWith("__core__")&&(e&&this.findBuiltin(t),!0)}static findBuiltin(t){let e=UPLC_BUILTINS.findIndex((e=>"__core__"+e.name==t));return assert(-1!=e,`${t} is not a real builtin`),e}}export class IRVariable extends Token{#i;constructor(t){super(t.site),this.#i=t}get name(){return this.#i.toString()}toString(){return this.name}copy(t){const e=new IRVariable(this.#i);return t.set(this,e),e}}export class IRNameExpr{site;#i;#F;#en;constructor(t,e=null){this.site=t.site,assert("_"!=t.toString()),assert(!t.toString().startsWith("undefined")),this.#i=t,this.#F=null,this.#en=e}get name(){return this.#i.toString()}get variable(){if(null===this.#en)throw new Error(`variable should be set (name: ${this.name})`);return this.#en}get flatSize(){if(this.isCore()){let t=0,e=this.name;return!e.startsWith("__core__macro")&&e.startsWith("__core__")&&(e.endsWith("__safe")&&(e=e.slice(0,e.length-6)),t=UPLC_BUILTINS[IRScope.findBuiltin(e)].forceCount),13+4*t}return 13}copy(t,e){const n=this.#en?e.get(this.#en)??this.#en:this.#en,r=new IRNameExpr(this.#i,n);return t(this,r),r}isCore(){return this.name.startsWith("__core__")}isParam(){return this.name.startsWith("__PARAM")}isVariable(t){return!this.isCore()&&this.variable===t}toString(t=""){return this.#i.toString()}resolveNames(t){this.isCore()||(null==this.#en||this.isParam()?[this.#F,this.#en]=t.get(this.#i):[this.#F,this.#en]=t.get(this.#en))}toUplc(){return this.isCore()?IRCallExpr.newUplcBuiltin(this.site,this.name):null===this.#F?new UplcVariable(this.site,new UplcInt(this.site,BigInt(0),!1)):new UplcVariable(this.site,new UplcInt(this.site,BigInt(this.#F),!1))}}export class IRLiteralExpr{site;#m;constructor(t){this.site=t.site,this.#m=t}get value(){return this.#m}get flatSize(){return new UplcConst(this.#m).flatSize}toString(t=""){return this.#m.toString()}copy(t,e){return this}resolveNames(t){}toUplc(){return new UplcConst(this.#m)}}export class IRFuncExpr{site;args;body;tag;constructor(t,e,n,r){this.site=t,this.args=e,this.body=assertDefined(n),this.tag=r}get flatSize(){const t=this.args.length;return 4+(t>0?4*(t-1):0)+this.body.flatSize}hasOptArgs(){const t=this.args.some((t=>t.name.startsWith("__useopt__")));return t||this.body instanceof IRFuncExpr&&this.body.hasOptArgs()}toString(t=""){let e=this.body instanceof IRCallExpr&&this.body.func instanceof IRFuncExpr&&1==this.body.args.length&&this.body.func instanceof IRFuncExpr&&this.body.func.args[0].name.startsWith("__")?t:t+TAB,n="("+this.args.map((t=>t.toString())).join(", ")+") -> {\n"+e;return n+=this.body.toString(e),n+="\n"+t+"}",n}resolveNames(t){for(let e of this.args)t=new IRScope(t,e);this.body.resolveNames(t)}copy(t,e){const n=this.args.map((t=>t.copy(e))),r=new IRFuncExpr(this.site,n,this.body.copy(t,e),this.tag);return t(this,r),r}toUplc(){let t=this.body.toUplc();if(0==this.args.length)t=new UplcDelay(this.site,t);else for(let e=this.args.length-1;e>=0;e--)t=new UplcLambda(this.site,t,this.args[e].toString());return t}}export class IRCallExpr{site;func;args;constructor(t,e,n){this.site=t,this.func=e,this.args=n}isSafeBuiltin(){return!!(this.func instanceof IRNameExpr&&this.func.isCore())&&this.func.name.endsWith("__safe")}get builtinName(){if(this.func instanceof IRNameExpr&&this.func.isCore()){let t=this.func.name.toString().slice(8);return t.endsWith("__safe")&&(t=t.slice(0,t.length-6)),t}return""}get flatSize(){return 4+this.args.reduce(((t,e)=>e.flatSize+t),0)+this.func.flatSize}argsToString(t=""){return this.args.map((e=>e.toString(t))).join(", ")}toString(t=""){if("ifThenElse"==this.builtinName)return`__core__${this.builtinName}(\n${t}${TAB}${this.args[0].toString(t+TAB)},\n${t}${TAB}${this.args[1].toString(t+TAB)},\n${t}${TAB}${this.args[2].toString(t+TAB)}\n${t})`;if(""!=this.builtinName)return`__core__${this.builtinName}(${this.argsToString(t)})`;if(this.func instanceof IRFuncExpr&&1==this.func.args.length)return`${this.func.args[0].name} = ${this.args[0].toString(t)};\n${t}${this.func.body.toString(t)}`;{let e=(this.func instanceof IRFuncExpr&&1==this.func.args.length&&this.func.args[0].name.startsWith("__"),"");return`${this.func.toString(t)}(${e}${this.argsToString(t)})`}}resolveNamesInArgs(t){for(let e of this.args)e.resolveNames(t)}resolveNames(t){this.func instanceof IRNameExpr&&this.func.isCore()||this.func.resolveNames(t),this.resolveNamesInArgs(t)}copy(t,e){const n=new IRCallExpr(this.site,this.func.copy(t,e),this.args.map((n=>n.copy(t,e))));return t(this,n),n}toUplcCall(t){if(0==this.args.length)t=new UplcForce(this.site,t);else for(let e of this.args)t=new UplcCall(this.site,t,e.toUplc());return t}static newUplcBuiltin(t,e){assert(e.startsWith("__core__")),e.endsWith("__safe")&&(e=e.slice(0,e.length-6));const n=e.slice(8);let r=new UplcBuiltin(t,n);if(!n.startsWith("macro__")){const n=UPLC_BUILTINS[IRScope.findBuiltin(e)].forceCount;for(let e=0;e<n;e++)r=new UplcForce(t,r)}return r}toUplc(){if(this.func instanceof IRNameExpr&&this.func.name.startsWith("__core__")){let t=IRCallExpr.newUplcBuiltin(this.site,this.func.name);return this.toUplcCall(t)}return this.toUplcCall(this.func.toUplc())}}export class IRErrorExpr{site;#yt;constructor(t,e=""){this.site=t,this.#yt=e}get flatSize(){return 4}toString(t=""){return"error()"}resolveNames(t){}copy(t){const e=new IRErrorExpr(this.site,this.#yt);return t(this,e),e}toUplc(){return new UplcError(this.site,this.#yt)}}export function loopIRExprs(t,e){const n=[t];let r=n.pop();for(;r;){if(r instanceof IRNameExpr)e.nameExpr&&e.nameExpr(r);else if(r instanceof IRErrorExpr)e.errorExpr&&e.errorExpr(r);else if(r instanceof IRLiteralExpr)e.literalExpr&&e.literalExpr(r);else if(r instanceof IRCallExpr){n.push(r.func);for(let t of r.args)n.push(t);e.callExpr&&e.callExpr(r)}else r instanceof IRFuncExpr&&(e.funcExpr&&e.funcExpr(r),n.push(r.body));if(e.exit&&e.exit())return;r=n.pop()}}class IRExprTagger{#Je;constructor(){this.#Je=0}genTag(){return this.#Je+=1,this.#Je}}export function buildIRExpr(t,e=null){let n=null;for(null===e&&(e=new IRExprTagger);t.length>0;){let r=t.shift();if(void 0===r)throw new Error("unexpected: no tokens");if(r.isWord()&&t.length>1&&t[0].isSymbol("=")){const s=assertDefined(assertDefined(t.shift()).assertSymbol("=")).site,a=SymbolToken.find(t,";");assert(-1!=a,"expected semicolon after '='");const i=buildIRExpr(t.splice(0,a),e),o=assertDefined(assertDefined(t.shift()).assertSymbol(";")).site,_=buildIRExpr(t,e),l=assertDefined(r.assertWord());n=new IRCallExpr(s,new IRFuncExpr(o,[new IRVariable(l)],_,e.genTag()),[i])}else if(r.isGroup("(")&&t.length>0&&t[0].isSymbol("->"))assert(null===n,"shouldn't be preceded by an expr"),t.unshift(r),n=buildIRFuncExpr(t,e);else if(r.isGroup("(")){let t=assertDefined(r.assertGroup(),"should be a group");if(null===n)1==t.fields.length?n=buildIRExpr(t.fields[0],e):0==t.fields.length?n=new IRLiteralExpr(new UplcUnit(r.site)):t.syntaxError("unexpected parentheses with multiple fields");else{let s=[];for(let n of t.fields)s.push(buildIRExpr(n,e));n=new IRCallExpr(r.site,n,s)}}else if(r.isSymbol("-")){let e=assertDefined(t.shift(),"expected digit after '-'");if(!(e instanceof IntLiteral))throw e.site.typeError(`expected literal int, got ${e}`);n=new IRLiteralExpr(new UplcInt(e.site,-1n*e.value))}else if(r instanceof BoolLiteral)assert(null===n),n=new IRLiteralExpr(new UplcBool(r.site,r.value));else if(r instanceof IntLiteral)assert(null===n),n=new IRLiteralExpr(new UplcInt(r.site,r.value));else if(r instanceof ByteArrayLiteral)if(assert(null===n),0==r.bytes.length&&null!=t[0]&&t[0]instanceof ByteArrayLiteral){const e=assertDefined(t.shift(),"expected hexadecimal bytestring after '##'");if(!(e instanceof ByteArrayLiteral))throw new Error("unexpected token after '##'");n=new IRLiteralExpr(new UplcDataValue(e.site,UplcData.fromCbor(e.bytes)))}else n=new IRLiteralExpr(new UplcByteArray(r.site,r.bytes));else if(r instanceof StringLiteral)assert(null===n),n=new IRLiteralExpr(new UplcString(r.site,r.value));else if(r.isWord("error")){assert(null===n,"unexpected expr before 'error'");let e=t.shift();if(void 0===e)throw r.site.syntaxError("expected parens after error");assertDefined(e.assertGroup("(",0),"expected empty parens after 'error'"),n=new IRErrorExpr(r.site,"")}else{if(!r.isWord())throw new Error("unhandled untyped token "+r.toString());{const t=assertDefined(r.assertWord(),"expected word");if(null!==n)throw new Error(`unexpected expr '${n.toString()}' before word '${t.value}'`);n=new IRNameExpr(t)}}}if(null===n)throw new Error("expr is null");return n}function buildIRFuncExpr(t,e){let n=t.shift();if(void 0===n)throw new Error("empty func expr");{let r=assertDefined(n.assertGroup("("));assertDefined(t.shift()).assertSymbol("->");let s=assertDefined(assertDefined(t.shift()).assertGroup("{")),a=[];for(let t of r.fields)assert(1==t.length,"expected single word per arg"),a.push(assertDefined(t[0].assertWord()));if(s.fields.length>1)throw s.syntaxError("unexpected comma in function body");if(0==s.fields.length)throw s.syntaxError("empty function body");let i=buildIRExpr(s.fields[0],e);return new IRFuncExpr(r.site,a.map((t=>new IRVariable(t))),i,e.genTag())}}class IRStack{values;#nn;constructor(t,e){this.values=t,this.#nn=e||0==t.length}static isGlobal(t){return null!==t.name.match(/^__(helios|const|module)__/)}dump(t,e=0){return{isLiteral:this.#nn,codes:t.getCodes(this),...e>0?{values:this.values.map((([n,r])=>r.dump(t,e-1)))}:{}}}isLiteral(){return this.#nn}withoutLiterals(){const t=this.values.map((([t,e])=>IRStack.isGlobal(t)?[t,e]:[t,e.withoutLiterals()]));return new IRStack(t,t.every((([t,e])=>e.isLiteral())))}getValue(t){const e=this.values.findIndex((([e])=>e==t));if(-1!=e)return this.values[e][1];throw new Error(`${t.name} not found in IRStack`)}extend(t){return assert(t.every((([t,e])=>!(e instanceof IRErrorValue)))),new IRStack(this.values.concat(t),this.#nn&&t.every((([t,e])=>e.isLiteral())))}filter(t){const e=this.values.filter((([e])=>t.has(e)));return new IRStack(e,e.every((([t,e])=>e.isLiteral())))}static empty(){return new IRStack([],!0)}merge(t){const e=this.values.length;assert(e==t.values.length);let n=IRStack.empty();for(let r=0;r<e;r++){const e=this.values[r],s=t.values[r];n=e==s?n.extend([e]):n.extend([[e[0],IRMultiValue.flatten([e[1],s[1]])]])}return n}}export class IRLiteralValue{value;constructor(t){this.value=t}toString(){return this.value.toString()}isLiteral(){return!0}hasError(t=!0){return!1}withoutLiterals(){return this.value instanceof UplcUnit?new IRAnyValue:new IRDataValue}withoutErrors(){return this}dump(t,e=0){return{type:"Literal",code:t.getCode(this),value:this.toString()}}}export class IRDataValue{isLiteral(){return!1}withoutLiterals(){return this}hasError(t=!0){return!1}withoutErrors(){return this}toString(){return"Data"}dump(t,e=0){return{code:t.getCode(this),type:"Data"}}}function collectIRVariables(t){const e=new Set;return loopIRExprs(t,{nameExpr:t=>{t.isCore()||e.add(t.variable)}}),e}export class IRBuiltinValue{builtin;constructor(t){assert(t.isCore()),this.builtin=t}get builtinName(){let t=this.builtin.name.slice(8);return t.endsWith("__safe")&&(t=t.slice(0,t.length-6)),t}toString(){return`Builtin__${this.builtinName}`}isLiteral(){return!0}withoutLiterals(){return this}hasError(t=!0){return!1}withoutErrors(){return this}dump(t,e=0){return{type:"Builtin",code:t.getCode(this),name:this.builtin.name}}}export class IRFuncValue{stack;definition;constructor(t,e){this.definition=t;const n=collectIRVariables(t);this.stack=e.filter(n)}static new(t,e){return new IRFuncValue(t,e)}isLiteral(){return this.stack.isLiteral()}withoutLiterals(){return new IRFuncValue(this.definition,this.stack.withoutLiterals())}hasError(t=!0){return!1}withoutErrors(){return this}dump(t,e=0){return{type:"Fn",tag:this.definition.tag,codes:t.getCodes(this),definition:this.definition.toString(),stack:this.stack.dump(t,e)}}toString(){return`Fn${this.definition.tag}`}}export class IRErrorValue{isLiteral(){return!1}withoutLiterals(){return this}hasError(t=!0){return!0}withoutErrors(){throw new Error("can't remove IRErrorValue from IRErrorValue")}toString(){return"Error"}dump(t,e=0){return{type:"Error",code:t.getCode(this)}}}export class IRAnyValue{isLiteral(){return!1}withoutLiterals(){return this}hasError(t=!0){return t}withoutErrors(){return this}toString(){return"Any"}dump(t,e=0){return{type:"Any",code:t.getCode(this)}}}export class IRMultiValue{values;constructor(t){assert(t.every((t=>!(t instanceof IRLiteralValue)))),this.values=t}hasError(t=!0){return this.values.some((e=>e.hasError(t)))}isLiteral(){return!1}withoutLiterals(){return IRMultiValue.flatten(this.values.map((t=>t.withoutLiterals())))}hasData(){return this.values.some((t=>t instanceof IRDataValue))}hasLiteral(){return this.values.some((t=>t instanceof IRLiteralValue))}dump(t,e=0){return{type:"Multi",code:t.getCode(this),values:this.values.slice().map((n=>n.dump(t,e)))}}toString(){const t=[];return this.hasError()&&t.push("Error"),this.hasData()&&t.push("Data"),this.values.forEach((e=>{e instanceof IRFuncValue?t.push(`Fn${e.definition.tag}`):e instanceof IRBuiltinValue&&t.push(`Builtin_${e.builtin.name.slice(8)}`)})),this.values.forEach((e=>{e instanceof IRLiteralValue&&t.push(e.toString())})),1==t.length&&"Error"==t[0]&&this.values.some((t=>t instanceof IRAnyValue))&&t.push("Any"),`(${t.join(" | ")})`}static flatten(t){if(1==t.length)return t[0];if(1==(t=t.map((t=>t instanceof IRMultiValue?t.values:[t])).flat()).length)return t[0];if(t.every(((e,n)=>e instanceof IRLiteralValue&&(0==n||e.toString()==t[0].toString()))))return t[0];const e=t.some((t=>t instanceof IRErrorValue)),n=t.some((t=>t instanceof IRDataValue||t instanceof IRLiteralValue&&!(t.value instanceof UplcUnit))),r=t.some((t=>t instanceof IRAnyValue||t instanceof IRLiteralValue&&t.value instanceof UplcUnit));let s=[];if(t.some((t=>t instanceof IRFuncValue||t instanceof IRBuiltinValue))){const e=new Map;t.forEach((t=>{if(t instanceof IRFuncValue){const n=e.get(t.definition);n instanceof IRFuncValue?e.set(t.definition,IRFuncValue.new(t.definition,n.stack.merge(t.stack))):e.set(t.definition,t)}else t instanceof IRBuiltinValue&&e.set(t.builtin,t)})),s=s.concat(Array.from(e.values()))}else n?s.push(new IRDataValue):r&&s.push(new IRAnyValue);return e&&s.push(new IRErrorValue),1==s.length?s[0]:new IRMultiValue(s)}static allPermutations(t){if(t.some((t=>t instanceof IRMultiValue))){const e=[];let n=t.map((t=>t instanceof IRMultiValue?t.values.length:1)),r=n.reduce(((t,e)=>t*e),1);for(let s=0;s<r;s++){let r=s;const a=[];n.forEach((t=>{a.push(r%t),r=Math.floor(r/t)})),e.push(a.map(((e,n)=>{const r=assertDefined(t[n]);return r instanceof IRMultiValue?r.values[e]:(assert(0==e),r)})))}return e}return[t]}withoutErrors(){return IRMultiValue.flatten(this.values.filter((t=>!(t instanceof IRErrorValue))))}}class IRValueCodeMapper{#rn;#sn;#an;constructor(){this.#sn=new Map([["Any",0],["Data",1],["Error",2]]),this.#rn=3,this.#an=new Map}static get maxDepth(){return 10}genCode(t){let e=this.#sn.get(t);return void 0!==e||(e=this.#rn,this.#rn+=1,this.#sn.set(t,e)),e}genCodes(t){if(t instanceof IRBuiltinValue)return new Array(IRValueCodeMapper.maxDepth).fill(this.genCode(t.builtinName));if(t instanceof IRDataValue)return new Array(IRValueCodeMapper.maxDepth).fill(this.genCode("Data"));if(t instanceof IRErrorValue)return new Array(IRValueCodeMapper.maxDepth).fill(this.genCode("Error"));if(t instanceof IRAnyValue)return new Array(IRValueCodeMapper.maxDepth).fill(this.genCode("Any"));if(t instanceof IRLiteralValue)return new Array(IRValueCodeMapper.maxDepth).fill(this.genCode(t.value.toString()));if(t instanceof IRFuncValue){const e=`Fn${assertDefined(t.definition.tag)}`,n=this.getCodes(t.stack),r=[];for(let t=0;t<IRValueCodeMapper.maxDepth;t++){const s=0==t?e:`${e}(${n[t-1]})`;r.push(this.genCode(s))}return r}if(t instanceof IRStack){const e=t.values.map((([t,e])=>this.getCodes(e))),n=[];for(let t=0;t<IRValueCodeMapper.maxDepth-1;t++){const r=`[${e.map((e=>e[t])).join(",")}]`;n.push(this.genCode(r))}return n}if(t instanceof IRMultiValue){const e=t.values.map((t=>this.getCodes(t))),n=[];for(let t=0;t<IRValueCodeMapper.maxDepth;t++){const r=`{${e.map((e=>e[t])).sort().join(",")}}`;n.push(this.genCode(r))}return n}throw new Error("unhandled")}getCodes(t){const e=this.#an.get(t);if(e)return e;const n=this.genCodes(t);return this.#an.set(t,n),n}getCode(t){return this.getCodes(t)[IRValueCodeMapper.maxDepth-1]}getCallCode(t,e){const n=`${assertDefined(this.getCode(t))}(${e.map((t=>this.getCode(t))).join(",")})`;return this.genCode(n)}eq(t,e){return this.getCode(t)==this.getCode(e)}}const IR_BUILTIN_CALLBACKS={addInteger:([t,e])=>new IRDataValue,subtractInteger:([t,e])=>new IRDataValue,multiplyInteger:([t,e])=>t instanceof IRLiteralValue&&0n==t.value.int?t:e instanceof IRLiteralValue&&0n==e.value.int?e:new IRDataValue,divideInteger:([t,e])=>t instanceof IRLiteralValue&&0n==t.value.int?IRMultiValue.flatten([t,new IRErrorValue]):e instanceof IRLiteralValue?0n==e.value.int?new IRErrorValue:1n==e.value.int?t:new IRDataValue:IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),modInteger:([t,e])=>e instanceof IRLiteralValue?1n==e.value.int?new IRLiteralValue(new UplcInt(e.value.site,0n,!0)):0n==e.value.int?new IRErrorValue:new IRDataValue:IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),quotientInteger:([t,e])=>t instanceof IRLiteralValue&&0n==t.value.int?IRMultiValue.flatten([t,new IRErrorValue]):e instanceof IRLiteralValue?0n==e.value.int?new IRErrorValue:1n==e.value.int?t:new IRDataValue:IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),remainderInteger:([t,e])=>e instanceof IRLiteralValue?1n==e.value.int?new IRLiteralValue(new UplcInt(e.value.site,0n,!0)):0n==e.value.int?new IRErrorValue:new IRDataValue:IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),equalsInteger:([t,e])=>new IRDataValue,lessThanInteger:([t,e])=>new IRDataValue,lessThanEqualsInteger:([t,e])=>new IRDataValue,appendByteString:([t,e])=>new IRDataValue,consByteString:([t,e])=>new IRDataValue,sliceByteString:([t,e,n])=>e instanceof IRLiteralValue&&e.value.int<=0n?new IRLiteralValue(new UplcByteArray(e.value.site,[])):new IRDataValue,lengthOfByteString:([t])=>new IRDataValue,indexByteString:([t,e])=>e instanceof IRLiteralValue&&e.value.int<0n||t instanceof IRLiteralValue&&0==t.value.bytes.length?new IRErrorValue:IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),equalsByteString:([t,e])=>new IRDataValue,lessThanByteString:([t,e])=>new IRDataValue,lessThanEqualsByteString:([t,e])=>new IRDataValue,appendString:([t,e])=>new IRDataValue,equalsString:([t,e])=>new IRDataValue,encodeUtf8:([t])=>new IRDataValue,decodeUtf8:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),sha2_256:([t])=>new IRDataValue,sha3_256:([t])=>new IRDataValue,blake2b_256:([t])=>new IRDataValue,verifyEd25519Signature:([t,e,n])=>t instanceof IRLiteralValue&&32!=t.value.bytes.length||n instanceof IRLiteralValue&&64!=n.value.bytes.length?new IRErrorValue:IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),ifThenElse:([t,e,n])=>t instanceof IRLiteralValue?t.value.bool?e:n:IRMultiValue.flatten([e,n]),chooseUnit:([t,e])=>e,trace:([t,e])=>e,fstPair:([t])=>new IRDataValue,sndPair:([t])=>new IRDataValue,chooseList:([t,e,n])=>t instanceof IRLiteralValue?0==t.value.list.length?e:n:IRMultiValue.flatten([e,n]),mkCons:([t,e])=>new IRDataValue,headList:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),tailList:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),nullList:([t])=>new IRDataValue,chooseData:([t,e,n,r,s,a])=>{if(t instanceof IRLiteralValue){const i=t.value.data;if(i instanceof ConstrData)return e;if(i instanceof MapData)return n;if(i instanceof ListData)return r;if(i instanceof IntData)return s;if(i instanceof ByteArrayData)return a;throw new Error("unhandled UplcData type")}return IRMultiValue.flatten([e,n,r,s,a])},constrData:([t,e])=>new IRDataValue,mapData:([t])=>new IRDataValue,listData:([t])=>new IRDataValue,iData:([t])=>new IRDataValue,bData:([t])=>new IRDataValue,unConstrData:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),unMapData:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),unListData:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),unIData:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),unBData:([t])=>IRMultiValue.flatten([new IRDataValue,new IRErrorValue]),equalsData:([t,e])=>new IRDataValue,mkPairData:([t,e])=>new IRDataValue,mkNilData:([t])=>new IRDataValue,mkNilPairData:([t])=>new IRDataValue,serialiseData:([t])=>new IRDataValue};export class IREvaluator{#in;#on;#_n;#ln;#un;#cn;#pn;#hn;#dn;constructor(t=!0){this.#in=[],this.#on=[],this.#_n=new Map,this.#ln=new Map,this.#un=new Map,this.#cn=new Map,this.#pn=new Map,this.#hn=new Map,this.#dn=t}get funcExprs(){return Array.from(this.#cn.keys())}getExprValue(t){return this.#_n.get(t)}getVariableValue(t){return this.#ln.get(t)}countVariableReferences(t){return this.#pn.get(t)?.size??0}getVariableReferences(t){return Array.from(this.#pn.get(t)??[])}countFuncCalls(t){return this.#un.get(t.tag)??0}expectsError(t){const e=this.getExprValue(t);return!e||(e instanceof IRErrorValue||(!!(e instanceof IRMultiValue&&e.hasError())||e instanceof IRAnyValue))}getUnusedFuncVariables(t){const e=[];return t.args.forEach(((t,n)=>{const r=this.#pn.get(t);r&&0!=r.size||e.push(n)})),e}getFuncCallExprs(t){return Array.from(this.#cn.get(t)??[])}onlyDedicatedCallExprs(t){const e=this.getFuncCallExprs(t);return 0!=e.length&&e.every((e=>{if(e.func==t)return!0;const n=this.getExprValue(e.func);if(n){if(n instanceof IRMultiValue)return n.values.every((e=>!(e instanceof IRFuncValue)||e.definition==t));if(n instanceof IRFuncValue)return!0;throw new Error(`unexpected ${n.toString()}`)}return!1}))}noUnusedArgErrors(t,e){return this.getFuncCallExprs(t).every((t=>e.every((e=>!this.expectsError(t.args[e])))))}onlyNestedCalls(t,e){const n=this.getFuncCallExprs(e);return 0!=n.length&&n.every((e=>{if(e.func instanceof IRCallExpr){const n=this.getExprValue(e.func.func);if(n){if(n instanceof IRMultiValue)return n.values.every((e=>!(e instanceof IRFuncValue)||e.definition==t));if(n instanceof IRFuncValue)return n.definition==t;throw new Error(`unexpected ${n.toString()}`)}return!1}return!1}))}notifyCopyExpr(t,e){const n=this.#_n.get(t);n&&this.#_n.set(e,n)}pushExpr(t,e){if(e instanceof IRErrorExpr)this.#in.push({stack:t,expr:e});else if(e instanceof IRLiteralExpr)this.#in.push({stack:t,expr:e});else if(e instanceof IRNameExpr)this.#in.push({stack:t,expr:e});else if(e instanceof IRFuncExpr)this.#in.push({stack:t,expr:e});else{if(!(e instanceof IRCallExpr))throw new Error("unexpected expression type");this.#in.push({stack:t,expr:e}),this.pushExpr(t,e.func),e.args.forEach((e=>this.pushExpr(t,e)))}}setExprValue(t,e){const n=this.#_n.get(t);if(n){const r=IRMultiValue.flatten([n,e]);return this.#_n.set(t,r),r}return this.#_n.set(t,e),e}pushReductionValue(t,e){if(t){const n=this.setExprValue(t,e);(e instanceof IRAnyValue||e instanceof IRMultiValue&&e.values.some((t=>t instanceof IRAnyValue)))&&(e=n)}this.#on.push(e)}getValue(t,e){const n=e.variable,r=this.#pn.get(n);return r?r.add(e):this.#pn.set(n,new Set([e])),t.getValue(n)}callBuiltin(t,e,n){let r=e.name.slice(8);const s=r.endsWith("__safe");s&&(r=r.slice(0,r.length-6));const a=IRMultiValue.allPermutations(n).map((t=>{if(!t.every((t=>t instanceof IRLiteralValue))){if(t.some((t=>t instanceof IRErrorValue)))return new IRErrorValue;{const e=assertDefined(IR_BUILTIN_CALLBACKS[r],`builtin ${r} not defined in IR_BUILTIN_CALLBACKS`)(t);return s&&e instanceof IRMultiValue&&e.hasError()?e.withoutErrors():e}}try{const e=UplcBuiltin.evalStatic(new Word(Site.dummy(),r),t.map((t=>assertClass(t,IRLiteralValue).value)));return new IRLiteralValue(e)}catch(t){if(t instanceof RuntimeError)return new IRErrorValue;throw t}}));this.pushReductionValue(t,IRMultiValue.flatten(a))}incrCallCount(t){const e=this.#un.get(t.tag);e?this.#un.set(t.tag,Math.min(e+1,Number.MAX_SAFE_INTEGER)):this.#un.set(t.tag,1)}mapVarsToValues(t,e){assert(t.length==e.length,"variables and values don't have the same length(["+t.map((t=>t.name)).join(",")+"] vs ["+e.map((t=>t.toString())).join(",")+"]");const n=[];return t.forEach(((t,r)=>{const s=e[r],a=this.#ln.get(t);a?this.#ln.set(t,IRMultiValue.flatten([a,s])):this.#ln.set(t,s),n.push([t,s])})),n}pushFuncCall(t,e,n,r){if(r.some((t=>t instanceof IRErrorValue)))this.pushReductionValue(e,new IRErrorValue);else{r.some((t=>t.hasError(!0)))&&(this.#in.push({multi:2,owner:e}),this.#in.push({value:new IRErrorValue,owner:e}),r=r.map((t=>t.withoutErrors())));const s=this.mapVarsToValues(n.args,r);t=t.extend(s),this.incrCallCount(n),this.#in.push({fn:n,owner:e,stack:t}),this.pushExpr(t,n.body)}}callFunc(t,e,n){const r=e.definition,s=e.stack;if(t instanceof IRCallExpr){const e=this.#cn.get(r);e?e.add(t):this.#cn.set(r,new Set([t]))}this.pushFuncCall(s,t,r,n)}callAnyFunc(t,e,n){if(n.some((t=>t instanceof IRErrorValue)))this.pushReductionValue(t,new IRErrorValue);else{n.some((t=>t.hasError(!1)))&&(this.#in.push({multi:2,owner:t}),this.#in.push({value:new IRErrorValue,owner:t}),n=n.map((t=>t.withoutErrors())));const e=[];n.forEach((t=>{t instanceof IRMultiValue?t.values.forEach((t=>{t instanceof IRFuncValue&&e.push(t)})):t instanceof IRFuncValue&&e.push(t)})),this.#in.push({ignore:e.length,owner:t}),e.forEach((t=>{const e=assertClass(t.definition,IRFuncExpr);this.pushFuncCall(t.stack,null,e,e.args.map((t=>new IRAnyValue)))}))}}cacheValue(t,e,n){const r=this.#hn.get(t);if(r){const t=r.get(e);if(!t||t instanceof IRAnyValue)r.set(e,n);else{const s=IRMultiValue.flatten([t,n]);r.set(e,s)}}else this.#hn.set(t,new Map([[e,n]]))}prepareCacheValue(t,e){this.#in.push({value:new IRAnyValue,cacheExpr:t,code:e})}evalInternal(){const t=new IRValueCodeMapper;let e=this.#in.pop();for(;e;){if("cacheExpr"in e)this.cacheValue(e.cacheExpr,e.code,e.value);else if("expr"in e){const n=e.expr;if(n instanceof IRCallExpr){let e=assertDefined(this.#on.pop()),r=[];for(let t=0;t<n.args.length;t++)r.push(assertDefined(this.#on.pop()));e.isLiteral()&&r.every((t=>t.isLiteral()))||e instanceof IRBuiltinValue||e instanceof IRFuncValue&&1==e.definition.args.length&&IRStack.isGlobal(e.definition.args[0])||(e=e.withoutLiterals(),r=r.map((t=>t.withoutLiterals())));const s=e instanceof IRMultiValue?e.values:[e];s.length>1&&this.#in.push({multi:s.length,owner:n});for(let e of s){const a=t.getCallCode(e,r),i=this.#hn.get(n)?.get(a);if(i){this.pushReductionValue(n,i);for(let t of s)t instanceof IRFuncValue&&this.incrCallCount(t.definition)}else if(this.#in.push({calling:n,code:a,args:r}),e instanceof IRAnyValue)this.callAnyFunc(n,e,r);else if(e instanceof IRErrorValue)this.pushReductionValue(n,new IRErrorValue);else if(e instanceof IRFuncValue)this.callFunc(n,e,r),this.prepareCacheValue(n,a);else{if(!(e instanceof IRBuiltinValue))throw console.log(n.toString()),n.site.typeError("unable to call "+e.toString());this.callBuiltin(n,e.builtin,r),this.prepareCacheValue(n,a)}}}else if(n instanceof IRErrorExpr)this.pushReductionValue(n,new IRErrorValue);else if(n instanceof IRNameExpr)n.isParam()?this.pushReductionValue(n,new IRDataValue):n.isCore()?this.pushReductionValue(n,new IRBuiltinValue(n)):this.pushReductionValue(n,this.getValue(e.stack,n));else if(n instanceof IRLiteralExpr)this.#dn?this.pushReductionValue(n,new IRLiteralValue(n.value)):n.value instanceof UplcUnit?this.pushReductionValue(n,new IRAnyValue):this.pushReductionValue(n,new IRDataValue);else{if(!(n instanceof IRFuncExpr))throw new Error("unexpected expr type");this.#on.push(IRFuncValue.new(n,e.stack))}}else if("calling"in e){const t=assertDefined(this.#on.pop());this.cacheValue(e.calling,e.code,t),this.pushReductionValue(e.calling,t)}else if("fn"in e&&e.fn instanceof IRFuncExpr){const t=e.owner,n=assertDefined(this.#on.pop());this.setExprValue(e.fn,n),this.pushReductionValue(t,n)}else if("multi"in e){const t=[];for(let n=0;n<e.multi;n++)t.push(assertDefined(this.#on.pop()));this.pushReductionValue(e.owner,IRMultiValue.flatten(t))}else if("value"in e)this.pushReductionValue(e.owner,e.value);else{if(!("ignore"in e))throw new Error("unexpected term");{const t=[new IRAnyValue];for(let n=0;n<e.ignore;n++)assertDefined(this.#on.pop())instanceof IRErrorValue&&t.push(new IRErrorValue);this.pushReductionValue(e.owner,IRMultiValue.flatten(t))}}e=this.#in.pop()}}evalFirstPass(t){this.pushExpr(IRStack.empty(),t),this.evalInternal();const e=assertDefined(this.#on.pop());if(assert(0==this.#on.length,"expected a single reduction value in first phase ["+this.#on.map((t=>t.toString())).join(", ")+"]"),e instanceof IRFuncValue)return e;if(e instanceof IRLiteralValue)return e;if(e instanceof IRMultiValue&&e.values.some((t=>t instanceof IRAnyValue)))return e;throw console.log(annotateIR(this,t)),new Error(`expected entry point function, got ${e.toString()}`)}evalSecondPass(t){const e=assertClass(t.definition,IRFuncExpr),n=e.args.map((t=>new IRDataValue));this.callFunc(e,t,n),this.evalInternal();const r=assertDefined(this.#on.pop());assert(0==this.#on.length,"expected a single reduction value in second phase ["+r.toString()+", "+this.#on.map((t=>t.toString())).join(", ")+"]");const s=r instanceof IRMultiValue?r.values:[r];for(let t of s);return IRMultiValue.flatten(s)}eval(t){const e=this.evalFirstPass(t);return e instanceof IRFuncValue?this.evalSecondPass(e):e}evalConst(t){const e=this.evalFirstPass(t);if(e instanceof IRLiteralValue){let t=e.value;if(t instanceof UplcDataValue)return t.data;if(t instanceof UplcInt)return new IntData(t.int);if(t instanceof UplcBool)return new ConstrData(t.bool?1:0,[]);if(t instanceof UplcList){if(t.isDataList())return new ListData(t.list.map((t=>t.data)));if(t.isDataMap())return new MapData(t.list.map((t=>{const e=assertClass(t,UplcPair);return[e.key,e.value]})))}else{if(t instanceof UplcString)return new ByteArrayData(textToBytes(t.string));if(t instanceof UplcByteArray)return new ByteArrayData(t.bytes)}throw new Error(`unable to turn '${t.toString()}' into data`)}throw new Error("expected IRLiteralValue")}}export function annotateIR(t,e){const n=(e,r)=>{if(e instanceof IRLiteralExpr)return e.value.toString();if(e instanceof IRErrorExpr)return"error()";if(e instanceof IRNameExpr){const n=t.getExprValue(e);return n?`${e.name}: ${n.toString()}`:e.name}if(e instanceof IRFuncExpr){const s=t.getExprValue(e),a=1==e.args.length&&e.args[0].name.startsWith("__"),i=r+(a?"":TAB);let o="";const _=t.countFuncCalls(e);return o=_==Number.MAX_SAFE_INTEGER?"∞":_.toString(),`Fn${e.tag}(${e.args.map((e=>{const n=t.getVariableValue(e);return n?`${e.name}: ${n.toString()}`:e.name})).join(", ")})${o} -> ${s?s.toString()+" ":""}{\n${i}${n(e.body,i)}\n${r}}`}if(e instanceof IRCallExpr){if(e.func instanceof IRFuncExpr&&1==e.args.length)return`${e.func.args[0].name} = ${n(e.args[0],r)};\n${r}${n(e.func.body,r)}`;{const s=t.getExprValue(e),a=e.func instanceof IRFuncExpr&&1==e.func.args.length&&e.func.args[0].name.startsWith("__"),i=(e.func instanceof IRFuncExpr&&1==e.func.args.length&&e.func.args[0].name,`(${a?`\n${r}${TAB}`:""}${e.args.map((t=>`\n${r}${TAB}${n(t,r+TAB)}`)).join(",")}${e.args.length>0||a?`\n${r}`:""})${s?`: ${s.toString()}`:""}`);return e.func instanceof IRNameExpr?`${e.func.toString()}${i}`:`${n(e.func,r)}${i}`}}throw new Error("unhandled IRExpr")};return n(e,"")}const INLINE_MAX_SIZE=128;function isIdentityFunc(t){return!!(t instanceof IRFuncExpr&&1==t.args.length&&t.body instanceof IRNameExpr&&t.body.isVariable(t.args[0]))}export class IROptimizerState{#mn;constructor(){this.#mn=0}incrCommonExprCount(){this.#mn+=1}get commonExprCount(){return this.#mn}}export class IROptimizer{#fn;#yn;#gn;#wn;constructor(t,e){this.#fn=new IREvaluator,this.#yn=t,IROptimizer.assertNoDuplicateExprs(t),this.#gn=e,this.#wn=new Map,this.init()}expectsError(t){return this.#fn.expectsError(t)}countFuncCalls(t){return this.#fn.countFuncCalls(t)}newFuncExpr(t,e,n){const r=new IRFuncExpr(t.site,e,n,t.tag);return this.#fn.notifyCopyExpr(t,r),r}init(){this.#fn.eval(this.#yn),config.DEBUG&&console.log(annotateIR(this.#fn,this.#yn)),this.removeUnusedArgs(),this.replaceUncalledArgsWithUnit(),this.#fn=new IREvaluator,this.#fn.eval(this.#yn),config.DEBUG&&console.log(annotateIR(this.#fn,this.#yn)),this.flattenNestedFuncExprs()}removeUnusedArgs(){this.#fn.funcExprs.filter((t=>{const e=this.#fn.getUnusedFuncVariables(t);return e.length>0&&this.#fn.onlyDedicatedCallExprs(t)&&this.#fn.noUnusedArgErrors(t,e)})).forEach((t=>{const e=this.#fn.getUnusedFuncVariables(t),n=new Set(e);this.#fn.getFuncCallExprs(t).forEach((t=>{t.args=t.args.filter(((t,e)=>!n.has(e)))})),t.args=t.args.filter(((t,e)=>!n.has(e)))}))}replaceUncalledArgsWithUnit(){loopIRExprs(this.#yn,{callExpr:t=>{t.args=t.args.map((t=>t instanceof IRFuncExpr&&0==this.#fn.countFuncCalls(t)?new IRLiteralExpr(new UplcUnit(t.site)):t))}})}collectFuncExprs(){const t=[];return loopIRExprs(this.#yn,{funcExpr:e=>{t.push(e)}}),t}flattenNestedFuncExprs(){const t=this.collectFuncExprs(),e=new Set;t.forEach((t=>{if(e.has(t))return;let n=t,r=t.args.slice(),s=1;for(;n.body instanceof IRFuncExpr&&this.#fn.onlyDedicatedCallExprs(n.body)&&this.#fn.onlyNestedCalls(n,n.body);)s+=1,n=n.body,r=r.concat(n.args.slice()),e.add(n);if(1==s)return;const a=this.#fn.getFuncCallExprs(n);assert(a.length>0),a.forEach((t=>{let e=t,n=[];for(let t=0;t<s;t++)n.push(e.args.slice()),t<s-1&&(e=assertClass(e.func,IRCallExpr));t.func=e.func,t.args=n.reverse().flat()})),t.args=r,t.body=n.body}))}isEvaluatedMoreThanOnce(t,e){const n=new Map;let r=!1;loopIRExprs(t,{funcExpr:t=>{n.set(t.body,t)},callExpr:t=>{n.set(t.func,t),t.args.forEach((e=>{n.set(e,t)}))},nameExpr:t=>{r=t==e},exit:()=>r});let s=n.get(e);for(;s&&s!=t;){if(s instanceof IRFuncExpr&&this.countFuncCalls(s)>1)return!0;s=n.get(s)}return!1}inline(t,e){this.#wn.set(t,e)}optimizeNameExpr(t){const e=this.#fn.getExprValue(t);if(e){if(e instanceof IRLiteralValue)return new IRLiteralExpr(e.value);if(e instanceof IRErrorValue)return new IRErrorExpr(t.site)}if(!t.isCore()){const e=this.#wn.get(t.variable);if(e)return e.copy(((t,e)=>{this.#fn.notifyCopyExpr(t,e)}),new Map)}return t}optimizeBuiltinCallExpr(t){const e=t.builtinName,n=t.args;switch(e){case"addInteger":{const[t,e]=n;if(t instanceof IRLiteralExpr&&0n==t.value.int)return e;if(e instanceof IRLiteralExpr&&0n==e.value.int)return t;break}case"subtractInteger":{const[t,e]=n;if(e instanceof IRLiteralExpr&&0n==e.value.int)return t;break}case"multiplyInteger":{const[t,e]=n;if(t instanceof IRLiteralExpr&&1n==t.value.int)return e;if(e instanceof IRLiteralExpr&&1n==e.value.int)return t;break}case"divideInteger":{const[t,e]=n;if(e instanceof IRLiteralExpr&&1n==e.value.int)return t;break}case"quotientInteger":{const[t,e]=n;if(e instanceof IRLiteralExpr&&1n==e.value.int)return t;break}case"appendByteString":{const[t,e]=n;if(t instanceof IRLiteralExpr&&0==t.value.bytes.length)return e;if(e instanceof IRLiteralExpr&&0==e.value.bytes.length)return t;break}case"appendString":{const[t,e]=n;if(t instanceof IRLiteralExpr&&""==t.value.string)return e;if(e instanceof IRLiteralExpr&&""==e.value.string)return t;break}case"decodeUtf8":{const[t]=n;if(t instanceof IRCallExpr&&t.func instanceof IRNameExpr&&"encodeUtf8"==t.builtinName)return t.args[0];break}case"ifThenElse":{const[e,r,s]=n;if(e instanceof IRLiteralExpr){if(e.value.bool&&!this.expectsError(s))return r;if(!e.value.bool&&!this.expectsError(r))return s}else{if(!this.expectsError(e)&&r.toString()==s.toString())return r;if(e instanceof IRCallExpr&&e.func instanceof IRNameExpr&&"nullList"==e.builtinName){const n=new IRCallExpr(t.site,new IRNameExpr(new Word(t.site,"__core__chooseList")),[e.args[0],r,s]);return this.#fn.notifyCopyExpr(t,n),n}}break}case"chooseUnit":{const[t,e]=n;if(t instanceof IRLiteralExpr&&t.value instanceof UplcUnit)return e;if(e instanceof IRLiteralExpr&&e.value instanceof UplcUnit)return t;break}case"trace":{const[t,e]=n;if(!this.expectsError(t))return e;break}case"chooseList":{const[t,e,r]=n;if(t instanceof IRLiteralExpr){if(0==t.value.list.length&&!this.expectsError(r))return e;if(t.value.list.length>0&&!this.expectsError(e))return r}break}case"chooseData":{const[t,e,r,s,a,i]=n;if(t instanceof IRLiteralExpr){if(t.value.data instanceof ConstrData&&!this.expectsError(r)&&!this.expectsError(s)&&!this.expectsError(a)&&!this.expectsError(i))return e;if(t.value.data instanceof MapData&&!this.expectsError(e)&&!this.expectsError(s)&&!this.expectsError(a)&&!this.expectsError(i))return r;if(t.value.data instanceof ListData&&!this.expectsError(e)&&!this.expectsError(r)&&!this.expectsError(a)&&!this.expectsError(i))return s;if(t.value.data instanceof IntData&&!this.expectsError(e)&&!this.expectsError(r)&&!this.expectsError(s)&&!this.expectsError(i))return a;if(t.value.data instanceof ByteArrayData&&!this.expectsError(e)&&!this.expectsError(r)&&!this.expectsError(s)&&!this.expectsError(a))return i}else if(t instanceof IRCallExpr&&t.func instanceof IRNameExpr&&!this.expectsError(t)){if(!("constrData"!=t.builtinName||this.expectsError(r)||this.expectsError(s)||this.expectsError(a)||this.expectsError(i)))return e;if(!("mapData"!=t.builtinName||this.expectsError(e)||this.expectsError(s)||this.expectsError(a)||this.expectsError(i)))return r;if(!("listData"!=t.builtinName||this.expectsError(e)||this.expectsError(r)||this.expectsError(a)||this.expectsError(i)))return s;if(!("iData"!=t.builtinName||this.expectsError(e)||this.expectsError(r)||this.expectsError(s)||this.expectsError(i)))return a;if(!("bData"!=t.builtinName||this.expectsError(e)||this.expectsError(r)||this.expectsError(s)||this.expectsError(a)))return i}break}case"unMapData":{const[t]=n;if(t instanceof IRCallExpr&&t.func instanceof IRNameExpr&&"mapData"==t.builtinName)return t.args[0];break}case"unListData":{const[t]=n;if(t instanceof IRCallExpr&&t.func instanceof IRNameExpr&&"listData"==t.builtinName)return t.args[0];break}case"unIData":{const[t]=n;if(t instanceof IRCallExpr&&t.func instanceof IRNameExpr&&"iData"==t.builtinName)return t.args[0];break}case"unBData":{const[t]=n;if(t instanceof IRCallExpr&&t.func instanceof IRNameExpr&&"bData"==t.builtinName)return t.args[0];break}case"equalsData":{const[e,r]=n;if(e instanceof IRCallExpr&&e.func instanceof IRNameExpr&&"iData"==e.builtinName&&r instanceof IRCallExpr&&r.func instanceof IRNameExpr&&"iData"==r.builtinName){const n=new IRCallExpr(t.site,new IRNameExpr(new Word(t.site,"__core__equalsInteger")),[e.args[0],r.args[0]]);return this.#fn.notifyCopyExpr(t,n),n}if(e instanceof IRCallExpr&&e.func instanceof IRNameExpr&&"bData"==e.builtinName&&r instanceof IRCallExpr&&r.func instanceof IRNameExpr&&"bData"==r.builtinName){const n=new IRCallExpr(t.site,new IRNameExpr(new Word(t.site,"__core__equalsByteString")),[e.args[0],r.args[0]]);return this.#fn.notifyCopyExpr(t,n),n}break}}return t}optimizeCallExpr(t){const e=this.#fn.getExprValue(t);if(e){if(e instanceof IRLiteralValue)return new IRLiteralExpr(e.value);if(e instanceof IRErrorValue)return new IRErrorExpr(t.site)}let n=t.func,r=t.args.map((t=>this.optimizeInternal(t)));if(isIdentityFunc(n))return assert(1==r.length),r[0];if(n instanceof IRNameExpr){const t=this.#fn.getExprValue(n);if(t instanceof IRFuncValue&&isIdentityFunc(t.definition))return assert(1==r.length),r[0]}if(n instanceof IRFuncExpr){let t=new Set;const e=n,s=n.args;if(r.forEach(((n,r)=>{const a=s[r];if(n instanceof IRNameExpr)t.add(r),this.inline(a,n);else if(n instanceof IRFuncExpr&&(1==this.#fn.countVariableReferences(a)||n.flatSize<=128))t.add(r),this.inline(a,n);else if(n instanceof IRCallExpr&&1==this.#fn.countVariableReferences(a)&&!this.expectsError(n)){const s=this.#fn.getVariableReferences(a)[0];this.isEvaluatedMoreThanOnce(e,s)||(t.add(r),this.inline(a,n))}})),t.size>0){r=r.filter(((e,n)=>!t.has(n)));const e=this.newFuncExpr(n,n.args.filter(((e,n)=>!t.has(n))),n.body);n=e}}if(0==r.length&&n instanceof IRFuncExpr&&0==n.args.length)return this.optimizeInternal(n.body);const s=new IRCallExpr(t.site,this.optimizeInternal(n),r);this.#fn.notifyCopyExpr(t,s);return""!=s.builtinName?this.optimizeBuiltinCallExpr(s):s}optimizeFuncExpr(t){return(t=this.newFuncExpr(t,t.args,this.optimizeInternal(t.body))).body instanceof IRCallExpr&&(t.body.func instanceof IRNameExpr||t.body.func instanceof IRFuncExpr)&&t.body.args.length==t.args.length&&t.body.args.every(((e,n)=>e instanceof IRNameExpr&&e.isVariable(t.args[n])&&1==this.#fn.countVariableReferences(t.args[n])))?t.body.func:t}optimizeInternal(t){return(()=>{if(t instanceof IRLiteralExpr)return t;if(t instanceof IRErrorExpr)return t;if(t instanceof IRNameExpr)return this.optimizeNameExpr(t);if(t instanceof IRCallExpr)return this.optimizeCallExpr(t);if(t instanceof IRFuncExpr)return this.optimizeFuncExpr(t);throw new Error("unhandled IRExpr")})()}static assertNoDuplicateExprs(t){const e=new Set;loopIRExprs(t,{nameExpr:n=>{if(e.has(n))throw console.log(t.toString()),new Error("duplicate IRNameExpr "+n.name);e.add(n)}})}optimize(){const t=this.optimizeInternal(this.#yn);return IROptimizer.assertNoDuplicateExprs(t),t}}export class IRProgram{#wt;#Tt;constructor(t,e){this.#wt=t,this.#Tt=e}static assertValidRoot(t){if(t instanceof IRFuncExpr||t instanceof IRCallExpr||t instanceof IRLiteralExpr)return t;throw new Error("invalid IRExpr type for IRProgram")}static new(t,e,n=!1,r=new IRScope(null,null)){let[s,a]=t.generateSource();const i=null!==s.match(/\b__helios__tx__time_range\b/);let o=buildIRExpr(tokenizeIR(s,a));try{o.resolveNames(r),n&&(o=IRProgram.simplify(o)),o.resolveNames(r);return new IRProgram(IRProgram.assertValidRoot(o),{purpose:e,callsTxTimeRange:i})}catch(t){throw console.log(new Source(s,"").pretty()),t}}annotate(){const t=new IREvaluator;return t.eval(this.#wt),annotateIR(t,this.#wt)}static simplify(t){let e=!0,n=t.toString(),r=new IROptimizerState;for(;e;){e=!1;const s=(t=new IROptimizer(t,r).optimize()).toString();s!=n&&(e=!0,n=s)}return t}get expr(){return this.#wt}get properties(){return this.#Tt}get site(){return this.#wt.site}get data(){if(this.#wt instanceof IRLiteralExpr){let t=this.#wt.value;if(t instanceof UplcDataValue)return t.data;if(t instanceof UplcInt)return new IntData(t.int);if(t instanceof UplcBool)return new ConstrData(t.bool?1:0,[]);if(t instanceof UplcList){if(t.isDataList())return new ListData(t.list.map((t=>t.data)));if(t.isDataMap())return new MapData(t.list.map((t=>{const e=assertClass(t,UplcPair);return[e.key,e.value]})))}else{if(t instanceof UplcString)return new ByteArrayData(textToBytes(t.string));if(t instanceof UplcByteArray)return new ByteArrayData(t.bytes)}}throw new Error(`unable to turn '${this.toString()}' into data`)}toString(){return this.#wt.toString()}toUplc(){return new UplcProgram(this.#wt.toUplc(),this.#Tt)}calcSize(){return this.toUplc().calcSize()}}export class IRParametricProgram{#Tn;#bn;constructor(t,e){this.#Tn=t,this.#bn=e}static new(t,e,n,r=!1){let s=new IRScope(null,null);for(let t=0;t<n;t++){const e=`__PARAM_${t}`;s=new IRScope(s,new IRVariable(new Word(Site.dummy(),e)))}const a=IRProgram.new(t,e,r,s);return new IRParametricProgram(a,n)}get program(){return this.#Tn}toUplc(){let t=this.#Tn.expr.toUplc();for(let e=0;e<this.#bn;e++)t=new UplcLambda(Site.dummy(),t);return new UplcProgram(t,this.#Tn.properties)}}class Module{#i;#tn;constructor(t,e){this.#i=t,this.#tn=e,this.#tn.forEach((t=>t.setBasePath(`__module__${this.#i.toString()}`)))}static new(t){let e="";const n=extractScriptPurposeAndName(t);n&&(e=n[1]);const r=new Source(t,e),s=tokenize(r);if(r.throwErrors(),null===s)throw new Error("should've been thrown above");if(0==s.length)throw UserError.syntaxError(r,0,1,"empty script");const[a,i,o,_]=buildScript(s,"module");if(r.throwErrors(),null!==i)return new Module(i,o);throw new Error("unexpected")}throwErrors(){this.#i.site.src.throwErrors()}get name(){return this.#i}get statements(){return this.#tn.slice()}loopConstStatements(t,e){for(let n of this.#tn)n.loopConstStatements(t,e)}toString(){return this.#tn.map((t=>t.toString())).join("\n")}evalTypes(t){for(let e of this.statements)e.eval(t)}filterDependencies(t,e=[]){let n=[],r=[this];r=r.concat(e);for(let s of this.#tn)if(s instanceof ImportFromStatement||s instanceof ImportModuleStatement){let a=s.moduleName.value;if(a==this.name.value)throw s.syntaxError("can't import self");if(e.some((t=>t.name.value==a)))throw s.syntaxError("circular import detected");if(!n.some((t=>t.name.value==a))){let e=t.find((t=>t.name.value==a));if(void 0===e)throw s.referenceError(`module '${a}' not found`);{let s=e.filterDependencies(t,r).concat([e]).filter((t=>!n.some((e=>e.name.value==t.name.value))));n=n.concat(s)}}}return n}}class MainModule extends Module{constructor(t,e){super(t,e)}get mainFunc(){for(let t of this.statements)if("main"==t.name.value){if(t instanceof FuncStatement)return t;throw t.typeError("'main' isn't a function statement")}throw new Error("'main' not found (is a module being used as an entrypoint?)")}}const DEFAULT_PROGRAM_CONFIG={allowPosParams:!1,invertEntryPoint:!1};export class Program{#xn;#In;#En;#Jt;#Xt;constructor(t,e,n){this.#xn=t,this.#In=e,this.#En=n,this.#Jt={},this.#Xt={}}throwErrors(){this.#In.forEach((t=>t.throwErrors()))}static parseMainInternal(t){let e="";const n=extractScriptPurposeAndName(t);n&&(e=n[1]);const r=new Source(t,e),s=tokenize(r);if(r.throwErrors(),null===s)throw new Error("should've been thrown above");if(0==s.length)throw UserError.syntaxError(r,0,1,"empty script");const[a,i,o,_]=buildScript(s);if(r.throwErrors(),null!==a&&null!==i){const t=[new MainModule(i,o.slice(0,_+1))];return _<o.length-1&&t.push(new Module(i,o.slice(_+1))),[a,t]}throw new Error("unexpected")}static parseImports(t,e=[]){let n=e.map((t=>Module.new(t))),r=new Set;r.add(t);for(let t of n){if(r.has(t.name.value))throw t.name.syntaxError(`non-unique module name '${t.name.value}'`);r.add(t.name.value)}return n}static parseMain(t,e){let[n,r]=Program.parseMainInternal(t);const s=r[0].name.site,a=Program.parseImports(r[0].name.value,e),i=r[0].filterDependencies(a);let o=[];if(r.length>1&&(o=r[r.length-1].filterDependencies(a).filter((t=>!i.some((e=>e.name.value==t.name.value))))),r=i.concat([r[0]]).concat(o).concat(r.slice(1)),"module"==n)throw s.syntaxError("can't use module for main");return[n,r]}static new(t,e=[],n={},r=DEFAULT_PROGRAM_CONFIG){return Program.newInternal(t,e,{},r)}static newInternal(t,e=[],n={},r=DEFAULT_PROGRAM_CONFIG){const[s,a]=Program.parseMain(t,e);let i;switch(s){case"testing":i=new TestingProgram(a);break;case"spending":i=new SpendingProgram(a,r);break;case"minting":i=new MintingProgram(a,r);break;case"staking":i=new StakingProgram(a,r);break;case"endpoint":i=new EndpointProgram(a);break;default:throw new Error("unhandled script purpose")}const o=i.evalTypes(n);return i.throwErrors(),"endpoint"!=s&&i.fillTypes(o),i}get config(){return this.#En}get nPosParams(){return 0}get posParams(){return this.mainArgTypes.slice(0,this.nPosParams)}get mainImportedModules(){let t=[];for(let e of this.#In){if(e instanceof MainModule)break;t.push(e)}return t}get mainModule(){for(let t of this.#In)if(t instanceof MainModule)return t;throw new Error("MainModule not found")}get postModule(){let t=this.#In[this.#In.length-1];return t instanceof MainModule?null:t}get purpose(){return this.#xn}get name(){return this.mainModule.name.value}get mainFunc(){return this.mainModule.mainFunc}get mainRetExprSite(){return this.mainFunc.retSite}get mainArgNames(){return this.mainFunc.argNames}get mainArgTypes(){return this.mainFunc.argTypes.map((t=>assertDefined(t.asDataType)))}get mainPath(){return this.mainFunc.path}get mainStatements(){return this.mainModule.statements}get mainAndPostStatements(){let t=this.mainModule.statements;return null!=this.postModule&&(t=t.concat(this.postModule.statements)),t}get allStatements(){let t=[];for(let e=0;e<this.#In.length;e++){let n=this.#In[e],r=!(n instanceof MainModule||e==this.#In.length-1);t=t.concat(n.statements.map((t=>[t,r])))}return t}toString(){return this.#In.map((t=>t.toString())).join("\n")}evalTypesInternal(t){const e=new TopScope(t);for(let t=0;t<this.#In.length;t++){const n=this.#In[t],r=n===this.postModule?e.getModuleScope(this.mainModule.name):new ModuleScope(e);n.evalTypes(r),n instanceof MainModule&&e.setStrict(!1),n!==this.postModule&&e.setScope(n.name,r)}return e}evalTypes(t={}){throw new Error("not yet implemented")}get types(){return this.#Jt}fillTypes(t){t.getModuleScope(this.mainModule.name).loopTypes(((t,e)=>{e?.asDataType?.offChainType&&(this.#Jt[t]=e.asDataType.offChainType)}))}loopConstStatements(t){const e=this.postModule;for(let n of this.#In){const r=n instanceof MainModule||n===e?"":`${n.name.value}::`;n.loopConstStatements(r,t)}}get paramTypes(){let t={};return this.loopConstStatements(((e,n)=>{t[e]=n.type})),t}changeParamSafe(t,e){let n=!1;if(this.loopConstStatements(((r,s)=>{n||r==t&&(s.changeValueSafe(e),n=!0)})),!n)throw this.mainFunc.referenceError(`param '${t}' not found`)}findConstStatement(t){let e=null;return this.loopConstStatements(((n,r)=>{null===e&&t==n&&(e=r)})),e}evalConst(t){const e=new ToIRContext(!1),n=this.fetchDefinitions(e,new IR(""),((e,n)=>{let r=!1;return e.loopConstStatements("",((e,n)=>{r||n===t&&(r=!0)})),r})),r=t.path,s=new IR(r),a=this.wrapInner(e,s,n),[i,o]=a.generateSource(),_=buildIRExpr(tokenizeIR(i,o)),l=new IRScope(null,null);_.resolveNames(l);const u=new IREvaluator;try{const t=u.evalConst(_);return new UplcDataValue(_.site,t)}catch(t){throw console.log(i),t}}evalParam(t){let e=this.findConstStatement(t);if(!e)throw new Error(`param '${t}' not found`);return this.evalConst(e)}get parameters(){const t=this,e=this.paramTypes,n={get(n,r){if(r in n)return n[r];{const s=assertDefined(e[r],`invalid param name '${r}'`),a=t.evalParam(r),i=assertDefined(s.offChainType).fromUplcData(a.data);return n[r]=i,i}},set(n,r,s){let a=!1;if(r.startsWith("?")&&(r=r.slice(1),a=!0),e[r]){const a=assertDefined(e[r].offChainType,`invalid param name '${r}'`),i=s instanceof a?s:new a(s);n[r]=i,t.changeParamSafe(r,i._toUplcData())}else if(!a)throw new Error(`invalid parameter name '${r}'`);return!0}};return new Proxy(this.#Xt,n)}set parameters(t){const e=this.parameters;for(let n in t)e[n]=t[n]}statementsToIR(t,e){const n=new Map;for(let[r,s]of this.allStatements)if(r.toIR(t,n),e(r,s))break;return n}static injectMutualRecursions(t,e){const n=Array.from(e.keys()),r=(t,r)=>{const s=[t];let a=new Set;for(;s.length>0;){const t=assertDefined(s.shift()),r=assertDefined(e.get(t)),i=n.slice(n.findIndex(t.includes("[")?(t=>e=>e.startsWith(t))(t.split("[")[0]):e=>e==t)).filter((t=>!a.has(t)));for(let e=0;e<i.length;e++){const n=i[e];r.includes(n)&&(a.add(n),n!=t&&s.push(n))}}return r.filter((t=>a.has(t)))};for(let s=n.length-1;s>=0;s--){const a=n[s];if(a.startsWith("__const")&&s==n.length-1||a.startsWith("__helios")||a.endsWith("__from_data")&&!config.CHECK_CASTS||a.includes("____"))continue;let i=assertDefined(a.match(/(__const)?([^[]+)(\[|$)/))[0];const o=n.slice(s).filter((t=>(t.startsWith(i)||t.startsWith(`__const${i}`))&&!(t.endsWith("__from_data")&&!config.CHECK_CASTS)&&!t.includes("____"))),_=r(a,o);if(_.length>0){const r=a.replace(/\[/g,"\\[").replace(/]/g,"\\]"),s=new RegExp(`\\b${r}(\\b|$)`,"gm"),i=`${a}(${_.join(", ")})`;for(let t of n)e.set(t,assertDefined(e.get(t)).replace(s,i));t=t.replace(s,i);const o=new IR([new IR(`(${_.join(", ")}) -> {`),assertDefined(e.get(a)),new IR("}")]);e.set(a,o)}}return t}static applyTypeParameters(t,e,n){const r=fetchRawGenerics(t),s=new Map,a=(t,e)=>{if(n.has(t)||s.has(t))return;const i=IRParametricName.parse(t),o=i.toTemplate(),_=i.toTemplate(!0);let l=r.get(t)??r.get(o)??r.get(_)??n.get(o);if(!l)throw new Error(`${o} undefined in ir`);if(l instanceof IR)l=i.replaceTemplateNames(l),s.set(t,[e,l]),l.search(RE_IR_PARAMETRIC_NAME,(e=>a(e,t)));else{const n=l(i.ttp,i.ftp);s.set(t,[e,n]),n.search(RE_IR_PARAMETRIC_NAME,(e=>a(e,t)))}};for(let[t,e]of n)e.search(RE_IR_PARAMETRIC_NAME,(e=>a(e,t)));e.search(RE_IR_PARAMETRIC_NAME,(t=>a(t,"main")));let i=Array.from(n.entries());const o=t=>{for(let e=i.length-1;e>=0;e--)if(i[e][0]==t)return e;if("main"==t)return i.length;throw new Error(`${t} not found`)},_=Array.from(s.entries());for(let t=0;t<_.length;t++){const[e,[n,r]]=_[t],s=o(n);i=i.slice(0,s).concat([[e,r]]).concat(i.slice(s))}return i=i.filter((([t,e])=>!IRParametricName.isTemplate(t))),new Map(i)}collectAllUsed(t,e){const n=new Set,r=[t],s=/__[a-zA-Z0-9_[\]@]+/g;for(;r.length>0;){assertDefined(r.pop()).search(s,(t=>{if(!n.has(t)){n.add(t);const s=e.get(t);s&&r.push(s)}}))}return n}eliminateUnused(t,e){const n=this.collectAllUsed(t,e),r=new Map;for(let[t,s]of e)n.has(t)&&r.set(t,s);return this.loopConstStatements(((t,r)=>{const s=r.path;if(n.has(s)&&!e.has(r.path))throw r.site.referenceError(`used unset const '${t}' (hint: use program.parameters['${t}'] = ...)`)})),r}fetchDefinitions(t,e,n){let r=this.statementsToIR(t,n);return Program.applyTypeParameters(t,e,r)}wrapInner(t,e,n){e=Program.injectMutualRecursions(e,n),n=this.eliminateUnused(e,n);const r=fetchRawFunctions(t,assertClass(e=IR.wrapWithDefinitions(e,n),IR),n);return e=IR.wrapWithDefinitions(e,r)}wrapEntryPoint(t,e,n=null){let r=this.fetchDefinitions(t,e,(t=>"main"==t.name.value));return n&&(r=new Map(Array.from(n.entries()).concat(Array.from(r.entries())))),this.wrapInner(t,e,r)}toIRInternal(t){throw new Error("not yet implemented")}toIR(t,e=null){const n=this.toIRInternal(t);return this.wrapEntryPoint(t,n,e)}get requiredParameters(){const t=this.toIRInternal(new ToIRContext(!1)),e=this.fetchDefinitions(new ToIRContext(!1),t,(t=>"main"==t.name.value)),n=this.collectAllUsed(t,e),r=[];return this.loopConstStatements(((t,e)=>{!e.isSet()&&n.has(e.path)&&r.push([t,e.type])})),r}dumpIR(t=!1,e=!1){const n=this.toIR(new ToIRContext(t)),r=IRProgram.new(n,this.#xn,t);return e?new Source(r.annotate(),this.name).pretty():new Source(r.toString(),this.name).pretty()}compile(t=!1){const e=this.toIR(new ToIRContext(t));if(this.nPosParams>0){return IRParametricProgram.new(e,this.#xn,this.nPosParams,t).toUplc()}return IRProgram.new(e,this.#xn,t).toUplc()}}class RedeemerProgram extends Program{constructor(t,e,n=DEFAULT_PROGRAM_CONFIG){super(t,e,n)}get nPosParams(){return this.mainFunc.nArgs-(this.config.invertEntryPoint?0:2)}evalTypesInternal(t){const e=super.evalTypesInternal(t),n=this.mainFunc,r=n.argTypeNames,s=n.argTypes,a=n.retType,i=s.length;if(this.config.allowPosParams){if(i<2)return n.typeError("expected at least 2 args for main"),e}else if(2!=i)return n.typeError("expected 2 args for main"),e;for(let t=0;t<i;t++)t==i-1?""==r[t]||(new ScriptContextType).isBaseOf(s[t])||n.typeError(`illegal type for arg ${i} in main, expected 'ScriptContext', got ${s[t].toString()}`):""==r[t]||(new DefaultTypeClass).isImplementedBy(s[t])||n.typeError(`illegal ${t==i-2?"redeemer ":""}argument type in main: '${s[t].toString()}`);return BoolType.isBaseOf(a)||n.typeError(`illegal return type for main, expected 'Bool', got '${a.toString()}'`),e}evalTypes(t={}){const e=GlobalScope.new(t);return this.evalTypesInternal(e)}toIRInternal(t){const e=this.config.invertEntryPoint?[]:["redeemer","ctx"],n=e.length,r=this.mainFunc.nArgs,s=this.mainFunc.argTypeNames,a=this.mainArgTypes.map(((t,a)=>{const i=a>=r-n?e[a-(r-n)]:`__PARAM_${a.toString()}`;return""!=s[a]?new IR([new IR(`${assertNonEmpty(t.path)}__from_data`),new IR("("),new IR(i),new IR(")")]):new IR("0")}));let i=new IR([new IR(`${TAB}${TAB}__core__ifThenElse`),new IR("(",this.mainRetExprSite),new IR(`\n${TAB}${TAB}${TAB}${this.mainPath}(`),new IR(a).join(", "),new IR(`),\n${TAB}${TAB}${TAB}() -> {()},\n${TAB}${TAB}${TAB}() -> {__helios__error("validation returned false")}\n${TAB}${TAB})`),new IR("(",this.mainRetExprSite),new IR(")")]);if(n>0){const t=e.map((t=>new IR(t)));i=new IR([new IR(`${TAB}\n${TAB}(`),new IR(t).join(", "),new IR(") -> {\n"),i,new IR(`\n${TAB}}`)])}return i}toString(){return`${this.purpose} ${this.name}\n${super.toString()}`}}export class DatumRedeemerProgram extends Program{constructor(t,e,n){super(t,e,n)}get nPosParams(){return this.mainFunc.nArgs-(this.config.invertEntryPoint?0:3)}get datumType(){return this.mainArgTypes[0]}get datumTypeName(){return this.mainFunc.argTypeNames[0]}evalTypesInternal(t){const e=super.evalTypesInternal(t),n=this.mainFunc,r=n.argTypeNames,s=n.argTypes,a=n.retType,i=n.nArgs;if(this.config.allowPosParams){if(s.length<3)return n.typeError("expected at least 3 args for main"),e}else if(3!=s.length)return n.typeError("expected 3 args for main"),e;for(let t=0;t<i;t++)t==i-1?""==r[t]||(new ScriptContextType).isBaseOf(s[t])||n.typeError(`illegal type for arg ${i} in main: expected 'ScriptContext', got '${s[t].toString()}'`):""==r[t]||(new DefaultTypeClass).isImplementedBy(s[t])||n.typeError(`illegal type for arg ${t+1} in main ${t==i-2?"(datum) ":t==i-3?"(redeemer) ":""}: '${s[t].toString()}`);return BoolType.isBaseOf(a)||n.typeError(`illegal return type for main, expected 'Bool', got '${a.toString()}'`),e}evalTypes(t){const e=GlobalScope.new(t);return this.evalTypesInternal(e)}toIRInternal(t){const e=this.config.invertEntryPoint?[]:["datum","redeemer","ctx"],n=e.length,r=this.mainFunc.nArgs,s=this.mainFunc.argTypeNames,a=this.mainArgTypes.map(((t,a)=>{const i=a>=r-n?e[a-(r-n)]:`__PARAM_${a.toString()}`;return""!=s[a]?new IR([new IR(`${assertNonEmpty(t.path)}__from_data`),new IR("("),new IR(i),new IR(")")]):new IR("0")}));let i=new IR([new IR(`${TAB}${TAB}__core__ifThenElse`),new IR("(",this.mainRetExprSite),new IR(`\n${TAB}${TAB}${TAB}${this.mainPath}(`),new IR(a).join(", "),new IR(`),\n${TAB}${TAB}${TAB}() -> {()},\n${TAB}${TAB}${TAB}() -> {__helios__error("validation returned false")}\n${TAB}${TAB})`),new IR("(",this.mainRetExprSite),new IR(")")]);if(n>0){const t=e.map((t=>new IR(t)));i=new IR([new IR(`${TAB}\n${TAB}(`),new IR(t).join(", "),new IR(") -> {\n"),i,new IR(`\n${TAB}}`)])}return i}datumCheckToIR(t){if(""==this.datumTypeName)return new IR("(data) -> {data}");{const e=this.datumType.path,n=new IR(`(data) -> {${e}____to_data(${e}__from_data(data))}`);return this.wrapEntryPoint(t,n)}}compileDatumCheck(){const t=this.datumCheckToIR(new ToIRContext(!1));return IRProgram.new(t,null,!1).toUplc()}toString(){return`${this.purpose} ${this.name}\n${super.toString()}`}}class GenericProgram extends Program{constructor(t,e,n){super(t,e,n)}toString(){return`${this.purpose} ${this.name}\n${super.toString()}`}evalTypes(t){const e=GlobalScope.new(t),n=super.evalTypesInternal(e),r=this.mainFunc,s=r.argTypeNames,a=r.argTypes,i=r.retType;return s.forEach(((t,e)=>{""==t||(new DefaultTypeClass).isImplementedBy(a[e])||r.typeError(`illegal argument type in main: '${a[e].toString()}`)})),(new DefaultTypeClass).isImplementedBy(i)||r.typeError(`illegal return type for main: '${i.toString()}'`),n}toIRInternal(t){const e=this.mainFunc.argTypeNames,n=this.mainArgTypes.map(((t,n)=>""!=e[n]?new IR([new IR(`${assertNonEmpty(t.path)}__from_data`),new IR("("),new IR(`arg${n}`),new IR(")")]):new IR("0")));let r=new IR([new IR(`${this.mainPath}(`),new IR(n).join(", "),new IR(")")]);const s=assertDefined(this.mainFunc.retType.asDataType);r=new IR([new IR(`${s.path}____to_data`),new IR("("),r,new IR(")")]);const a=this.mainFunc.argTypes.map(((t,e)=>new IR(`arg${e}`)));return r=new IR([new IR(`${TAB}\n${TAB}(`),new IR(a).join(", "),new IR(`) -> {\n${TAB}${TAB}`),r,new IR(`\n${TAB}}`)]),r}}class TestingProgram extends GenericProgram{constructor(t){super("testing",t,DEFAULT_PROGRAM_CONFIG)}}class SpendingProgram extends DatumRedeemerProgram{constructor(t,e){super("spending",t,e)}}class MintingProgram extends RedeemerProgram{constructor(t,e=DEFAULT_PROGRAM_CONFIG){super("minting",t,e)}}class StakingProgram extends RedeemerProgram{constructor(t,e=DEFAULT_PROGRAM_CONFIG){super("staking",t,e)}}class EndpointProgram extends GenericProgram{constructor(t){super("endpoint",t,DEFAULT_PROGRAM_CONFIG)}evalTypes(t={}){const e=GlobalScope.new(t),n=super.evalTypesInternal(e),r=this.mainFunc,s=r.argTypes,a=r.argTypeNames,i=r.retType;if(0==a.length)return r.typeError("expected at least argument 'ContractContext'"),n;if(a.forEach(((t,e)=>{e==a.length-1||""==t||(new DefaultTypeClass).isImplementedBy(s[e])||r.typeError(`illegal argument type in main: '${s[e].toString()}`)})),""!=a[a.length-1]){const t=s[s.length-1];t instanceof ContractContextType||r.typeError(`expected 'ContractContext' for arg ${s.length}, got '${t.toString()}'`)}return(new DefaultTypeClass).isImplementedBy(i)||r.typeError(`illegal return type for main: '${i.toString()}'`),n}}export class NativeContext{#Cn;#Sn;#vn;constructor(t,e,n){this.#Cn=t,this.#Sn=e,this.#vn=n}isAfter(t){return null!==this.#Cn?this.#Cn>=t:(console.error("Warning: tx validity time range start not set but checked in native script"),!1)}isBefore(t){return null!==this.#Sn?this.#Sn<t:(console.error("Warning: tx validity time range end not set but checked in native script"),!1)}isSignedBy(t){return this.#vn.some((e=>e.eq(t)))}}export class NativeScript extends CborData{#f;constructor(t){super(),this.#f=t}typeToCbor(){return Cbor.encodeInteger(BigInt(this.#f))}static fromCbor(t){const e="string"==typeof t?hexToBytes(t):t;0==e[0]&&e.shift();let n=-1,r=-1n,s=null;if(Cbor.decodeTuple(e,((t,e)=>{if(0==t)n=Number(Cbor.decodeInteger(e));else switch(n){case 0:assert(1==t),s=new NativeSig(PubKeyHash.fromCbor(e));break;case 1:case 2:{assert(1==t);const r=[];switch(Cbor.decodeList(e,((t,e)=>{r.push(NativeScript.fromCbor(e))})),n){case 1:s=new NativeAll(r);break;case 2:s=new NativeAny(r);break;default:throw new Error("unexpected")}}break;case 3:if(1==t)r=Cbor.decodeInteger(e);else{assert(2==t);const n=[];Cbor.decodeList(e,((t,e)=>{n.push(NativeScript.fromCbor(e))})),s=new NativeAtLeast(Number(r),n)}break;case 4:case 5:switch(assert(1==t),r=Cbor.decodeInteger(e),n){case 4:s=new NativeAfter(r);break;case 5:s=new NativeBefore(r);break;default:throw new Error("unexpected")}break;default:throw new Error("unexpected")}})),s)return s;throw new Error("unable to deserialize native script")}static fromJson(t){const e="string"==typeof t?JSON.parse(t):t,n=e.type;if(!n)throw new Error("invalid Native script");switch(n){case"sig":{const t=e.keyHash;if(!t)throw new Error("invalid NativeKey script");return new NativeSig(PubKeyHash.fromHex(t))}case"all":{const t=e.scripts;if(!t)throw new Error("invalid NativeAll script");return new NativeAll(t.map((t=>NativeScript.fromJson(t))))}case"any":{const t=e.scripts;if(!t)throw new Error("invalid NativeAny script");return new NativeAny(t.map((t=>NativeScript.fromJson(t))))}case"atLeast":{const t=e.required;if("number"!=typeof t)throw new Error("invalid NativeAtLeast script");const n=e.scripts;if(!n)throw new Error("invalid NativeAtLeast script");return new NativeAtLeast(t,n.map((t=>NativeScript.fromJson(t))))}case"after":{const t=e.slot;if("number"!=typeof t)throw new Error("invalid NativeAfter script");return new NativeAfter(BigInt(t))}case"before":{const t=e.slot;if("number"!=typeof t)throw new Error("invalid NativeAfter script");return new NativeBefore(BigInt(t))}default:throw new Error(`unrecognized NativeScript type '${n}'`)}}toJson(){throw new Error("not implemented")}eval(t){throw new Error("not implemented")}hash(){let t=this.toCbor();return t.unshift(0),Crypto.blake2b(t,28)}get validatorHash(){return new ValidatorHash(this.hash())}get mintingPolicyHash(){return new MintingPolicyHash(this.hash())}}class NativeSig extends NativeScript{#Rn;constructor(t){super(0),this.#Rn=t}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),this.#Rn.toCbor()])}toJson(){return{type:"sig",keyHash:this.#Rn.hex}}eval(t){return t.isSignedBy(this.#Rn)}}class NativeAll extends NativeScript{#te;constructor(t){super(1),assert(t.length>0),this.#te=t}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeDefList(this.#te)])}toJson(){return{type:"all",scripts:this.#te.map((t=>t.toJson()))}}eval(t){return this.#te.every((e=>e.eval(t)))}}class NativeAny extends NativeScript{#te;constructor(t){super(2),assert(t.length>0),this.#te=t}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeDefList(this.#te)])}toJson(){return{type:"any",scripts:this.#te.map((t=>t.toJson()))}}eval(t){return this.#te.some((e=>e.eval(t)))}}class NativeAtLeast extends NativeScript{#Pn;#te;constructor(t,e){super(3),assert(e.length>=t),this.#Pn=t,this.#te=e}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeInteger(BigInt(this.#Pn)),Cbor.encodeDefList(this.#te)])}toJson(){return{type:"atLeast",required:this.#Pn,scripts:this.#te.map((t=>t.toJson()))}}eval(t){return this.#te.reduce(((e,n)=>e+(n.eval(t)?1:0)),0)>=this.#Pn}}class NativeAfter extends NativeScript{#Dn;constructor(t){super(4),this.#Dn=t}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeInteger(this.#Dn)])}toJson(){const t=Number(this.#Dn);return BigInt(t)!=this.#Dn&&console.error("Warning: slot overflow (not representable by Number in Native script Json)"),{type:"after",slot:t}}eval(t){return t.isAfter(this.#Dn)}}class NativeBefore extends NativeScript{#Dn;constructor(t){super(5),this.#Dn=t}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeInteger(this.#Dn)])}toJson(){const t=Number(this.#Dn);return BigInt(t)!=this.#Dn&&console.error("Warning: slot overflow (not representable by Number in Native script Json)"),{type:"before",slot:t}}eval(t){return t.isBefore(this.#Dn)}}export class Tx extends CborData{#Fn;#$n;#kn;#Bn;#An;#Mn;constructor(t=new TxBody,e=new TxWitnesses,n=!1,r=null,s=null,a=null){super(),this.#Fn=t,this.#$n=e,this.#kn=n,this.#Bn=r,this.#An=s,this.#Mn=a}static new(){return new Tx}get body(){return this.#Fn}get bodyHash(){return this.#Fn.hash()}get witnesses(){return this.#$n}isValid(t){return!!this.#kn&&this.#Fn.isValid(t)}toCbor(){return Cbor.encodeTuple([this.#Fn.toCbor(),this.#$n.toCbor(),Cbor.encodeBool(this.#kn),null===this.#Bn?Cbor.encodeNull():this.#Bn.toCbor()])}withoutMetadata(){return new Tx(this.#Fn,this.#$n,this.#kn,null,this.#An,this.#Mn)}static fromCbor(t){let e="string"==typeof t?hexToBytes(t):t;e=e.slice();let n=new Tx;return assert(4==Cbor.decodeTuple(e,((t,e)=>{switch(t){case 0:n.#Fn=TxBody.fromCbor(e);break;case 1:n.#$n=TxWitnesses.fromCbor(e);break;case 2:n.#kn=Cbor.decodeBool(e);break;case 3:Cbor.isNull(e)?(Cbor.decodeNull(e),n.#Bn=null):n.#Bn=TxMetadata.fromCbor(e);break;default:throw new Error("bad tuple size")}}))),assert(0==e.length),n}static async finalizeUplcData(t,e,n,r,s){const a=t.fields;assert(12==a.length);const i=a[0].list.map((t=>TxInput.fromUplcData(t))),o=a[1].list.map((t=>TxInput.fromUplcData(t))),_=a[2].list.map((t=>TxOutput.fromUplcData(t))),l=Value.fromUplcData(a[4]).assets,u=a[8].list.map((t=>PubKeyHash.fromUplcData(t))),c=a[9].map.map((([t,e])=>{if(1==t.index){assert(1==t.fields.length);const n=TxOutputId.fromUplcData(t.fields[0]),r=i.findIndex((t=>t.txId.eq(n.txId)&&t.utxoIdx==n.utxoIdx));return assert(-1!=r),new SpendingRedeemer(i[r],r,e)}if(0==t.index){assert(1==t.fields.length);const n=MintingPolicyHash.fromUplcData(t.fields[0]),r=l.mintingPolicies.findIndex((t=>t.eq(n)));return assert(-1!=r),new MintingRedeemer(n,r,e)}throw new Error("unhandled redeemer constr index")})),p=new Tx;return i.forEach(((t,e)=>{const n=c.find((t=>t instanceof SpendingRedeemer&&t.inputIndex==e))??null;if(n instanceof SpendingRedeemer){if(p.addInput(t,n.data),!t.address.validatorHash)throw new Error("unexpected (expected a validator address");if(!(t.address.validatorHash.hex in s))throw new Error(`script for SpendingRedeemer (vh:${t.address.validatorHash.hex}) not found in [${Object.keys(s).join(", ")}]`);{const e=s[t.address.validatorHash.hex];e instanceof UplcProgram?p.attachScript(e):p.attachScript(e())}}else assert(null===n),p.addInput(t)})),o.forEach((t=>{p.addRefInput(t)})),r=r.filter((t=>i.every((e=>!e.eq(t)))&&o.every((e=>!e.eq(t))))),_.forEach((t=>{p.addOutput(t)})),l.mintingPolicies.forEach(((t,e)=>{const n=c.find((t=>t instanceof MintingRedeemer&&t.mphIndex==e))??null;if(!(n instanceof MintingRedeemer))throw new Error("missing MintingRedeemer");if(p.mintTokens(t,l.getTokens(t),n.data),!(t.hex in s))throw new Error(`policy for mph ${t.hex} not found in ${Object.keys(s)}`);{const e=s[t.hex];e instanceof UplcProgram?p.attachScript(e):p.attachScript(e())}})),u.forEach((t=>{p.addSigner(t)})),await p.finalize(e,n,r)}toTxData(t){return this.#Fn.toTxData(t,this.witnesses.redeemers,this.witnesses.datums,this.id())}async completeInputData(t){await this.#Fn.completeInputData(t,this.#$n)}dump(t=null){return{body:this.#Fn.dump(),witnesses:this.#$n.dump(t,this.#Fn),metadata:null!==this.#Bn?this.#Bn.dump():null,valid:this.#kn,id:this.#kn?this.id().toString():"invalid"}}validFrom(t){return assert(!this.#kn),this.#Mn=t,this}validTo(t){return assert(!this.#kn),this.#An=t,this}mintTokens(t,e,n){const r=MintingPolicyHash.fromProps(t);if(assert(!this.#kn),this.#Fn.addMint(r,e),n)this.#$n.addMintingRedeemer(r,UplcDataValue.unwrap(n));else if(!this.#$n.isNativeScript(r))throw new Error("no redeemer specified for minted tokens (hint: if this policy is a NativeScript, attach that script before calling tx.mintTokens())");return this}addInput(t,e=null){if(assert(!this.#kn),null===t.origOutput)throw new Error("TxInput.origOutput must be set when building transaction");if(this.#Fn.addInput(t),null!==e){assert(null!==t.origOutput.address.validatorHash,"input isn't locked by a script");const n=e instanceof HeliosData?e._toUplcData():UplcDataValue.unwrap(e);if(this.#$n.addSpendingRedeemer(t,n),null===t.origOutput.datum)throw new Error("expected non-null datum");{let e=t.origOutput.datum;if(e instanceof HashedDatum){let t=e.data;if(null===t)throw new Error("expected non-null datum data");this.#$n.addDatumData(t)}}}else if(null===t.origOutput.address.pubKeyHash&&!this.#$n.isNativeScript(assertDefined(t.origOutput.address.validatorHash)))throw new Error("input is locked by a script, but redeemer isn't specified (hint: if this is a NativeScript, attach that script before calling tx.addInput())");return this}addInputs(t,e=null){for(let n of t)this.addInput(n,e);return this}addRefInput(t,e=null){return assert(!this.#kn),this.#Fn.addRefInput(t),null!==e&&this.#$n.attachPlutusScript(e,!0),this}addRefInputs(t){for(let e of t){const t=e.origOutput.refScript;this.addRefInput(e,t)}return this}addOutput(t){return assert(!this.#kn),this.#Fn.addOutput(t),this}addOutputs(t){for(let e of t)this.addOutput(e);return this}addSigner(t){return assert(!this.#kn),this.#Fn.addSigner(t),this}addDCert(t){return this.#Fn.addDCert(t),this}attachScript(t){return assert(!this.#kn),t instanceof NativeScript?this.#$n.attachNativeScript(t):this.#$n.attachPlutusScript(t),this}addCollateral(t){return assert(!this.#kn),this.#Fn.addCollateral(t),this}estimateFee(t){let[e,n]=t.txFeeParams;if(!this.#kn){let t=this.#Fn.countUniqueSigners();this.#$n.addDummySignatures(t)}let r=this.toCbor().length;return this.#kn||this.#$n.removeDummySignatures(),BigInt(e)+BigInt(r)*BigInt(n)+this.#$n.estimateFee(t)}setFee(t,e){let n=this.#Fn.fee;for(;n!=e;)this.#Fn.setFee(e),n=e,e=this.estimateFee(t);return e}checkScripts(){let t=this.#$n.scripts;const e=new Set;t.forEach((t=>{e.add(bytesToHex(t.hash()))}));let n=new Map;if(this.#Fn.collectScriptHashes(n),n.size<t.length)throw new Error("too many scripts included, not all are needed");n.size>t.length&&n.forEach(((t,n)=>{if(!e.has(n)){if(t>=0)throw console.error(JSON.stringify(this.dump(),null,"  ")),new Error(`missing script for input ${t}`);if(t<0)throw console.error(JSON.stringify(this.dump(),null,"  ")),new Error("missing script for minting policy "+(-t-1))}})),e.forEach((t=>{if(!n.has(t))throw console.log(n,e),new Error("detected unused script")}))}async executeRedeemers(t,e){await this.#$n.executeScripts(t,this.#Fn,e)}async checkExecutionBudgets(t){await this.#$n.checkExecutionBudgets(t,this.#Fn)}balanceAssets(t){const e=this.#Fn.sumInputAndMintedAssets(),n=this.#Fn.sumOutputAssets();if(!e.eq(n)){if(n.ge(e))throw new Error("not enough input assets");{const r=e.sub(n);if(config.MAX_ASSETS_PER_CHANGE_OUTPUT){const e=config.MAX_ASSETS_PER_CHANGE_OUTPUT;let n=new Assets,s=0;r.mintingPolicies.forEach((a=>{r.getTokens(a).forEach((([r,i],o)=>{n.addComponent(a,r,i),s+=1,s==e&&(this.#Fn.addOutput(new TxOutput(t,new Value(0n,n))),n=new Assets,s=0)}))})),n.isZero()||this.#Fn.addOutput(new TxOutput(t,new Value(0n,n)))}else{const e=new TxOutput(t,new Value(0n,r));this.#Fn.addOutput(e)}}}}estimateCollateralBaseFee(t,e,n){assert(1==config.N_DUMMY_INPUTS||2==config.N_DUMMY_INPUTS,"expected N_DUMMY_INPUTs == 1 or N_DUMMY_INPUTS == 2");const r=new TxOutput(e,new Value(0n));r.correctLovelace(t);const s=n.map((t=>t)).concat(this.#Fn.inputs).slice(0,3);s.forEach((t=>{this.#Fn.collateral.push(t)}));const a=s.slice(0,config.N_DUMMY_INPUTS);this.#Fn.setCollateralReturn(r),a.forEach((t=>this.#Fn.addInput(t,!1))),this.#Fn.addOutput(r);const i=this.estimateFee(t);for(;this.#Fn.collateral.length;)this.#Fn.collateral.pop();return this.#Fn.setCollateralReturn(null),a.forEach((t=>this.#Fn.removeInput(t))),this.#Fn.removeOutput(r),i}balanceCollateral(t,e,n){if(this.#Fn.collateral.length>0||!this.isSmart())return;const r=(this.estimateCollateralBaseFee(t,e,n)*BigInt(t.minCollateralPct)+100n)/100n;let s=0n;const a=[];function i(e){const n=e.filter((t=>!t.address.validatorHash&&t.value.assets.isZero())).sort(((t,e)=>Number(t.value.lovelace-e.value.lovelace)));for(let e of n){if(s>r)break;for(;a.length>=t.maxCollateralInputs;)a.shift();a.push(e),s+=e.value.lovelace}}i(this.#Fn.inputs.slice()),i(n.map((t=>t)));const o=new TxOutput(e,new Value(0n));if(o.correctLovelace(t),s<r)throw new Error("unable to find enough collateral input");s>r+o.value.lovelace&&(o.setValue(new Value(0n)),o.correctLovelace(t),s>r+o.value.lovelace?(o.setValue(new Value(s-r)),this.#Fn.setCollateralReturn(o)):console.log(`not setting collateral return: collateral input too low (${s})`)),a.forEach((t=>{this.#Fn.addCollateral(t)}))}balanceLovelace(t,e,n){let r=this.#Fn.sumOutputValue();const s=new TxOutput(e,new Value(0n));s.correctLovelace(t),this.#Fn.addOutput(s);const a=s.value.lovelace;let i=t.maxTxFee;this.#Fn.setFee(i);let o=this.#Fn.sumInputAndMintedValue(),_=new Value(i);r=_.add(r);const l=new Value(t.stakeAddressDeposit);this.#Fn.dcerts.forEach((t=>{0==t.certType&&(r=r.add(l)),1==t.certType&&(o=o.add(l))}));const u=n.some((t=>!t.value.assets.isZero()));n=n.filter((t=>t.value.assets.isZero()));const c=r.add(s.value);for(;!o.ge(c);){let t=n.pop();if(void 0===t)throw u?new Error("UTxOs too fragmented"):new Error(`need ${c.lovelace} lovelace, but only have ${o.lovelace}`);this.#Fn.addInput(t),o=o.add(t.value)}let p=o.sub(r);return assert(p.assets.isZero(),"unexpected unbalanced assets"),assert(p.lovelace>=a,`diff.lovelace=${p.lovelace} ${typeof p.lovelace} vs minLovelace=${a} ${typeof a}`),s.setValue(p),s}correctChangeOutput(t,e){const n=this.#Fn.fee-this.setFee(t,this.estimateFee(t)),r=e.value.lovelace+n;e.value.setLovelace(r)}checkBalanced(t){const e=new Value(t.stakeAddressDeposit);let n=new Value(0n);n=this.#Fn.inputs.reduce(((t,e)=>e.value.add(t)),n),n=this.#Fn.dcerts.reduce(((t,n)=>1===n.certType?t.add(e):t),n),n=n.sub(new Value(this.#Fn.fee)),n=n.add(new Value(0,this.#Fn.minted)),n=this.#Fn.outputs.reduce(((t,e)=>t.sub(e.value)),n),n=this.#Fn.dcerts.reduce(((t,n)=>0===n.certType?t.sub(e):t),n),assert(0n==n.lovelace,`tx not balanced, net lovelace not zero (${n.lovelace})`),assert(n.assets.isZero(),"tx not balanced, net assets not zero")}syncScriptDataHash(t){const e=this.#$n.calcScriptDataHash(t);this.#Fn.setScriptDataHash(e)}isSmart(){return this.#$n.scripts.length>0}checkCollateral(t){if(this.isSmart()){let e=t.minCollateralPct;const n=this.#Fn.fee;this.#Fn.checkCollateral(t,BigInt(Math.ceil(e*Number(n)/100)))}else this.#Fn.checkCollateral(t,null)}checkSize(t){if(this.toCbor().length>t.maxTxSize)throw new Error("tx too big")}checkFee(t){assert(this.estimateFee(t)<=this.#Fn.fee,`fee too small (${this.#Fn.fee} < ${this.estimateFee(t)})`)}finalizeValidityTimeRange(t){if(this.#$n.anyScriptCallsTxTimeRange()&&null===this.#Mn&&null===this.#An){const e=t.liveSlot,n=null!==e?new Date(Number(t.slotToTime(e))):new Date;null!==config.VALIDITY_RANGE_START_OFFSET&&(this.#Mn=new Date(n.getTime()-1e3*config.VALIDITY_RANGE_START_OFFSET)),null!==config.VALIDITY_RANGE_END_OFFSET&&(this.#An=new Date(n.getTime()+1e3*config.VALIDITY_RANGE_END_OFFSET)),config.AUTO_SET_VALIDITY_RANGE||console.error("Warning: validity interval is unset but detected usage of tx.time_range in one of the scripts.\nSetting the tx validity interval to a sane default\n(hint: set helios.config.AUTO_SET_VALIDITY_RANGE to true to avoid this warning)")}null!==this.#An&&this.#Fn.validTo("bigint"==typeof this.#An?this.#An:t.timeToSlot(BigInt(this.#An.getTime()))),null!==this.#Mn&&this.#Fn.validFrom("bigint"==typeof this.#Mn?this.#Mn:t.timeToSlot(BigInt(this.#Mn.getTime())))}async finalize(t,e,n=[]){assert(!this.#kn),null!==this.#Bn&&this.#Fn.setMetadataHash(new Hash(Crypto.blake2b(this.#Bn.toCbor()))),this.#$n.redeemers.length>0&&this.#Fn.setScriptDataHash(new Hash(new Array(32).fill(0))),this.finalizeValidityTimeRange(t),this.#Fn.sortInputs(),this.#$n.updateRedeemerIndices(this.#Fn),this.checkScripts(),this.balanceAssets(e),this.#Fn.sortOutputs(),this.#Fn.correctOutputs(t);const r=this.balanceLovelace(t,e,n.slice());return await this.executeRedeemers(t,e),this.balanceCollateral(t,e,n.slice()),this.correctChangeOutput(t,r),this.#$n.updateRedeemerIndices(this.#Fn),this.syncScriptDataHash(t),this.#Fn.checkOutputs(t),this.checkCollateral(t),await this.checkExecutionBudgets(t),this.#$n.checkExecutionBudgetLimits(t),this.checkSize(t),this.checkFee(t),this.checkBalanced(t),this.#kn=!0,this}get profileReport(){return this.#$n.profileReport}addSignature(t,e=!0){return assert(this.#kn),e&&t.verify(this.bodyHash),this.#$n.addSignature(t),this}addSignatures(t,e=!0){for(let n of t)this.addSignature(n,e);return this}addMetadata(t,e){return null===this.#Bn&&(this.#Bn=new TxMetadata),this.#Bn.add(t,e),this}id(){return assert(this.#kn,"can't get TxId of unfinalized Tx"),new TxId(this.bodyHash)}}export class TxBody extends CborData{#Un;#Nn;#Ln;#Sn;#Vn;#On;#Cn;#Hn;#qn;#zn;#jn;#Wn;#Gn;#Kn;#Jn;constructor(){super(),this.#Un=[],this.#Nn=[],this.#Ln=0n,this.#Sn=null,this.#Vn=[],this.#On=new Map,this.#Cn=null,this.#Hn=new Assets,this.#qn=null,this.#zn=[],this.#jn=[],this.#Wn=null,this.#Gn=0n,this.#Kn=[],this.#Jn=null}get inputs(){return this.#Un}get refInputs(){return this.#Kn}get outputs(){return this.#Nn}get fee(){return this.#Ln}setFee(t){this.#Ln=t}get minted(){return this.#Hn}get collateral(){return this.#zn}get firstValidSlot(){return this.#Cn}get lastValidSlot(){return this.#Sn}get signers(){return this.#jn.slice()}get dcerts(){return this.#Vn.slice()}toCbor(){let t=new Map;if(t.set(0,Cbor.encodeDefList(this.#Un)),t.set(1,Cbor.encodeDefList(this.#Nn)),t.set(2,Cbor.encodeInteger(this.#Ln)),null!==this.#Sn&&t.set(3,Cbor.encodeInteger(this.#Sn)),0!=this.#Vn.length&&t.set(4,Cbor.encodeDefList(this.#Vn)),0!=this.#On.size)throw new Error("not yet implemented");return null!==this.#Jn&&t.set(7,this.#Jn.toCbor()),null!==this.#Cn&&t.set(8,Cbor.encodeInteger(this.#Cn)),this.#Hn.isZero()||t.set(9,this.#Hn.toCbor()),null!==this.#qn&&t.set(11,this.#qn.toCbor()),0!=this.#zn.length&&t.set(13,Cbor.encodeDefList(this.#zn)),0!=this.#jn.length&&t.set(14,Cbor.encodeDefList(this.#jn)),null!==this.#Wn&&t.set(16,this.#Wn.toCbor()),this.#Gn>0n&&t.set(17,Cbor.encodeInteger(this.#Gn)),0!=this.#Kn.length&&t.set(18,Cbor.encodeDefList(this.#Kn)),Cbor.encodeObject(t)}static fromCbor(t){const e=new TxBody,n=Cbor.decodeObject(t,((t,n)=>{switch(t){case 0:Cbor.decodeList(n,((t,n)=>{e.#Un.push(TxInput.fromCbor(n))}));break;case 1:Cbor.decodeList(n,((t,n)=>{e.#Nn.push(TxOutput.fromCbor(n))}));break;case 2:e.#Ln=Cbor.decodeInteger(n);break;case 3:e.#Sn=Cbor.decodeInteger(n);break;case 4:Cbor.decodeList(n,((t,n)=>{e.#Vn.push(DCert.fromCbor(n))}));break;case 5:case 6:throw new Error("not yet implemented");case 7:e.#Jn=Hash.fromCbor(n);break;case 8:e.#Cn=Cbor.decodeInteger(n);break;case 9:e.#Hn=Assets.fromCbor(n);break;case 10:case 12:throw new Error("unhandled field");case 11:e.#qn=Hash.fromCbor(n);break;case 13:Cbor.decodeList(n,((t,n)=>{e.#zn.push(TxInput.fromCbor(n))}));break;case 14:Cbor.decodeList(n,((t,n)=>{e.#jn.push(PubKeyHash.fromCbor(n))}));break;case 15:Cbor.decodeInteger(n);break;case 16:e.#Wn=TxOutput.fromCbor(n);break;case 17:e.#Gn=Cbor.decodeInteger(n);break;case 18:Cbor.decodeList(n,(t=>{e.#Kn.push(TxInput.fromCbor(n))}));break;default:throw new Error("unrecognized field")}}));return assert(n.has(0)&&n.has(1)&&n.has(2)),e}dump(){return{inputs:this.#Un.map((t=>t.dump())),outputs:this.#Nn.map((t=>t.dump())),fee:this.#Ln.toString(),lastValidSlot:null===this.#Sn?null:this.#Sn.toString(),firstValidSlot:null===this.#Cn?null:this.#Cn.toString(),minted:this.#Hn.isZero()?null:this.#Hn.dump(),metadataHash:null===this.#Jn?null:this.#Jn.dump(),scriptDataHash:null===this.#qn?null:this.#qn.dump(),certificates:0==this.#Vn.length?null:this.#Vn.map((t=>t.dump())),collateral:0==this.#zn.length?null:this.#zn.map((t=>t.dump())),signers:0==this.#jn.length?null:this.#jn.map((t=>t.dump())),collateralReturn:null===this.#Wn?null:this.#Wn.dump(),refInputs:this.#Kn.map((t=>t.dump()))}}toValidTimeRangeData(t){return new ConstrData(0,[new ConstrData(0,[null===this.#Cn?new ConstrData(0,[]):new ConstrData(1,[new IntData(t.slotToTime(this.#Cn))]),new ConstrData(1,[])]),new ConstrData(0,[null===this.#Sn?new ConstrData(2,[]):new ConstrData(1,[new IntData(t.slotToTime(this.#Sn))]),new ConstrData(null===this.#Sn?1:0,[])])])}async completeInputData(t,e){const n=[],r=[];for(let t=0;t<this.#Un.length;t++){const e=this.#Un[t];e.hasOrigOutput()||(n.push(t),r.push(e.outputId))}const s=this.#Un.length;for(let t=0;t<this.#Kn.length;t++){const e=this.#Kn[t];e.hasOrigOutput()||(n.push(s+t),r.push(e.outputId))}(await Promise.all(r.map((e=>t(e))))).forEach(((t,r)=>{const a=n[r];t.refScript&&e.attachRefScript(t.refScript),a<s?this.#Un[a].setOrigOutput(t):this.#Kn[a-s].setOrigOutput(t)}))}toTxData(t,e,n,r){return new ConstrData(0,[new ListData(this.#Un.map((t=>t.toData()))),new ListData(this.#Kn.map((t=>t.toData()))),new ListData(this.#Nn.map((t=>t.toData()))),new Value(this.#Ln)._toUplcData(),new Value(0n,this.#Hn)._toUplcData(!0),new ListData(this.#Vn.map((t=>t.toData()))),new MapData(Array.from(this.#On.entries()).map((t=>[t[0].toStakingData(),new IntData(t[1])]))),this.toValidTimeRangeData(t),new ListData(this.#jn.map((t=>new ByteArrayData(t.bytes)))),new MapData(e.map((t=>[t.toScriptPurposeData(this),t.data]))),new MapData(n.list.map((t=>[new ByteArrayData(Crypto.blake2b(t.toCbor())),t]))),new ConstrData(0,[new ByteArrayData(r.bytes)])])}toScriptContextData(t,e,n,r,s=TxId.dummy()){return new ConstrData(0,[this.toTxData(t,e,n,s),e[r].toScriptPurposeData(this)])}sumInputValue(){let t=new Value;for(let e of this.#Un)null!==e.origOutput&&(t=t.add(e.origOutput.value));return t}sumInputAndMintedValue(){return this.sumInputValue().add(new Value(0n,this.#Hn)).assertAllPositive()}sumInputAndMintedAssets(){return this.sumInputAndMintedValue().assets}sumOutputValue(){let t=new Value;for(let e of this.#Nn)t=t.add(e.value);return t}sumOutputAssets(){return this.sumOutputValue().assets}validFrom(t){this.#Cn=t}validTo(t){this.#Sn=t}addMint(t,e){this.#Hn.addTokens(t,e)}addInput(t,e=!0){if(null===t.origOutput)throw new Error("TxInput.origOutput must be set when building transaction");t.origOutput.value.assertAllPositive(),e&&assert(this.#Un.every((e=>!e.txId.eq(t.txId)||e.utxoIdx!=t.utxoIdx)),"input already added before"),this.#Un.push(t),this.#Un.sort(TxInput.comp)}removeInput(t){let e=-1;for(let n=this.#Un.length-1;n>=0;n--)if(this.#Un[n]==t){e=n;break}const n=this.#Un.length;assert(-1!=e,"input not found"),this.#Un=this.#Un.filter(((t,n)=>n!=e)),assert(this.#Un.length==n-1,"input not removed")}addRefInput(t,e=!0){if(null===t.origOutput)throw new Error("TxInput.origOutput must be set when building transaction");t.origOutput.value.assertAllPositive(),e&&assert(this.#Kn.every((e=>!e.txId.eq(t.txId)||e.utxoIdx!=t.utxoIdx)),"refInput already added before"),this.#Kn.push(t),this.#Kn.sort(TxInput.comp)}addOutput(t){t.value.assertAllPositive(),this.#Nn.push(t)}removeOutput(t){let e=-1;for(let n=this.#Nn.length-1;n>=0;n--)if(this.#Nn[n]==t){e=n;break}const n=this.#Nn.length;assert(-1!=e,"output not found"),this.#Nn=this.#Nn.filter(((t,n)=>n!=e)),assert(this.#Nn.length==n-1,"output not removed")}addSigner(t,e=!0){e&&assert(this.#jn.every((e=>!e.eq(t))),"signer already added before"),this.#jn.push(t),this.#jn.sort(Hash.compare)}addDCert(t){this.#Vn.push(t);[1,2].includes(t.certType)&&0===t.credentialType&&this.addSigner(t.stakeHash)}addCollateral(t){this.#zn.push(t)}setScriptDataHash(t){this.#qn=t}setMetadataHash(t){this.#Jn=t}setCollateralReturn(t){this.#Wn=t}countUniqueSigners(){let t=new Set;const e=this.#Un.concat(this.#zn);for(let n of e){let e=n.origOutput;if(null!==e){let n=e.address.pubKeyHash;null!==n&&t.add(n)}}for(let e of this.#jn)t.add(e);return t.size}collectScriptHashes(t){for(let e=0;e<this.#Un.length;e++){const n=this.#Un[e];if(null!==n.origOutput){let r=n.origOutput.address.validatorHash;if(null!==r){const n=bytesToHex(r.bytes);t.has(n)||t.set(n,e)}}}let e=this.#Hn.mintingPolicies;for(let n=0;n<e.length;n++){const r=bytesToHex(e[n].bytes);t.has(r)||t.set(r,-n-1)}}correctOutputs(t){for(let e of this.#Nn)e.correctLovelace(t)}checkOutputs(t){for(let e of this.#Nn){let n=e.calcMinLovelace(t);assert(n<=e.value.lovelace,`not enough lovelace in output (expected at least ${n.toString()}, got ${e.value.lovelace})`),e.value.assets.assertSorted()}}checkCollateral(t,e){if(assert(this.#zn.length<=t.maxCollateralInputs),null===e)assert(0==this.#zn.length,"unnecessary collateral included");else{let t=new Value;for(let e of this.#zn){if(null===e.origOutput)throw new Error("expected collateral TxInput.origOutput to be set");if(!e.origOutput.value.assets.isZero())throw new Error("collateral can only contain lovelace");t=t.add(e.origOutput.value)}null!=this.#Wn&&(t=t.sub(this.#Wn.value)),assert(t.lovelace>=e,"not enough collateral"),t.lovelace>5n*e&&console.error("Warning: way too much collateral")}}sortInputs(){this.#Un.forEach(((t,e)=>{if(e>0){const n=this.#Un[e-1];assert(TxInput.comp(n,t)<=-1,"inputs not sorted")}})),this.#Kn.forEach(((t,e)=>{if(e>0){const n=this.#Kn[e-1];assert(TxInput.comp(n,t)<=-1,"refInputs not sorted")}})),this.#On=new Map(Array.from(this.#On.entries()).sort(((t,e)=>Address.compStakingHashes(t[0],e[0])))),this.#Hn.assertSorted()}sortOutputs(){this.#Nn.forEach((t=>{t.value.assets.sort()}))}isValid(t){return!(null!=this.#Sn&&t>this.#Sn)&&!(null!=this.#Cn&&t<this.#Cn)}hash(){return Crypto.blake2b(this.toCbor())}}export class TxWitnesses extends CborData{#Zn;#Yn;#Xn;#Qn;#te;#tr;#er;constructor(){super(),this.#Zn=[],this.#Yn=new ListData([]),this.#Xn=[],this.#Qn=[],this.#te=[],this.#tr=[],this.#er=[]}get signatures(){return this.#Zn}get scripts(){let t=this.#te.slice().concat(this.#tr.slice());return t=t.concat(this.#er.slice()),t}get redeemers(){return this.#Xn}get datums(){return this.#Yn}isNativeScript(t){return this.#er.some((e=>eq(e.hash(),t.bytes)))}anyScriptCallsTxTimeRange(){return this.scripts.some((t=>t instanceof UplcProgram&&t.properties.callsTxTimeRange))}toCbor(){let t=new Map;if(this.#Zn.length>0&&t.set(0,Cbor.encodeDefList(this.#Zn)),this.#er.length>0&&t.set(1,Cbor.encodeDefList(this.#er)),this.#Qn.length>0&&t.set(3,Cbor.encodeDefList(this.#Qn)),this.#Yn.list.length>0&&t.set(4,this.#Yn.toCbor()),this.#Xn.length>0&&t.set(5,Cbor.encodeDefList(this.#Xn)),this.#te.length>0){let e=this.#te.map((t=>t.toCbor()));t.set(6,Cbor.encodeDefList(e))}return Cbor.encodeObject(t)}static fromCbor(t){let e=new TxWitnesses;return Cbor.decodeObject(t,((t,n)=>{switch(t){case 0:Cbor.decodeList(n,((t,n)=>{e.#Zn.push(Signature.fromCbor(n))}));break;case 1:Cbor.decodeList(n,((t,n)=>{e.#er.push(NativeScript.fromCbor(n))}));break;case 2:throw new Error(`unhandled TxWitnesses field ${t}`);case 3:Cbor.decodeList(n,((t,n)=>{e.#Qn.push(n)}));break;case 4:e.#Yn=ListData.fromCbor(n);break;case 5:Cbor.decodeList(n,((t,n)=>{e.#Xn.push(Redeemer.fromCbor(n))}));break;case 6:Cbor.decodeList(n,((t,n)=>{e.#te.push(UplcProgram.fromCbor(n))}));break;default:throw new Error("unrecognized field")}})),e}verifySignatures(t){for(let e of this.#Zn)e.verify(Crypto.blake2b(t))}dump(t=null,e=null){return{signatures:this.#Zn.map((t=>t.dump())),datums:this.#Yn.list.map((t=>t.toString())),redeemers:this.#Xn.map(((n,r)=>{const s=n.dump();if(t&&e){const a=e.toScriptContextData(t,this.#Xn,this.#Yn,r);if(s.ctx=a.toCborHex(),n instanceof SpendingRedeemer){const t=n.inputIndex,r=e.inputs[t].origOutput;if(null===r)throw new Error("expected origOutput to be non-null");{const t=r.getDatumData();s.datum=t.toCborHex()}}}return s})),nativeScripts:this.#er.map((t=>t.toJson())),scripts:this.#te.map((t=>bytesToHex(t.toCbor()))),refScripts:this.#tr.map((t=>bytesToHex(t.toCbor())))}}estimateFee(t){let e=0n;for(let n of this.#Xn)e+=n.estimateFee(t);return e}addSignature(t){this.#Zn.every((e=>!e.isDummy()&&!e.pubKeyHash.eq(t.pubKeyHash)))&&this.#Zn.push(t)}addDummySignatures(t){for(let e=0;e<t;e++)this.#Zn.push(Signature.dummy())}removeDummySignatures(){this.#Zn=this.#Zn.filter((t=>!t.isDummy()))}addSpendingRedeemer(t,e){this.#Xn.push(new SpendingRedeemer(t,-1,e))}addMintingRedeemer(t,e){this.#Xn.push(new MintingRedeemer(t,-1,e))}addDatumData(t){for(let e of this.#Yn.list)if(eq(e.toCbor(),t.toCbor()))return;let e=this.#Yn.list;e.push(t),this.#Yn=new ListData(e)}attachNativeScript(t){const e=t.hash();this.#er.some((t=>eq(e,t.hash())))||this.#er.push(t)}attachRefScript(t){this.#tr.some((e=>eq(e.hash(),t.hash())))||this.#tr.push(t)}attachPlutusScript(t,e=!1){const n=t.hash();if(e){if(assert(this.#te.every((t=>!eq(t.hash(),n)))),this.#tr.some((t=>eq(t.hash(),n))))return;this.#tr.push(t)}else{if(assert(this.#tr.every((t=>!eq(t.hash(),n)))),this.#te.some((t=>eq(t.hash(),n))))return;this.#te.push(t)}}getUplcProgram(t){const e=this.scripts.find((e=>eq(e.hash(),t.bytes)));if(!(e instanceof UplcProgram))throw new Error("not a uplc program");return e}updateRedeemerIndices(t){for(let e of this.#Xn)e.updateIndex(t)}calcScriptDataHash(t){if(this.#Xn.length>0){let e=Cbor.encodeDefList(this.#Xn);this.#Yn.list.length>0&&(e=e.concat(this.#Yn.toCbor()));let n=t.sortedCostParams;return e=e.concat(Cbor.encodeMap([[Cbor.encodeInteger(1n),Cbor.encodeDefList(n.map((t=>Cbor.encodeInteger(BigInt(t)))))]])),new Hash(Crypto.blake2b(e))}return null}async executeRedeemer(t,e,n,r){if(n instanceof SpendingRedeemer){const s=n.inputIndex,a=e.inputs[s].origOutput;if(null===a)throw new Error("expected origOutput to be non-null");{const e=a.getDatumData(),s=a.address.validatorHash;if(null==s)throw new Error("expected validatorHash to be non-null");{const a=this.getUplcProgram(s);a.properties.name&&n.setProgramName(a.properties.name);const i=[new UplcDataValue(Site.dummy(),e),new UplcDataValue(Site.dummy(),n.data),new UplcDataValue(Site.dummy(),r)],o=await a.profile(i,t);if(o.messages?.forEach((t=>console.log(t))),o.result instanceof UserError||o.result instanceof RuntimeError)throw a.properties.name&&(o.result.context.name=a.properties.name),o.result.context.Datum=bytesToHex(e.toCbor()),o.result.context.Redeemer=bytesToHex(n.data.toCbor()),o.result.context.ScriptContext=bytesToHex(r.toCbor()),o.result;return o}}}if(n instanceof MintingRedeemer){const s=e.minted.mintingPolicies[n.mphIndex],a=this.getUplcProgram(s);a.properties.name&&n.setProgramName(a.properties.name);const i=[new UplcDataValue(Site.dummy(),n.data),new UplcDataValue(Site.dummy(),r)],o=await a.profile(i,t);if(o.messages?.forEach((t=>console.log(t))),o.result instanceof UserError||o.result instanceof RuntimeError)throw a.properties.name&&(o.result.context.name=a.properties.name),o.result.context.Redeemer=bytesToHex(n.data.toCbor()),o.result.context.ScriptContext=bytesToHex(r.toCbor()),o.result;return o}throw new Error("unhandled redeemer type")}async executeScripts(t,e,n){await this.executeRedeemers(t,e,n),this.executeNativeScripts(e)}executeNativeScripts(t){const e=new NativeContext(t.firstValidSlot,t.lastValidSlot,t.signers);this.#er.forEach((t=>{if(!t.eval(e))throw new Error("native script execution returned false")}))}async executeRedeemers(t,e,n){assert(1==config.N_DUMMY_INPUTS||2==config.N_DUMMY_INPUTS,"expected N_DUMMY_INPUTS==1 or N_DUMMY_INPUTS==2");const r=2==config.N_DUMMY_INPUTS,s=t.maxTxFee,a=new TxInput(new TxOutputId(TxId.dummy(0),0),new TxOutput(n,new Value(s+1000000000n))),i=new TxInput(new TxOutputId(TxId.dummy(255),999),new TxOutput(n,new Value(1000000000n))),o=new TxOutput(n,new Value(r?2000000000n:1000000000n));e.setFee(s),e.addInput(a,!1),r&&e.addInput(i,!1),e.addOutput(o),this.updateRedeemerIndices(e);for(let n=0;n<this.#Xn.length;n++){const r=this.#Xn[n],s=e.toScriptContextData(t,this.#Xn,this.#Yn,n),a=await this.executeRedeemer(t,e,r,s);r.setProfile(a)}e.removeInput(a),r&&e.removeInput(i),e.removeOutput(o),this.updateRedeemerIndices(e)}async checkExecutionBudgets(t,e){const n=new TxId(e.hash());for(let r=0;r<this.#Xn.length;r++){const s=this.#Xn[r],a=e.toScriptContextData(t,this.#Xn,this.#Yn,r,n),i=await this.executeRedeemer(t,e,s,a);if(s.memCost<i.mem)throw new Error(`internal finalization error, redeemer mem budget too low (${s.memCost} < ${i.mem})`);if(s.cpuCost<i.cpu)throw new Error(`internal finalization error, redeemer cpu budget too low (${s.cpuCost} < ${i.cpu})`)}}checkExecutionBudgetLimits(t){let e=0n,n=0n;for(let t of this.#Xn)e+=t.memCost,n+=t.cpuCost;let[r,s]=t.maxTxExecutionBudget;if(e>BigInt(r)+BigInt(16e6))throw new Error(`execution budget exceeded for mem (${e.toString()} > ${r.toString()})\n${this.profileReport.split("\n").map((t=>"  "+t)).join("\n")}`);if(n>BigInt(s)+BigInt(1e10))throw new Error(`execution budget exceeded for cpu (${n.toString()} > ${s.toString()})\n${this.profileReport.split("\n").map((t=>"  "+t)).join("\n")}`)}get profileReport(){let t=[];for(let e of this.#Xn){let n="";if(e instanceof SpendingRedeemer)n=`SpendingRedeemer ${e.inputIndex.toString()}`;else{if(!(e instanceof MintingRedeemer))throw new Error("unhandled Redeemer type");n=`MintingRedeemer ${e.mphIndex.toString()}`}if(n+=`${e.programName?` (${e.programName})`:""}: mem=${e.memCost.toString()}, cpu=${e.cpuCost.toString()}`,t.push(n),e.profile.builtins){t.push("  builtins");for(let n in e.profile.builtins){const r=e.profile.builtins[n];t.push(`    ${n}: mem=${r.mem}, cpu=${r.cpu}`)}}if(e.profile.terms){t.push("  terms");for(let n in e.profile.terms){const r=e.profile.terms[n];t.push(`    ${n}: mem=${r.mem}, cpu=${r.cpu}`)}}}return t.join("\n")}}export class TxInput extends CborData{outputId;#nr;constructor(t,e=null){super(),this.outputId=t,this.#nr=e}get txId(){return this.outputId.txId}get utxoIdx(){return Number(this.outputId.utxoIdx)}eq(t){return t.outputId.eq(this.outputId)}hasOrigOutput(){return null!==this.#nr}setOrigOutput(t){this.#nr=t}get output(){if(null===this.#nr)throw new Error("underlying output data not set");return this.#nr}get origOutput(){return this.output}get value(){return assertDefined(this.#nr).value}get address(){return assertDefined(this.#nr).address}toOutputIdData(){return this.outputId._toUplcData()}toData(){if(null===this.#nr)throw new Error("expected to be non-null");return new ConstrData(0,[this.toOutputIdData(),this.#nr.toData()])}static fromUplcData(t){assert(0==t.index);const e=t.fields,n=TxOutputId.fromUplcData(e[0]);return new TxInput(n,TxOutput.fromUplcData(e[1]))}toCbor(){return this.outputId.toCbor()}toFullCbor(){return Cbor.encodeTuple([this.outputId.toCbor(),this.origOutput.toCbor()])}static fromFullCbor(t){const e=Array.isArray(t)?t:hexToBytes(t);let n=null,r=null;if(Cbor.decodeTuple(e,((t,e)=>{switch(t){case 0:n=TxOutputId.fromCbor(e);break;case 1:r=TxOutput.fromCbor(e);break;default:throw new Error("unrecognized field")}})),null!==n&&null!==r)return new TxInput(n,r);throw new Error("unexpected")}static fromCbor(t){const e=TxOutputId.fromCbor(t);return new TxInput(e,null)}static comp(t,e){return TxOutputId.comp(t.outputId,e.outputId)}static sumValue(t){let e=new Value;for(let n of t)e=e.add(n.value);return e}dump(){return{outputId:this.outputId.toString(),output:null!==this.#nr?this.#nr.dump():null}}}export class UTxO extends TxInput{}export class TxRefInput extends TxInput{}export class TxOutput extends CborData{#rr;#m;#sr;#ar;constructor(t,e,n=null,r=null){assert(null===n||n instanceof Datum),super(),this.#rr=t,this.#m=e,this.#sr=n,this.#ar=r}get address(){return this.#rr}setAddress(t){this.#rr=t}get value(){return this.#m}setValue(t){this.#m=t}get datum(){return this.#sr}setDatum(t){this.#sr=t}getDatumData(){if(null===this.#sr)throw new Error("no datum data available");{let t=this.#sr.data;if(null===t)throw new Error("no datum data available");return t}}get refScript(){return this.#ar}toCbor(){if((null===this.#sr||this.#sr instanceof HashedDatum)&&null===this.#ar&&!config.STRICT_BABBAGE){let t=[this.#rr.toCbor(),this.#m.toCbor()];if(null!==this.#sr){if(!(this.#sr instanceof HashedDatum))throw new Error("unexpected");t.push(this.#sr.hash.toCbor())}return Cbor.encodeTuple(t)}{let t=new Map;return t.set(0,this.#rr.toCbor()),t.set(1,this.#m.toCbor()),null!==this.#sr&&t.set(2,this.#sr.toCbor()),null!==this.#ar&&t.set(3,Cbor.encodeTag(24n).concat(Cbor.encodeBytes(Cbor.encodeTuple([Cbor.encodeInteger(BigInt(this.#ar.versionTag())),this.#ar.toCbor()])))),Cbor.encodeObject(t)}}static fromCbor(t){let e=null,n=null,r=null,s=null;if(Cbor.isObject(t))Cbor.decodeObject(t,((t,a)=>{switch(t){case 0:e=Address.fromCbor(a);break;case 1:n=Value.fromCbor(a);break;case 2:r=Datum.fromCbor(a);break;case 3:assert(24n==Cbor.decodeTag(a));let t=Cbor.decodeBytes(a),i=-1;Cbor.decodeTuple(t,((t,e)=>{switch(assert(null===s),t){case 0:i=Number(Cbor.decodeInteger(e));break;case 1:switch(i){case 0:throw new Error("native refScript not handled");case 1:console.log("Warning: deserializing PlutusV1 refScript as PlutusV2 refScript"),s=UplcProgram.fromCbor(e);break;case 2:s=UplcProgram.fromCbor(e);break;default:throw new Error(`unhandled refScript type ${i}`)}break;default:throw new Error("unhandled refScript format")}}));break;default:throw new Error("unrecognized field")}}));else{if(!Cbor.isTuple(t))throw new Error("expected object or tuple for TxOutput");Cbor.decodeTuple(t,((t,s)=>{switch(t){case 0:e=Address.fromCbor(s);break;case 1:n=Value.fromCbor(s);break;case 2:r=new HashedDatum(DatumHash.fromCbor(s));break;default:throw new Error("unrecognized field")}}))}if(null===e||null===n)throw new Error("unexpected");return new TxOutput(e,n,r,s)}dump(){return{address:this.#rr.dump(),value:this.#m.dump(),datum:null===this.#sr?null:this.#sr.dump(),refScript:null===this.#ar?null:bytesToHex(this.#ar.toCbor())}}toData(){let t=new ConstrData(0,[]);return null!==this.#sr&&(t=this.#sr.toData()),new ConstrData(0,[this.#rr._toUplcData(),this.#m._toUplcData(),t,this.#ar?new ConstrData(0,[new ByteArrayData(this.#ar.hash())]):new ConstrData(1,[])])}static fromUplcData(t){return assert(0==t.index),assert(4==t.fields.length),new TxOutput(Address.fromUplcData(t.fields[0]),Value.fromUplcData(t.fields[1]),Datum.fromUplcData(t.fields[2]))}calcMinLovelace(t){let e=t.lovelacePerUTXOByte,n=this.toCbor().length+160;return BigInt(n)*BigInt(e)}correctLovelace(t,e=null){let n=this.calcMinLovelace(t);for(;this.#m.lovelace<n;)this.#m.setLovelace(n),null!=e&&e(this),n=this.calcMinLovelace(t)}}export class DCert extends CborData{#ir;constructor(t){super(),this.#ir=t}get certType(){return this.#ir}get stakeHash(){throw new Error("not yet implemented")}get credentialType(){throw new Error("not yet implemented")}typeToCbor(){return Cbor.encodeInteger(BigInt(this.#ir))}static fromCbor(t){const e="string"==typeof t?hexToBytes(t):t;0==e[0]&&e.shift();let n,r,s,a=-1,i=null;if(Cbor.decodeTuple(e,((t,e)=>{if(0==t)a=Number(Cbor.decodeInteger(e));else switch(a){case 0:case 1:case 2:1==t?(Cbor.decodeList(e,((t,e)=>{if(0==t)r=Number(Cbor.decodeInteger(e));else if(0==r)n=PubKeyHash.fromCbor(e);else{if(1!=r)throw new Error("invalid stake credential");n=StakingValidatorHash.fromCbor(e)}})),0==a&&(i=new DCertRegister(n)),1==a&&(i=new DCertDeregister(n))):2==t&&(s=PubKeyHash.fromCbor(Cbor.decodeBytes(e)),2==a&&(i=new DCertDelegate(n,s)));break;case 3:case 4:case 5:case 6:throw new Error("DCert type not yet implemented");default:throw new Error("invalid DCert type")}})),i)return i;throw new Error("unable to deserialize certificate")}static fromJson(t){const e="string"==typeof t?JSON.parse(t):t,n=e?.type,r=e.credential.type;if("number"!=typeof n)throw new Error("invalid or no certificate type specified");let s,a,i=null;switch(n){case 0:case 1:case 2:s=0===r?PubKeyHash.fromHex(e.credential.hash):StakingValidatorHash.fromHex(e.credential.hash),0==n&&(i=new DCertRegister(s)),1==n&&(i=new DCertDeregister(s)),2==n&&(a=PubKeyHash.fromHex(e.poolHash),i=new DCertDelegate(s,a));break;case 3:case 4:case 5:case 6:throw new Error("DCert type not yet implemented");default:throw new Error("invalid DCert type")}if(i)return i;throw new Error("unable to deserialize certificate")}static fromUplcData(t){throw new Error("not yet implemented")}toData(){throw new Error("not yet implemented")}dump(){return{}}}export class DCertRegister extends DCert{#or;#_r;constructor(t){super(0),assert(t instanceof PubKeyHash||t instanceof StakingValidatorHash),this.#or=t,this.#_r=t instanceof PubKeyHash?0:1}get stakeHash(){return this.#or}get credentialType(){return this.#_r}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeDefList([Cbor.encodeInteger(BigInt(this.#_r)),this.#or.toCbor()])])}dump(){return{certType:"stake_registration",stakeCredential:{type:this.#_r,hash:this.#or.dump()}}}}export class DCertDeregister extends DCert{#or;#_r;constructor(t){super(1),assert(t instanceof PubKeyHash||t instanceof StakingValidatorHash),this.#or=t,this.#_r=t instanceof PubKeyHash?0:1}get stakeHash(){return this.#or}get credentialType(){return this.#_r}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeDefList([Cbor.encodeInteger(BigInt(this.#_r)),this.#or.toCbor()])])}dump(){return{certType:"stake_deregistration",stakeCredential:{type:this.#_r,hash:this.#or.dump()}}}}export class DCertDelegate extends DCert{#or;#_r;#lr;constructor(t,e){super(2),assert(t instanceof PubKeyHash||t instanceof StakingValidatorHash),assert(e instanceof PubKeyHash),this.#or=t,this.#_r=t instanceof PubKeyHash?0:1,this.#lr=e}get stakeHash(){return this.#or}get credentialType(){return this.#_r}get poolHash(){return this.#lr}toCbor(){return Cbor.encodeTuple([this.typeToCbor(),Cbor.encodeDefList([Cbor.encodeInteger(BigInt(this.#_r)),this.#or.toCbor()]),this.#lr.toCbor()])}dump(){return{certType:"stake_delegation",stakeCredential:{type:this.#_r,hash:this.#or.dump()},poolHash:this.#lr.dump()}}}export class DCertRegisterPool extends DCert{}export class DCertRetirePool extends DCert{}export class StakeAddress{#w;constructor(t){assert(29==t.length),this.#w=t}get bytes(){return this.#w}static isForTestnet(t){return Address.isForTestnet(new Address(t.bytes))}static fromAddress(t){const e=t.stakingHash;if(null===e)throw new Error("address doesn't have a staking part");return StakeAddress.fromHash(Address.isForTestnet(t),e)}toCbor(){return Cbor.encodeBytes(this.#w)}static fromCbor(t){return new StakeAddress(Cbor.decodeBytes(t))}toBech32(){return Crypto.encodeBech32(StakeAddress.isForTestnet(this)?"stake_test":"stake",this.bytes)}static fromBech32(t){let[e,n]=Crypto.decodeBech32(t),r=new StakeAddress(n);return assert(e==(StakeAddress.isForTestnet(r)?"stake_test":"stake"),"invalid StakeAddress prefix"),r}toHex(){return bytesToHex(this.#w)}get hex(){return this.toHex()}static fromHex(t){return new StakeAddress(hexToBytes(t))}static fromPubKeyHash(t,e){return new StakeAddress([t?224:225].concat(e.bytes))}static fromStakingValidatorHash(t,e){return new StakeAddress([t?240:241].concat(e.bytes))}static fromHash(t,e){return e instanceof PubKeyHash?StakeAddress.fromPubKeyHash(t,e):StakeAddress.fromStakingValidatorHash(t,e)}get stakingHash(){const t=this.bytes[0];if(224==t||225==t)return new PubKeyHash(this.bytes.slice(1));if(240==t||241==t)return new StakingValidatorHash(this.bytes.slice(1));throw new Error("bad StakeAddress header")}}export class Signature extends CborData{#ur;#cr;constructor(t,e){super(),this.#ur=t instanceof PubKey?t:new PubKey(t),this.#cr=e}get bytes(){return this.#cr}get pubKey(){return this.#ur}get pubKeyHash(){return this.#ur.pubKeyHash}static dummy(){return new Signature(PubKey.dummy(),new Array(64).fill(0))}isDummy(){return this.#ur.isDummy()&&this.#cr.every((t=>0==t))}toCbor(){return Cbor.encodeTuple([this.#ur.toCbor(),Cbor.encodeBytes(this.#cr)])}static fromCbor(t){let e=null,n=null;if(assert(2==Cbor.decodeTuple(t,((t,r)=>{switch(t){case 0:e=PubKey.fromCbor(r);break;case 1:n=Cbor.decodeBytes(r);break;default:throw new Error("unrecognized field")}}))),null===e||null===n)throw new Error("unexpected");return new Signature(e,n)}dump(){return{pubKey:this.#ur.dump,pubKeyHash:this.pubKeyHash.dump(),signature:bytesToHex(this.#cr)}}verify(t){if(null===this.#cr)throw new Error("signature can't be null");if(null===this.#ur)throw new Error("pubKey can't be null");if(!Ed25519.verify(this.#cr,t,this.#ur.bytes))throw new Error("incorrect signature")}}export class Ed25519PrivateKey extends HeliosData{#w;#ur;constructor(t){super(),this.#w=Array.isArray(t)?t:hexToBytes(t),this.#ur=null}static random(t){return new Ed25519PrivateKey(randomBytes(t,32))}get bytes(){return this.#w}get hex(){return bytesToHex(this.#w)}extend(){return new Ed25519PrivateKey(Crypto.sha2_512(this.#w))}derivePubKey(){return this.#ur||(this.#ur=new PubKey(Ed25519.derivePublicKey(this.#w))),this.#ur}sign(t){return new Signature(this.derivePubKey(),Ed25519.sign(t,this.#w))}}export const BIP32_HARDEN=2147483648;export class Bip32PrivateKey{#w;#ur;constructor(t){assert(96==t.length),this.#w=t,this.#ur=null}get bytes(){return this.#w.slice()}get k(){return this.#w.slice(0,64)}get kl(){return this.#w.slice(0,32)}get kr(){return this.#w.slice(32,64)}get c(){return this.#w.slice(64,96)}static random(t=Crypto.rand(Math.random())){return new Bip32PrivateKey(randomBytes(t,96))}static fromBip39Entropy(t,e=!0){const n=Crypto.pbkdf2(Crypto.hmacSha2_512,[],t,4096,96),r=n.slice(0,32),s=n.slice(32,64);e||assert(!(32&r[31]),"invalid root secret"),r[0]&=248,r[31]&=31,r[31]|=64;const a=n.slice(64,96);return new Bip32PrivateKey(r.concat(s).concat(a))}calcChildZ(t){const e=bigIntToBytes(BigInt(t)).reverse();for(;e.length<4;)e.push(0);if(assert(4==e.length,"child index too big"),t<2147483648){const t=this.derivePubKey().bytes;return Crypto.hmacSha2_512(this.c,[2].concat(t).concat(e))}return Crypto.hmacSha2_512(this.c,[0].concat(this.k).concat(e))}calcChildC(t){const e=bigIntToBytes(BigInt(t)).reverse();for(;e.length<4;)e.push(0);if(assert(4==e.length,"child index too big"),t<2147483648){const t=this.derivePubKey().bytes;return Crypto.hmacSha2_512(this.c,[3].concat(t).concat(e))}return Crypto.hmacSha2_512(this.c,[1].concat(this.k).concat(e))}derive(t){const e=this.calcChildZ(t),n=bigIntToLe32Bytes(8n*leBytesToBigInt(e.slice(0,28))+leBytesToBigInt(this.kl)).slice(0,32),r=bigIntToLe32Bytes(leBytesToBigInt(e.slice(32,64))+leBytesToBigInt(this.kr)%115792089237316195423570985008687907853269984665640564039457584007913129639936n).slice(0,32),s=this.calcChildC(t).slice(32,64);return new Bip32PrivateKey(n.concat(r).concat(s))}derivePath(t){let e=this;return t.forEach((t=>{e=e.derive(t)})),e}derivePubKey(){return this.#ur||(this.#ur=new PubKey(Ed25519.deriveBip32PublicKey(this.k))),this.#ur}sign(t){return new Signature(this.derivePubKey(),Ed25519.signBip32(t,this.k))}}export class RootPrivateKey{#pr;#hr;constructor(t){assert(16==t.length||20==t.length||24==t.length||28==t.length||32==t.length,`expected 16, 20, 24, 28 or 32 bytes for the root entropy, got ${t.length}`),this.#pr=t,this.#hr=Bip32PrivateKey.fromBip39Entropy(t)}static isValidPhrase(t,e=BIP39_DICT_EN){return(12==t.length||15==t.length||18==t.length||21==t.length||24==t.length)&&t.every((t=>-1!=e.findIndex((e=>e==t))))}static fromPhrase(t,e=BIP39_DICT_EN){assert(12==t.length||15==t.length||18==t.length||21==t.length||24==t.length,`expected phrase with 12, 15, 18, 21 or 24 words, got ${t.length} words`);const n=new BitWriter;t.forEach((t=>{const r=e.findIndex((e=>e==t));assert(-1!=r,`invalid phrase, ${t} not found in dict`),n.write(padZeroes(r.toString(2),11))}));const r=t.length/3;assert(r%1==0,"bad nChecksumBits"),assert(r>=4&&r<=8,"too many or too few nChecksumBits");const s=n.pop(r),a=n.finalize(!1);return assert(padZeroes(Crypto.sha2_256(a)[0].toString(2).slice(0,r),r)==s,"invalid checksum"),new RootPrivateKey(a)}get bytes(){return this.#hr.bytes}get entropy(){return this.#pr}toPhrase(t=BIP39_DICT_EN){const e=this.#pr.length/4,n=padZeroes(Crypto.sha2_256(this.#pr)[0].toString(2).slice(0,e),e),r=[];this.#pr.forEach((t=>{r.push(padZeroes(t.toString(2),8))})),r.push(n);let s=r.join("");assert(s.length%11==0);const a=[];for(;s.length>0;){const e=s.slice(0,11);assert(11==e.length,"didn't slice of exactly 11 bits");const n=parseInt(e,2);a.push(assertDefined(t[n],`dict entry ${n} not found`)),s=s.slice(11)}return assert(RootPrivateKey.isValidPhrase(a,t),"internal error: invalid phrase"),a}derive(t){return this.#hr.derive(t)}derivePath(t){return this.#hr.derivePath(t)}deriveSpendingRootKey(t=0){return this.derivePath([2147485500,2147485463,t+2147483648,0])}deriveStakingRootKey(t){return this.derivePath([2147485500,2147485463,t+2147483648,2])}deriveSpendingKey(t=0,e=0){return this.deriveSpendingRootKey(t).derive(e)}deriveStakingKey(t=0,e=0){return this.deriveStakingRootKey(t).derive(e)}derivePubKey(){return this.#hr.derivePubKey()}sign(t){return this.#hr.sign(t)}}export class Redeemer extends CborData{#mt;#dr;#mr;constructor(t,e={mem:0n,cpu:0n}){super(),this.#mt=t,this.#dr=e,this.#mr=null}get data(){return this.#mt}get memCost(){return this.#dr.mem}get cpuCost(){return this.#dr.cpu}setProgramName(t){this.#mr=t}get programName(){return this.#mr}toCborInternal(t,e){return Cbor.encodeTuple([Cbor.encodeInteger(BigInt(t)),Cbor.encodeInteger(BigInt(e)),this.#mt.toCbor(),Cbor.encodeTuple([Cbor.encodeInteger(this.#dr.mem),Cbor.encodeInteger(this.#dr.cpu)])])}static fromCbor(t){let e=null,n=null,r=null,s=null,a=Cbor.decodeTuple(t,((t,a)=>{switch(t){case 0:e=Number(Cbor.decodeInteger(a));break;case 1:n=Number(Cbor.decodeInteger(a));break;case 2:r=UplcData.fromCbor(a);break;case 3:let t=null,i=null;if(assert(2==Cbor.decodeTuple(a,((e,n)=>{switch(e){case 0:t=Cbor.decodeInteger(n);break;case 1:i=Cbor.decodeInteger(n);break;default:throw new Error("unrecognized field")}}))),null===t||null===i)throw new Error("unexpected");s={mem:t,cpu:i};break;default:throw new Error("unrecognized field")}}));if(assert(4==a),null===e||null===n||null===r||null===s)throw new Error("unexpected");switch(e){case 0:return new SpendingRedeemer(null,n,r,s);case 1:return new MintingRedeemer(null,n,r,s);default:throw new Error("unhandled redeemer type (Todo)")}}dumpInternal(){return{json:this.#mt.toSchemaJson(),cbor:this.#mt.toCborHex(),exUnits:{mem:this.#dr.mem.toString(),cpu:this.#dr.cpu.toString()}}}dump(){throw new Error("not yet implemented")}toScriptPurposeData(t){throw new Error("not yet implemented")}updateIndex(t){throw new Error("not yet implemented")}setProfile(t){this.#dr=t}get profile(){return this.#dr}estimateFee(t){let[e,n]=t.exFeeParams;return BigInt(Math.ceil(Number(this.#dr.mem)*e+Number(this.#dr.cpu)*n))}}export class SpendingRedeemer extends Redeemer{#fr;#yr;constructor(t,e,n,r={mem:0n,cpu:0n}){super(n,r),this.#fr=t,this.#yr=e}get inputIndex(){return this.#yr}toCbor(){return this.toCborInternal(0,this.#yr)}dump(){let t=super.dumpInternal();return t.type=0,t.typeName="spending",t.inputIndex=this.#yr,t}toScriptPurposeData(t){return new ConstrData(1,[t.inputs[this.#yr].toOutputIdData()])}updateIndex(t){if(null==this.#fr)throw new Error("input can't be null");this.#yr=t.inputs.findIndex((t=>t.txId.eq(assertDefined(this.#fr).txId)&&t.utxoIdx==assertDefined(this.#fr).utxoIdx)),assert(-1!=this.#yr)}}export class MintingRedeemer extends Redeemer{#B;#gr;constructor(t,e,n,r={mem:0n,cpu:0n}){super(n,r),this.#B=t,this.#gr=e}get mphIndex(){return this.#gr}toCbor(){return this.toCborInternal(1,this.#gr)}dump(){let t=super.dumpInternal();return t.type=1,t.typeName="minting",t.mphIndex=this.#gr,t}toScriptPurposeData(t){let e=t.minted.mintingPolicies[this.#gr];return new ConstrData(0,[new ByteArrayData(e.bytes)])}updateIndex(t){if(null===this.#B)throw new Error("can't have null mph at this point");this.#gr=t.minted.mintingPolicies.findIndex((t=>t.eq(assertDefined(this.#B)))),assert(-1!=this.#gr)}}export class Datum extends CborData{constructor(){super()}static fromCbor(t){let e=null,n=null,r=Cbor.decodeTuple(t,((t,r)=>{switch(t){case 0:e=Number(Cbor.decodeInteger(r));break;case 1:if(0==e)n=new HashedDatum(DatumHash.fromCbor(r));else if(1==e){assert(24n==Cbor.decodeTag(r));let t=Cbor.decodeBytes(r),e=UplcData.fromCbor(t);n=new InlineDatum(e)}break;default:throw new Error("unrecognized field label")}}));if(assert(2==r),null===e||null===n)throw new Error("unexpected");return n}static fromUplcData(t){if(0==t.index)return assert(0==t.fields.length),null;if(1==t.index)return assert(1==t.fields.length),new HashedDatum(DatumHash.fromUplcData(t.fields[0]));if(2==t.index)return assert(1==t.fields.length),new InlineDatum(t.fields[0]);throw new Error("unhandled constr index")}static hashed(t){return t instanceof HeliosData?HashedDatum.fromData(t._toUplcData()):HashedDatum.fromData(UplcDataValue.unwrap(t))}static inline(t){return new InlineDatum(t instanceof HeliosData?t._toUplcData():UplcDataValue.unwrap(t))}isInline(){throw new Error("not yet implemented")}isHashed(){throw new Error("not yet implemented")}get hash(){throw new Error("not yet implemented")}get data(){throw new Error("not yet implemented")}dump(){throw new Error("not yet implemented")}toData(){throw new Error("not yet implemented")}}export class HashedDatum extends Datum{#wr;#Tr;constructor(t,e=null){super(),this.#wr=t,this.#Tr=e,null!==this.#Tr&&assert(eq(this.#wr.bytes,Crypto.blake2b(this.#Tr.toCbor())))}isInline(){return!1}isHashed(){return!0}get hash(){return this.#wr}get data(){return this.#Tr}toData(){return new ConstrData(1,[new ByteArrayData(this.#wr.bytes)])}toCbor(){return Cbor.encodeTuple([Cbor.encodeInteger(0n),this.#wr.toCbor()])}static fromData(t){return new HashedDatum(new Hash(Crypto.blake2b(t.toCbor())),t)}dump(){return{hash:this.#wr.dump(),cbor:null===this.#Tr?null:bytesToHex(this.#Tr.toCbor()),schema:null===this.#Tr?null:JSON.parse(this.#Tr.toSchemaJson())}}}class InlineDatum extends Datum{#mt;constructor(t){super(),this.#mt=t}isInline(){return!0}isHashed(){return!1}get hash(){return new DatumHash(Crypto.blake2b(this.#mt.toCbor()))}get data(){return this.#mt}toData(){return new ConstrData(2,[this.#mt])}toCbor(){return Cbor.encodeTuple([Cbor.encodeInteger(1n),Cbor.encodeTag(24n).concat(Cbor.encodeBytes(this.#mt.toCbor()))])}dump(){return{inlineCbor:bytesToHex(this.#mt.toCbor()),inlineSchema:JSON.parse(this.#mt.toSchemaJson())}}}function encodeMetadata(t){if("string"==typeof t)return Cbor.encodeUtf8(t,!0);if("number"==typeof t)return assert(t%1==0),Cbor.encodeInteger(BigInt(t));if(Array.isArray(t))return Cbor.encodeDefList(t.map((t=>encodeMetadata(t))));if(t instanceof Object&&"map"in t&&1==Object.keys(t).length){let e=t.map;if(Array.isArray(e))return Cbor.encodeMap(e.map((t=>{if(Array.isArray(t)&&2==t.length)return[encodeMetadata(t[0]),encodeMetadata(t[1])];throw new Error("invalid metadata schema")})));throw new Error("invalid metadata schema")}throw new Error("invalid metadata schema")}function decodeMetadata(t){if(Cbor.isUtf8(t))return Cbor.decodeUtf8(t);if(Cbor.isList(t)){let e=[];return Cbor.decodeList(t,((t,n)=>{e.push(decodeMetadata(n))})),e}if(Cbor.isMap(t)){let e=[];return Cbor.decodeMap(t,((t,n)=>{e.push([decodeMetadata(n),decodeMetadata(n)])})),{map:e}}return Number(Cbor.decodeInteger(t))}export class TxMetadata{#Bn;constructor(){this.#Bn={}}add(t,e){this.#Bn[t]=e}get keys(){return Object.keys(this.#Bn).map((t=>parseInt(t))).sort()}dump(){let t={};for(let e of this.keys)t[e]=this.#Bn[e];return t}toCbor(){const t=this.keys.map((t=>[Cbor.encodeInteger(BigInt(t)),encodeMetadata(this.#Bn[t])]));return Cbor.encodeMap(t)}static fromCbor(t){const e=new TxMetadata;return Cbor.decodeMap(t,((t,n)=>{e.add(Number(Cbor.decodeInteger(n)),decodeMetadata(n))})),e}}const SyntaxCategory={Normal:0,Comment:1,Literal:2,Symbol:3,Type:4,Keyword:5,Error:6};export function highlight(t){let e=t.length;const n=0,r=1,s=2,a=3,i=4,o=5,_=6,l=7,u=8,c=9;let p=new Uint8Array(e),h=0,d=n,m=[];for(let f=0;f<e;f++){let y=t[f],g=f==e-1;switch(d){case n:if("/"==y)g||"/"!=t[f+1]?g||"*"!=t[f+1]?p[h++]=SyntaxCategory.Symbol:(p[h++]=SyntaxCategory.Comment,p[h++]=SyntaxCategory.Comment,f++,d=s):(p[h++]=SyntaxCategory.Comment,p[h++]=SyntaxCategory.Comment,f++,d=r);else if("["==y||"]"==y||"{"==y||"}"==y||"("==y||")"==y){let e=new SymbolToken(new Site(new Source(t,""),f),y);if(Group.isOpenSymbol(e))m.push(e),p[h++]=SyntaxCategory.Normal;else{let t=m.pop();void 0===t?p[h++]=SyntaxCategory.Error:y==Group.matchSymbol(t)?p[h++]=SyntaxCategory.Normal:(p[t.site.startPos]=SyntaxCategory.Error,p[h++]=SyntaxCategory.Error)}}else if("%"==y||"!"==y||"&"==y||"*"==y||"+"==y||"-"==y||"<"==y||"="==y||">"==y||"|"==y)switch(y){case"&":g||"&"!=t[f+1]?p[h++]=SyntaxCategory.Normal:(p[h++]=SyntaxCategory.Symbol,p[h++]=SyntaxCategory.Symbol,f++);break;case"|":g||"|"!=t[f+1]?p[h++]=SyntaxCategory.Normal:(p[h++]=SyntaxCategory.Symbol,p[h++]=SyntaxCategory.Symbol,f++);break;case"!":case">":case"<":g||"="!=t[f+1]?p[h++]=SyntaxCategory.Symbol:(p[h++]=SyntaxCategory.Symbol,p[h++]=SyntaxCategory.Symbol,f++);break;case"=":g||"="!=t[f+1]&&">"!=t[f+1]?p[h++]=SyntaxCategory.Symbol:(p[h++]=SyntaxCategory.Symbol,p[h++]=SyntaxCategory.Symbol,f++);break;case"-":g||">"!=t[f+1]?p[h++]=SyntaxCategory.Symbol:(p[h++]=SyntaxCategory.Symbol,p[h++]=SyntaxCategory.Symbol,f++);break;default:p[h++]=SyntaxCategory.Symbol}else if('"'==y)p[h++]=SyntaxCategory.Literal,d=a;else if("0"==y)p[h++]=SyntaxCategory.Literal,d=i;else if(y>="1"&&y<="9")p[h++]=SyntaxCategory.Literal,d=u;else if("#"==y)p[h++]=SyntaxCategory.Literal,d=c;else if(y>="a"&&y<="z"||y>="A"&&y<="Z"||"_"==y){let n,r=f,s=[y];for(;f+1<e;){let e=t[f+1];if(!(e>="a"&&e<="z"||e>="A"&&e<="Z"||"_"==e||e>="0"&&e<="9"))break;s.push(e),f++}switch(s.join("")){case"true":case"false":n=SyntaxCategory.Literal;break;case"Bool":case"Int":case"ByteArray":case"String":case"Option":n=SyntaxCategory.Type;break;case"if":case"else":case"switch":case"func":case"const":case"struct":case"enum":case"import":case"print":case"error":case"self":n=SyntaxCategory.Keyword;break;case"testing":case"spending":case"staking":case"minting":case"endpoint":case"module":n=0==r?SyntaxCategory.Keyword:SyntaxCategory.Normal;break;default:n=SyntaxCategory.Normal}for(let t=r;t<r+s.length;t++)p[h++]=n}else p[h++]=SyntaxCategory.Normal;break;case r:p[h++]=SyntaxCategory.Comment,"\n"==y&&(d=n);break;case s:p[h++]=SyntaxCategory.Comment,"*"!=y||g||"/"!=t[f+1]||(f++,p[h++]=SyntaxCategory.Comment,d=n);break;case a:p[h++]=SyntaxCategory.Literal,'"'==y&&(d=n);break;case i:"x"==y?(p[h++]=SyntaxCategory.Literal,d=o):"o"==y?(p[h++]=SyntaxCategory.Literal,d=l):"b"==y?(p[h++]=SyntaxCategory.Literal,d=_):y>="0"&&y<="9"?(p[h++]=SyntaxCategory.Literal,d=u):(f--,d=n);break;case u:y>="0"&&y<="9"?p[h++]=SyntaxCategory.Literal:(f--,d=n);break;case o:case c:y>="a"&&y<="f"||y>="0"&&y<="9"?p[h++]=SyntaxCategory.Literal:(f--,d=n);break;case l:y>="0"&&y<="7"?p[h++]=SyntaxCategory.Literal:(f--,d=n);break;case _:"0"==y||"1"==y?p[h++]=SyntaxCategory.Literal:(f--,d=n);break;default:throw new Error("unhandled SyntaxState")}}for(let t of m)p[t.site.startPos]=SyntaxCategory.Error;return p}export const CoinSelection={selectExtremumFirst:(t,e,n)=>{let r=new Value,s=t.slice();const a=[];function i(t,i){s.sort(((t,e)=>{const r=i(t),s=i(e),a=n?-1:1;if(0n!=r&&0n==s)return a;if(0n==r&&0n!=s)return-a;if(0n==r&&0n==s)return 0;{const n=t.value.assets.nTokenTypes,i=e.value.assets.nTokenTypes;return n==i?Number(r-s)*a:n<i?a:-a}}));let o=0n;const _=[];for(;o<t||0n==o;){const t=s.shift();if(void 0===t)throw console.error(a.map((t=>JSON.stringify(t.dump(),void 0,"  ")))),console.error(JSON.stringify(e.dump(),void 0,"  ")),new Error("not enough utxos to cover amount");{const e=i(t);e>0n?(o+=e,a.push(t),r=r.add(t.value)):_.push(t)}}s=s.concat(_)}const o=e.assets.mintingPolicies;for(const t of o){const n=e.assets.getTokenNames(t);for(const s of n){const n=e.assets.get(t,s),a=r.assets.get(t,s);if(a<n){i(n-a,(e=>e.value.assets.get(t,s)))}}}const _=e.lovelace,l=r.lovelace;if(l<_){i(_-l,(t=>t.value.lovelace))}return assert(a.length+s.length==t.length,"internal error: select algorithm doesn't conserve utxos"),[a,s]},selectSmallestFirst:(t,e)=>CoinSelection.selectExtremumFirst(t,e,!1),selectLargestFirst:(t,e)=>CoinSelection.selectExtremumFirst(t,e,!0)};export class Cip30Wallet{#br;constructor(t){this.#br=t}async isMainnet(){return 1==await this.#br.getNetworkId()}get rewardAddresses(){return this.#br.getRewardAddresses().then((t=>{if(!Array.isArray(t))throw new Error("The wallet getRewardAddresses() call did not return an array.");return t.map((t=>new StakeAddress(hexToBytes(t))))}))}get usedAddresses(){return this.#br.getUsedAddresses().then((t=>t.map((t=>new Address(t)))))}get unusedAddresses(){return this.#br.getUnusedAddresses().then((t=>t.map((t=>new Address(t)))))}get utxos(){return this.#br.getUtxos().then((t=>t.map((t=>TxInput.fromFullCbor(hexToBytes(t))))))}get collateral(){return(this.#br.getCollateral||this.#br.experimental.getCollateral)().then((t=>t.map((t=>TxInput.fromFullCbor(hexToBytes(t))))))}async signData(t,e){if(!(t instanceof Address))throw new Error("The value in the addr parameter is not a Cardano Address object.");if("string"!=typeof e||e.length<1)throw new Error("The sigStructure parameter is empty or invalid.  Must be a non-empty string");const n=bytesToHex(textToBytes(e));return await this.#br.signData(t.toHex(),n)}async signTx(t){const e=await this.#br.signTx(bytesToHex(t.toCbor()),!0);return TxWitnesses.fromCbor(hexToBytes(e)).signatures}async submitTx(t){const e=await this.#br.submitTx(bytesToHex(t.toCbor()));return new TxId(e)}}export class WalletHelper{#xr;#Ir;constructor(t,e=void 0){this.#xr=t,this.#Ir=e}get allAddresses(){return this.#xr.usedAddresses.then((t=>this.#xr.unusedAddresses.then((e=>t.concat(e)))))}async calcBalance(){let t=new Value;const e=await this.getUtxos();for(const n of e)t=t.add(n.value);return t}get baseAddress(){return this.allAddresses.then((t=>assertDefined(t[0])))}get changeAddress(){return this.#xr.unusedAddresses.then((t=>0==t.length?this.#xr.usedAddresses.then((t=>{if(0==t.length)throw new Error("no addresses found");return t[t.length-1]})):t[0]))}get refUtxo(){return this.getUtxos().then((t=>0==t.length?null:assertDefined(t[0])))}async getUtxos(){try{const t=await this.#xr.utxos;if(t.length>0)return t}catch(t){if(!this.#Ir)throw console.error("fallback not set"),t}if(this.#Ir)return console.log("falling back to retrieving UTxOs through query layer"),this.#Ir(await this.#xr.usedAddresses);throw new Error("wallet returned 0 utxos, set the helper getUtxosFallback callback to use an Api query layer instead")}async pickUtxos(t,e=CoinSelection.selectSmallestFirst){return e(await this.getUtxos(),t)}async pickCollateral(t=2000000n){const e=(await this.getUtxos()).filter((t=>t.value.assets.isZero()));if(0==e.length)throw new Error("no pure UTxOs in wallet (needed for collateral)");const n=e.filter((e=>e.value.lovelace>=t));if(0==n.length)throw new Error("no UTxO in wallet that is big enough to cover collateral");return n.sort(((t,e)=>Number(t.value.lovelace-e.value.lovelace))),n[0]}async isOwnAddress(t){const e=t.pubKeyHash;return null!==e&&this.isOwnPubKeyHash(e)}async isOwnPubKeyHash(t){const e=await this.allAddresses;for(const n of e){const e=n.pubKeyHash;if(null!==e&&e.eq(t))return!0}return!1}async toJson(){const t=await this.#xr.isMainnet(),e=await this.#xr.usedAddresses,n=await this.#xr.unusedAddresses;return{isMainnet:t,usedAddresses:e.map((t=>t.toBech32())),unusedAddresses:n.map((t=>t.toBech32())),utxos:(await this.getUtxos()).map((t=>bytesToHex(t.toFullCbor())))}}}export class RemoteWallet{#Er;#Cr;#Sr;#vr;constructor(t,e,n,r){this.#Er=t,this.#Cr=e,this.#Sr=n,this.#vr=r}static fromJson(t){return"string"==typeof t?RemoteWallet.fromJson(JSON.parse(t)):new RemoteWallet(t.isMainnet,t.usedAddresses.map((t=>Address.fromBech32(t))),t.unusedAddresses.map((t=>Address.fromBech32(t))),t.utxos.map((t=>TxInput.fromFullCbor(t))))}async isMainnet(){return this.#Er}get rewardAddresses(){throw new Error("not yet implemented")}get usedAddresses(){return new Promise(((t,e)=>t(this.#Cr)))}get unusedAddresses(){return new Promise(((t,e)=>t(this.#Sr)))}get utxos(){return new Promise(((t,e)=>t(this.#vr)))}get collateral(){return new Promise(((t,e)=>t([])))}async signData(t,e){throw new Error("not yet implemented")}async signTx(t){throw new Error("a RemoteWallet can't sign a transaction")}async submitTx(t){throw new Error("a RemoteWallet can't submit a transaction")}}export class BlockfrostV0{#Rr;#Pr;constructor(t,e){this.#Rr=t,this.#Pr=e}get networkName(){return this.#Rr}static async resolveUsingUtxo(t,e){const n=e.mainnet,r=e.preprod,s=e.preview;if(void 0!==r){const e=new BlockfrostV0("preprod",r);if(await e.hasUtxo(t))return e}if(void 0!==s){const e=new BlockfrostV0("preview",s);if(await e.hasUtxo(t))return e}if(void 0!==n){const e=new BlockfrostV0("mainnet",n);if(await e.hasUtxo(t))return e}throw new Error("refUtxo not found on a network for which you have a project id")}static async resolveUsingWallet(t,e){if(await t.isMainnet())return new BlockfrostV0("mainnet",assertDefined(e.mainnet));{const n=new WalletHelper(t),r=await n.refUtxo;if(null===r)throw new Error("empty wallet, can't determine which testnet you are connecting to");return BlockfrostV0.resolveUsingUtxo(r,e)}}static async resolve(t,e){return t instanceof TxInput?BlockfrostV0.resolveUsingUtxo(t,e):BlockfrostV0.resolveUsingWallet(t,e)}static parseValue(t){let e=new Value;for(let n of t){let t=BigInt(n.quantity);if("lovelace"==n.unit)e=e.add(new Value(t));else{let r=n.unit.substring(0,56),s=MintingPolicyHash.fromHex(r),a=hexToBytes(n.unit.substring(56));e=e.add(new Value(0n,new Assets([[s,[[a,t]]]])))}}return e}async getParameters(){const t=await fetch(`https://d1t0d7c2nekuk0.cloudfront.net/${this.#Rr}.json`);return new NetworkParams(await t.json())}async getLatestEpoch(){const t=await fetch(`https://cardano-${this.#Rr}.blockfrost.io/api/v0/epochs/latest`,{method:"GET",headers:{project_id:this.#Pr}});return await t.json()}async getUtxo(t){const e=t.txId,n=`https://cardano-${this.#Rr}.blockfrost.io/api/v0/txs/${e.hex}/utxos`,r=await fetch(n,{method:"GET",headers:{project_id:this.#Pr}});if(!r.ok)throw new Error(`UTxO ${t.toString()} not found`);if(200!=r.status)throw new Error(`Blockfrost error: ${await r.text()}`);const s=await r.json(),a=s.outputs;if(!a)throw console.log(s),new Error("unexpected response from Blockfrost");const i=a[t.utxoIdx];if(!i)throw console.log(s),new Error(`UTxO ${t.toString()} not found`);return i.tx_hash=e.hex,i.output_index=Number(t.utxoIdx),await this.restoreTxInput(i)}async hasUtxo(t){const e=t.outputId.txId,n=`https://cardano-${this.#Rr}.blockfrost.io/api/v0/txs/${e.hex}/utxos`;return(await fetch(n,{method:"GET",headers:{project_id:this.#Pr}})).ok}async restoreTxInput(t){let e=null;if(null!==t.reference_script_hash){const n=`https://cardano-${this.#Rr}.blockfrost.io/api/v0/scripts/${t.reference_script_hash}/cbor`,r=await fetch(n,{method:"GET",headers:{project_id:this.#Pr}}),s=(await r.json()).cbor;e=UplcProgram.fromCbor(s)}return new TxInput(new TxOutputId(TxId.fromHex(t.tx_hash),t.output_index),new TxOutput(Address.fromBech32(t.address),BlockfrostV0.parseValue(t.amount),t.inline_datum?Datum.inline(UplcData.fromCbor(hexToBytes(t.inline_datum))):null,e))}async getUtxos(t){const e=`https://cardano-${this.#Rr}.blockfrost.io/api/v0/addresses/${t.toBech32()}/utxos?order=asc`;try{const t=await fetch(e,{headers:{project_id:this.#Pr}});if(404==t.status)return[];let n=await t.json();n?.status_code>=300&&(n=[]);try{return await Promise.all(n.map((t=>this.restoreTxInput(t))))}catch(t){throw console.error("unable to parse blockfrost utxo format:",n),t}}catch(t){if(t.message.includes("The requested component has not been found"))return[];throw t}}async submitTx(t){const e=new Uint8Array(t.toCbor()),n=`https://cardano-${this.#Rr}.blockfrost.io/api/v0/tx/submit`,r=await fetch(n,{method:"POST",headers:{"content-type":"application/cbor",project_id:this.#Pr},body:e}).catch((t=>{throw console.error(t),t})),s=await r.text();if(200!=r.status)throw new Error(s);return new TxId(JSON.parse(s))}async dumpMempool(){const t=`https://cardano-${this.#Rr}.blockfrost.io/api/v0/mempool`,e=await fetch(t,{method:"GET",headers:{project_id:this.#Pr}});console.log(await e.text())}}export class KoiosV0{#Rr;constructor(t){this.#Rr=t}get rootUrl(){return{preview:"https://preview.koios.rest",preprod:"https://preprod.koios.rest",guildnet:"https://guild.koios.rest",mainnet:"https://api.koios.rest"}[this.#Rr]}async getParameters(){const t=await fetch(`https://d1t0d7c2nekuk0.cloudfront.net/${this.#Rr}.json`);return new NetworkParams(await t.json())}async getUtxosInternal(t){const e=`${this.rootUrl}/api/v0/tx_info`,n=new Map;t.forEach((t=>{const e=n.get(t.txId.hex);e?e.push(t.utxoIdx):n.set(t.txId.hex,[t.utxoIdx])}));const r=await fetch(e,{method:"POST",headers:{accept:"application/json","content-type":"application/json"},body:JSON.stringify({_tx_hashes:Array.from(n.keys())})}),s=await r.text();if(200!=r.status)throw new Error(s);const a=JSON.parse(s),i=new Map,o=a;if(!Array.isArray(o))throw new Error(`unexpected tx_info format: ${s}`);return o.forEach((t=>{const e=t.outputs;if(!e)throw new Error(`unexpected tx_info format: ${JSON.stringify(t)}`);const r=assertDefined(n.get(t.tx_hash));for(let n of r){const r=new TxOutputId(new TxId(t.tx_hash),n),s=e[r.utxoIdx];if(!s)throw new Error(`UTxO ${r.toString()} doesn't exist`);const a=s.payment_addr?.bech32;if(!a||"string"!=typeof a)throw new Error(`unexpected tx_info format: ${JSON.stringify(t)}`);const o=s.stake_addr;if(void 0===o)throw new Error(`unexpected tx_info format: ${JSON.stringify(t)}`);const _=Address.fromBech32(a),l=o?StakeAddress.fromBech32(o):null,u=Address.fromHashes(assertDefined(_.pubKeyHash??_.validatorHash),l?.stakingHash??null,"mainnet"!=this.#Rr),c=BigInt(parseInt(assertDefined(s.value)));assert(c.toString()==s.value,`unexpected tx_info format: ${JSON.stringify(t)}`);const p=[];for(let e of s.asset_list){const n=BigInt(parseInt(e.quantity));assert(n.toString()==e.quantity,`unexpected tx_info format: ${JSON.stringify(t)}`),p.push([new AssetClass(`${e.policy_id}.${e.asset_name??""}`),n])}const h=s.inline_datum?Datum.inline(UplcData.fromCbor(s.inline_datum.bytes)):s.datum_hash?new HashedDatum(new DatumHash(s.datum_hash)):null,d=s.reference_script?UplcProgram.fromCbor(s.reference_script):null,m=new TxInput(r,new TxOutput(u,new Value(c,new Assets(p)),h,d));i.set(r.toString(),m)}})),t.map((t=>assertDefined(i.get(t.toString()))))}static async resolveUsingUtxo(t){const e=new KoiosV0("preprod");if(await e.hasUtxo(t))return e;const n=new KoiosV0("preview");if(await n.hasUtxo(t))return n;const r=new KoiosV0("mainnet");if(await r.hasUtxo(t))return r;throw new Error("refUtxo not found on any network")}async getUtxo(t){return assertDefined(await this.getUtxosInternal([t])[0])}async hasUtxo(t){const e=`${this.rootUrl}/api/v0/tx_info`;return(await fetch(e,{method:"GET",headers:{accept:"application/json","content-type":"application/json"},body:JSON.stringify({_tx_hashes:[t.outputId.txId.hex]})})).ok}async getUtxos(t){const e=`${this.rootUrl}/api/v0/credential_utxos`,n=await fetch(e,{method:"POST",headers:{accept:"application/json","content-type":"application/json"},body:JSON.stringify({_payment_credentials:[assertDefined(t.pubKeyHash??t.validatorHash).hex]})}),r=await n.text();if(200!=n.status)throw new Error(r);const s=JSON.parse(r);if(!Array.isArray(s))throw new Error(`unexpected credential_utxos format: ${r}`);const a=s.map((t=>{const e=Number(t.tx_index);return new TxOutputId(new TxId(t.tx_hash),e)}));return this.getUtxosInternal(a)}async submitTx(t){const e=`${this.rootUrl}/api/v0/submittx`,n=await fetch(e,{method:"POST",headers:{accept:"application/json","content-type":"application/cbor"},body:new Uint8Array(t.toCbor())}),r=await n.text();if(200!=n.status)throw new Error(r);return new TxId(r)}}export class FuncArg extends NameTypePair{#Dr;constructor(t,e,n=null){super(t,e),this.#Dr=n}evalDefault(t){if(null!=this.#Dr){const e=this.#Dr.eval(t);if(!e)return;const n=e.asTyped;if(!n)return void this.#Dr.typeError("not typed");const r=this.evalType(t);if(!r)return;if(!r.isBaseOf(n.type))return void this.#Dr.site.typeError(`expected ${r.toString()}, got ${n.type.toString()}`)}}evalArgType(t){const e=super.evalType(t);return e?new ArgType(this.name,e,null!=this.#Dr):null}toIR(){const t=super.toIR();return null==this.#Dr?t:new IR([new IR(`__useopt__${this.name.toString()}`),new IR(", "),t])}static wrapWithDefaultInternal(t,e,n){return new IR([new IR(`(${e}) -> {`),t,new IR([new IR(`}(__core__ifThenElse(__useopt__${e}, () -> {${e}}, () -> {`),n,new IR("})())")])])}wrapWithDefault(t,e){if(null==this.#Dr)return e;{const n=this.name.toString();return FuncArg.wrapWithDefaultInternal(e,n,this.#Dr.toIR(t))}}}export class FuncLiteralExpr extends Expr{#Fr;#fe;#Me;constructor(t,e,n,r){super(t),this.#Fr=e,this.#fe=n,this.#Me=r}get nArgs(){return this.#Fr.length}get argNames(){return this.#Fr.map((t=>t.name.value))}get argTypes(){return this.#Fr.map((t=>t.type))}get argTypeNames(){return this.#Fr.map((t=>t.typeName))}get retExpr(){let t=this.#Me;for(;t instanceof ChainExpr;)t=t.downstreamExpr;return t}get retType(){return null===this.#fe?new AllType:assertDefined(this.#fe.cache?.asType)}isLiteral(){return!0}evalType(t){let e=this.#Fr;this.isMethod()&&(e=e.slice(1));const n=reduceNull(e.map((e=>e.evalArgType(t)))),r=this.#fe?this.#fe.evalAsType(t):new AllType;return null===n||null===r?null:new FuncType(n,r)}evalInternal(t){const e=this.evalType(t);if(!e)return null;const n=this.#Fr.map((e=>e.evalType(t))),r=new Scope(t,!0);n.forEach(((t,e)=>{t&&!this.#Fr[e].isIgnored()&&(this.#Fr[e].evalDefault(r),r.set(this.#Fr[e].name,t.toTyped()))}));let s=this.#Me.eval(r);return s?null==this.#fe?s.asTyped?new FuncEntity(new FuncType(e.argTypes,s.asTyped.type)):(this.#Me.typeError("expect multi or typed"),null):s.asTyped?e.retType.isBaseOf(s.asTyped.type)?(r.assertAllUsed(),new FuncEntity(e)):(this.#fe.typeError(`wrong return type, expected ${e.retType.toString()} but got ${s.asTyped.type.toString()}`),null):(this.#Me.typeError("expect multi or typed"),null):null}isMethod(){return this.#Fr.length>0&&"self"==this.#Fr[0].name.toString()}argsToIR(){let t=this.#Fr.map((t=>t.toIR()));return this.isMethod()&&(t=t.slice(1)),new IR(t).join(", ")}wrapWithDefaultArgs(t,e){const n=this.#Fr.slice().reverse();for(let r of n)e=r.wrapWithDefault(t,e);return e}toIRInternal(t){let e=this.argsToIR(),n=t.indent,r=t.indent;this.isMethod()&&(n+=TAB);let s=this.#Me.toIR(t.tab());s=this.wrapWithDefaultArgs(t,s);let a=new IR([new IR("("),e,new IR(") "),new IR("->",this.site),new IR(` {\n${n}${TAB}`),s,new IR(`\n${n}}`)]);return this.isMethod()&&(a=new IR([new IR(`(self) -> {\n${r}${TAB}`),a,new IR(`\n${r}}`)])),a}toIR(t){return this.toIRInternal(t)}toString(){return null==this.#fe?`(${this.#Fr.map((t=>t.toString())).join(", ")}) -> {${this.#Me.toString()}}`:`(${this.#Fr.map((t=>t.toString())).join(", ")}) -> ${this.#fe.toString()} {${this.#Me.toString()}}`}}export const rawNetworkEmulatorParams={shelleyGenesis:{activeSlotsCoeff:.05,epochLength:432e3,genDelegs:{"637f2e950b0fd8f8e3e811c5fbeb19e411e7a2bf37272b84b29c1a0b":{delegate:"aae9293510344ddd636364c2673e34e03e79e3eefa8dbaa70e326f7d",vrf:"227116365af2ed943f1a8b5e6557bfaa34996f1578eec667a5e2b361c51e4ce7"},"8a4b77c4f534f8b8cc6f269e5ebb7ba77fa63a476e50e05e66d7051c":{delegate:"d15422b2e8b60e500a82a8f4ceaa98b04e55a0171d1125f6c58f8758",vrf:"0ada6c25d62db5e1e35d3df727635afa943b9e8a123ab83785e2281605b09ce2"},b00470cd193d67aac47c373602fccd4195aad3002c169b5570de1126:{delegate:"b3b539e9e7ed1b32fbf778bf2ebf0a6b9f980eac90ac86623d11881a",vrf:"0ff0ce9b820376e51c03b27877cd08f8ba40318f1a9f85a3db0b60dd03f71a7a"},b260ffdb6eba541fcf18601923457307647dce807851b9d19da133ab:{delegate:"7c64eb868b4ef566391a321c85323f41d2b95480d7ce56ad2abcb022",vrf:"7fb22abd39d550c9a022ec8104648a26240a9ff9c88b8b89a6e20d393c03098e"},ced1599fd821a39593e00592e5292bdc1437ae0f7af388ef5257344a:{delegate:"de7ca985023cf892f4de7f5f1d0a7181668884752d9ebb9e96c95059",vrf:"c301b7fc4d1b57fb60841bcec5e3d2db89602e5285801e522fce3790987b1124"},dd2a7d71a05bed11db61555ba4c658cb1ce06c8024193d064f2a66ae:{delegate:"1e113c218899ee7807f4028071d0e108fc790dade9fd1a0d0b0701ee",vrf:"faf2702aa4893c877c622ab22dfeaf1d0c8aab98b837fe2bf667314f0d043822"},f3b9e74f7d0f24d2314ea5dfbca94b65b2059d1ff94d97436b82d5b4:{delegate:"fd637b08cc379ef7b99c83b416458fcda8a01a606041779331008fb9",vrf:"37f2ea7c843a688159ddc2c38a2f997ab465150164a9136dca69564714b73268"}},initialFunds:{},maxKESEvolutions:120,maxLovelaceSupply:45e15,networkId:"Testnet",networkMagic:1,protocolParams:{a0:.1,decentralisationParam:1,eMax:18,extraEntropy:{tag:"NeutralNonce"},keyDeposit:4e5,maxBlockBodySize:65536,maxBlockHeaderSize:1100,maxTxSize:16384,minFeeA:44,minFeeB:155381,minPoolCost:0,minUTxOValue:0,nOpt:50,poolDeposit:5e8,protocolVersion:{major:2,minor:0},rho:.00178650067,tau:.1},securityParam:2160,slotLength:1,slotsPerKESPeriod:86400,staking:{pools:{},stake:{}},systemStart:"2022-06-01T00:00:00Z",updateQuorum:5},alonzoGenesis:{lovelacePerUTxOWord:34482,executionPrices:{prSteps:{numerator:721,denominator:1e7},prMem:{numerator:577,denominator:1e4}},maxTxExUnits:{exUnitsMem:1e7,exUnitsSteps:1e10},maxBlockExUnits:{exUnitsMem:5e7,exUnitsSteps:4e10},maxValueSize:5e3,collateralPercentage:150,maxCollateralInputs:3,costModels:{PlutusV1:{"sha2_256-memory-arguments":4,"equalsString-cpu-arguments-constant":1e3,"cekDelayCost-exBudgetMemory":100,"lessThanEqualsByteString-cpu-arguments-intercept":103599,"divideInteger-memory-arguments-minimum":1,"appendByteString-cpu-arguments-slope":621,"blake2b-cpu-arguments-slope":29175,"iData-cpu-arguments":15e4,"encodeUtf8-cpu-arguments-slope":1e3,"unBData-cpu-arguments":15e4,"multiplyInteger-cpu-arguments-intercept":61516,"cekConstCost-exBudgetMemory":100,"nullList-cpu-arguments":15e4,"equalsString-cpu-arguments-intercept":15e4,"trace-cpu-arguments":15e4,"mkNilData-memory-arguments":32,"lengthOfByteString-cpu-arguments":15e4,"cekBuiltinCost-exBudgetCPU":29773,"bData-cpu-arguments":15e4,"subtractInteger-cpu-arguments-slope":0,"unIData-cpu-arguments":15e4,"consByteString-memory-arguments-intercept":0,"divideInteger-memory-arguments-slope":1,"divideInteger-cpu-arguments-model-arguments-slope":118,"listData-cpu-arguments":15e4,"headList-cpu-arguments":15e4,"chooseData-memory-arguments":32,"equalsInteger-cpu-arguments-intercept":136542,"sha3_256-cpu-arguments-slope":82363,"sliceByteString-cpu-arguments-slope":5e3,"unMapData-cpu-arguments":15e4,"lessThanInteger-cpu-arguments-intercept":179690,"mkCons-cpu-arguments":15e4,"appendString-memory-arguments-intercept":0,"modInteger-cpu-arguments-model-arguments-slope":118,"ifThenElse-cpu-arguments":1,"mkNilPairData-cpu-arguments":15e4,"lessThanEqualsInteger-cpu-arguments-intercept":145276,"addInteger-memory-arguments-slope":1,"chooseList-memory-arguments":32,"constrData-memory-arguments":32,"decodeUtf8-cpu-arguments-intercept":15e4,"equalsData-memory-arguments":1,"subtractInteger-memory-arguments-slope":1,"appendByteString-memory-arguments-intercept":0,"lengthOfByteString-memory-arguments":4,"headList-memory-arguments":32,"listData-memory-arguments":32,"consByteString-cpu-arguments-intercept":15e4,"unIData-memory-arguments":32,"remainderInteger-memory-arguments-minimum":1,"bData-memory-arguments":32,"lessThanByteString-cpu-arguments-slope":248,"encodeUtf8-memory-arguments-intercept":0,"cekStartupCost-exBudgetCPU":100,"multiplyInteger-memory-arguments-intercept":0,"unListData-memory-arguments":32,"remainderInteger-cpu-arguments-model-arguments-slope":118,"cekVarCost-exBudgetCPU":29773,"remainderInteger-memory-arguments-slope":1,"cekForceCost-exBudgetCPU":29773,"sha2_256-cpu-arguments-slope":29175,"equalsInteger-memory-arguments":1,"indexByteString-memory-arguments":1,"addInteger-memory-arguments-intercept":1,"chooseUnit-cpu-arguments":15e4,"sndPair-cpu-arguments":15e4,"cekLamCost-exBudgetCPU":29773,"fstPair-cpu-arguments":15e4,"quotientInteger-memory-arguments-minimum":1,"decodeUtf8-cpu-arguments-slope":1e3,"lessThanInteger-memory-arguments":1,"lessThanEqualsInteger-cpu-arguments-slope":1366,"fstPair-memory-arguments":32,"modInteger-memory-arguments-intercept":0,"unConstrData-cpu-arguments":15e4,"lessThanEqualsInteger-memory-arguments":1,"chooseUnit-memory-arguments":32,"sndPair-memory-arguments":32,"addInteger-cpu-arguments-intercept":197209,"decodeUtf8-memory-arguments-slope":8,"equalsData-cpu-arguments-intercept":15e4,"mapData-cpu-arguments":15e4,"mkPairData-cpu-arguments":15e4,"quotientInteger-cpu-arguments-constant":148e3,"consByteString-memory-arguments-slope":1,"cekVarCost-exBudgetMemory":100,"indexByteString-cpu-arguments":15e4,"unListData-cpu-arguments":15e4,"equalsInteger-cpu-arguments-slope":1326,"cekStartupCost-exBudgetMemory":100,"subtractInteger-cpu-arguments-intercept":197209,"divideInteger-cpu-arguments-model-arguments-intercept":425507,"divideInteger-memory-arguments-intercept":0,"cekForceCost-exBudgetMemory":100,"blake2b-cpu-arguments-intercept":2477736,"remainderInteger-cpu-arguments-constant":148e3,"tailList-cpu-arguments":15e4,"encodeUtf8-cpu-arguments-intercept":15e4,"equalsString-cpu-arguments-slope":1e3,"lessThanByteString-memory-arguments":1,"multiplyInteger-cpu-arguments-slope":11218,"appendByteString-cpu-arguments-intercept":396231,"lessThanEqualsByteString-cpu-arguments-slope":248,"modInteger-memory-arguments-slope":1,"addInteger-cpu-arguments-slope":0,"equalsData-cpu-arguments-slope":1e4,"decodeUtf8-memory-arguments-intercept":0,"chooseList-cpu-arguments":15e4,"constrData-cpu-arguments":15e4,"equalsByteString-memory-arguments":1,"cekApplyCost-exBudgetCPU":29773,"quotientInteger-memory-arguments-slope":1,"verifySignature-cpu-arguments-intercept":3345831,"unMapData-memory-arguments":32,"mkCons-memory-arguments":32,"sliceByteString-memory-arguments-slope":1,"sha3_256-memory-arguments":4,"ifThenElse-memory-arguments":1,"mkNilPairData-memory-arguments":32,"equalsByteString-cpu-arguments-slope":247,"appendString-cpu-arguments-intercept":15e4,"quotientInteger-cpu-arguments-model-arguments-slope":118,"cekApplyCost-exBudgetMemory":100,"equalsString-memory-arguments":1,"multiplyInteger-memory-arguments-slope":1,"cekBuiltinCost-exBudgetMemory":100,"remainderInteger-memory-arguments-intercept":0,"sha2_256-cpu-arguments-intercept":2477736,"remainderInteger-cpu-arguments-model-arguments-intercept":425507,"lessThanEqualsByteString-memory-arguments":1,"tailList-memory-arguments":32,"mkNilData-cpu-arguments":15e4,"chooseData-cpu-arguments":15e4,"unBData-memory-arguments":32,"blake2b-memory-arguments":4,"iData-memory-arguments":32,"nullList-memory-arguments":32,"cekDelayCost-exBudgetCPU":29773,"subtractInteger-memory-arguments-intercept":1,"lessThanByteString-cpu-arguments-intercept":103599,"consByteString-cpu-arguments-slope":1e3,"appendByteString-memory-arguments-slope":1,"trace-memory-arguments":32,"divideInteger-cpu-arguments-constant":148e3,"cekConstCost-exBudgetCPU":29773,"encodeUtf8-memory-arguments-slope":8,"quotientInteger-cpu-arguments-model-arguments-intercept":425507,"mapData-memory-arguments":32,"appendString-cpu-arguments-slope":1e3,"modInteger-cpu-arguments-constant":148e3,"verifySignature-cpu-arguments-slope":1,"unConstrData-memory-arguments":32,"quotientInteger-memory-arguments-intercept":0,"equalsByteString-cpu-arguments-constant":15e4,"sliceByteString-memory-arguments-intercept":0,"mkPairData-memory-arguments":32,"equalsByteString-cpu-arguments-intercept":112536,"appendString-memory-arguments-slope":1,"lessThanInteger-cpu-arguments-slope":497,"modInteger-cpu-arguments-model-arguments-intercept":425507,"modInteger-memory-arguments-minimum":1,"sha3_256-cpu-arguments-intercept":0,"verifySignature-memory-arguments":1,"cekLamCost-exBudgetMemory":100,"sliceByteString-cpu-arguments-intercept":15e4}}},latestParams:{collateralPercentage:150,costModels:{PlutusScriptV1:{"addInteger-cpu-arguments-intercept":205665,"addInteger-cpu-arguments-slope":812,"addInteger-memory-arguments-intercept":1,"addInteger-memory-arguments-slope":1,"appendByteString-cpu-arguments-intercept":1e3,"appendByteString-cpu-arguments-slope":571,"appendByteString-memory-arguments-intercept":0,"appendByteString-memory-arguments-slope":1,"appendString-cpu-arguments-intercept":1e3,"appendString-cpu-arguments-slope":24177,"appendString-memory-arguments-intercept":4,"appendString-memory-arguments-slope":1,"bData-cpu-arguments":1e3,"bData-memory-arguments":32,"blake2b_256-cpu-arguments-intercept":117366,"blake2b_256-cpu-arguments-slope":10475,"blake2b_256-memory-arguments":4,"cekApplyCost-exBudgetCPU":23e3,"cekApplyCost-exBudgetMemory":100,"cekBuiltinCost-exBudgetCPU":23e3,"cekBuiltinCost-exBudgetMemory":100,"cekConstCost-exBudgetCPU":23e3,"cekConstCost-exBudgetMemory":100,"cekDelayCost-exBudgetCPU":23e3,"cekDelayCost-exBudgetMemory":100,"cekForceCost-exBudgetCPU":23e3,"cekForceCost-exBudgetMemory":100,"cekLamCost-exBudgetCPU":23e3,"cekLamCost-exBudgetMemory":100,"cekStartupCost-exBudgetCPU":100,"cekStartupCost-exBudgetMemory":100,"cekVarCost-exBudgetCPU":23e3,"cekVarCost-exBudgetMemory":100,"chooseData-cpu-arguments":19537,"chooseData-memory-arguments":32,"chooseList-cpu-arguments":175354,"chooseList-memory-arguments":32,"chooseUnit-cpu-arguments":46417,"chooseUnit-memory-arguments":4,"consByteString-cpu-arguments-intercept":221973,"consByteString-cpu-arguments-slope":511,"consByteString-memory-arguments-intercept":0,"consByteString-memory-arguments-slope":1,"constrData-cpu-arguments":89141,"constrData-memory-arguments":32,"decodeUtf8-cpu-arguments-intercept":497525,"decodeUtf8-cpu-arguments-slope":14068,"decodeUtf8-memory-arguments-intercept":4,"decodeUtf8-memory-arguments-slope":2,"divideInteger-cpu-arguments-constant":196500,"divideInteger-cpu-arguments-model-arguments-intercept":453240,"divideInteger-cpu-arguments-model-arguments-slope":220,"divideInteger-memory-arguments-intercept":0,"divideInteger-memory-arguments-minimum":1,"divideInteger-memory-arguments-slope":1,"encodeUtf8-cpu-arguments-intercept":1e3,"encodeUtf8-cpu-arguments-slope":28662,"encodeUtf8-memory-arguments-intercept":4,"encodeUtf8-memory-arguments-slope":2,"equalsByteString-cpu-arguments-constant":245e3,"equalsByteString-cpu-arguments-intercept":216773,"equalsByteString-cpu-arguments-slope":62,"equalsByteString-memory-arguments":1,"equalsData-cpu-arguments-intercept":1060367,"equalsData-cpu-arguments-slope":12586,"equalsData-memory-arguments":1,"equalsInteger-cpu-arguments-intercept":208512,"equalsInteger-cpu-arguments-slope":421,"equalsInteger-memory-arguments":1,"equalsString-cpu-arguments-constant":187e3,"equalsString-cpu-arguments-intercept":1e3,"equalsString-cpu-arguments-slope":52998,"equalsString-memory-arguments":1,"fstPair-cpu-arguments":80436,"fstPair-memory-arguments":32,"headList-cpu-arguments":43249,"headList-memory-arguments":32,"iData-cpu-arguments":1e3,"iData-memory-arguments":32,"ifThenElse-cpu-arguments":80556,"ifThenElse-memory-arguments":1,"indexByteString-cpu-arguments":57667,"indexByteString-memory-arguments":4,"lengthOfByteString-cpu-arguments":1e3,"lengthOfByteString-memory-arguments":10,"lessThanByteString-cpu-arguments-intercept":197145,"lessThanByteString-cpu-arguments-slope":156,"lessThanByteString-memory-arguments":1,"lessThanEqualsByteString-cpu-arguments-intercept":197145,"lessThanEqualsByteString-cpu-arguments-slope":156,"lessThanEqualsByteString-memory-arguments":1,"lessThanEqualsInteger-cpu-arguments-intercept":204924,"lessThanEqualsInteger-cpu-arguments-slope":473,"lessThanEqualsInteger-memory-arguments":1,"lessThanInteger-cpu-arguments-intercept":208896,"lessThanInteger-cpu-arguments-slope":511,"lessThanInteger-memory-arguments":1,"listData-cpu-arguments":52467,"listData-memory-arguments":32,"mapData-cpu-arguments":64832,"mapData-memory-arguments":32,"mkCons-cpu-arguments":65493,"mkCons-memory-arguments":32,"mkNilData-cpu-arguments":22558,"mkNilData-memory-arguments":32,"mkNilPairData-cpu-arguments":16563,"mkNilPairData-memory-arguments":32,"mkPairData-cpu-arguments":76511,"mkPairData-memory-arguments":32,"modInteger-cpu-arguments-constant":196500,"modInteger-cpu-arguments-model-arguments-intercept":453240,"modInteger-cpu-arguments-model-arguments-slope":220,"modInteger-memory-arguments-intercept":0,"modInteger-memory-arguments-minimum":1,"modInteger-memory-arguments-slope":1,"multiplyInteger-cpu-arguments-intercept":69522,"multiplyInteger-cpu-arguments-slope":11687,"multiplyInteger-memory-arguments-intercept":0,"multiplyInteger-memory-arguments-slope":1,"nullList-cpu-arguments":60091,"nullList-memory-arguments":32,"quotientInteger-cpu-arguments-constant":196500,"quotientInteger-cpu-arguments-model-arguments-intercept":453240,"quotientInteger-cpu-arguments-model-arguments-slope":220,"quotientInteger-memory-arguments-intercept":0,"quotientInteger-memory-arguments-minimum":1,"quotientInteger-memory-arguments-slope":1,"remainderInteger-cpu-arguments-constant":196500,"remainderInteger-cpu-arguments-model-arguments-intercept":453240,"remainderInteger-cpu-arguments-model-arguments-slope":220,"remainderInteger-memory-arguments-intercept":0,"remainderInteger-memory-arguments-minimum":1,"remainderInteger-memory-arguments-slope":1,"sha2_256-cpu-arguments-intercept":806990,"sha2_256-cpu-arguments-slope":30482,"sha2_256-memory-arguments":4,"sha3_256-cpu-arguments-intercept":1927926,"sha3_256-cpu-arguments-slope":82523,"sha3_256-memory-arguments":4,"sliceByteString-cpu-arguments-intercept":265318,"sliceByteString-cpu-arguments-slope":0,"sliceByteString-memory-arguments-intercept":4,"sliceByteString-memory-arguments-slope":0,"sndPair-cpu-arguments":85931,"sndPair-memory-arguments":32,"subtractInteger-cpu-arguments-intercept":205665,"subtractInteger-cpu-arguments-slope":812,"subtractInteger-memory-arguments-intercept":1,"subtractInteger-memory-arguments-slope":1,"tailList-cpu-arguments":41182,"tailList-memory-arguments":32,"trace-cpu-arguments":212342,"trace-memory-arguments":32,"unBData-cpu-arguments":31220,"unBData-memory-arguments":32,"unConstrData-cpu-arguments":32696,"unConstrData-memory-arguments":32,"unIData-cpu-arguments":43357,"unIData-memory-arguments":32,"unListData-cpu-arguments":32247,"unListData-memory-arguments":32,"unMapData-cpu-arguments":38314,"unMapData-memory-arguments":32,"verifyEd25519Signature-cpu-arguments-intercept":9462713,"verifyEd25519Signature-cpu-arguments-slope":1021,"verifyEd25519Signature-memory-arguments":10},PlutusScriptV2:{"addInteger-cpu-arguments-intercept":205665,"addInteger-cpu-arguments-slope":812,"addInteger-memory-arguments-intercept":1,"addInteger-memory-arguments-slope":1,"appendByteString-cpu-arguments-intercept":1e3,"appendByteString-cpu-arguments-slope":571,"appendByteString-memory-arguments-intercept":0,"appendByteString-memory-arguments-slope":1,"appendString-cpu-arguments-intercept":1e3,"appendString-cpu-arguments-slope":24177,"appendString-memory-arguments-intercept":4,"appendString-memory-arguments-slope":1,"bData-cpu-arguments":1e3,"bData-memory-arguments":32,"blake2b_256-cpu-arguments-intercept":117366,"blake2b_256-cpu-arguments-slope":10475,"blake2b_256-memory-arguments":4,"cekApplyCost-exBudgetCPU":23e3,"cekApplyCost-exBudgetMemory":100,"cekBuiltinCost-exBudgetCPU":23e3,"cekBuiltinCost-exBudgetMemory":100,"cekConstCost-exBudgetCPU":23e3,"cekConstCost-exBudgetMemory":100,"cekDelayCost-exBudgetCPU":23e3,"cekDelayCost-exBudgetMemory":100,"cekForceCost-exBudgetCPU":23e3,"cekForceCost-exBudgetMemory":100,"cekLamCost-exBudgetCPU":23e3,"cekLamCost-exBudgetMemory":100,"cekStartupCost-exBudgetCPU":100,"cekStartupCost-exBudgetMemory":100,"cekVarCost-exBudgetCPU":23e3,"cekVarCost-exBudgetMemory":100,"chooseData-cpu-arguments":19537,"chooseData-memory-arguments":32,"chooseList-cpu-arguments":175354,"chooseList-memory-arguments":32,"chooseUnit-cpu-arguments":46417,"chooseUnit-memory-arguments":4,"consByteString-cpu-arguments-intercept":221973,"consByteString-cpu-arguments-slope":511,"consByteString-memory-arguments-intercept":0,"consByteString-memory-arguments-slope":1,"constrData-cpu-arguments":89141,"constrData-memory-arguments":32,"decodeUtf8-cpu-arguments-intercept":497525,"decodeUtf8-cpu-arguments-slope":14068,"decodeUtf8-memory-arguments-intercept":4,"decodeUtf8-memory-arguments-slope":2,"divideInteger-cpu-arguments-constant":196500,"divideInteger-cpu-arguments-model-arguments-intercept":453240,"divideInteger-cpu-arguments-model-arguments-slope":220,"divideInteger-memory-arguments-intercept":0,"divideInteger-memory-arguments-minimum":1,"divideInteger-memory-arguments-slope":1,"encodeUtf8-cpu-arguments-intercept":1e3,"encodeUtf8-cpu-arguments-slope":28662,"encodeUtf8-memory-arguments-intercept":4,"encodeUtf8-memory-arguments-slope":2,"equalsByteString-cpu-arguments-constant":245e3,"equalsByteString-cpu-arguments-intercept":216773,"equalsByteString-cpu-arguments-slope":62,"equalsByteString-memory-arguments":1,"equalsData-cpu-arguments-intercept":1060367,"equalsData-cpu-arguments-slope":12586,"equalsData-memory-arguments":1,"equalsInteger-cpu-arguments-intercept":208512,"equalsInteger-cpu-arguments-slope":421,"equalsInteger-memory-arguments":1,"equalsString-cpu-arguments-constant":187e3,"equalsString-cpu-arguments-intercept":1e3,"equalsString-cpu-arguments-slope":52998,"equalsString-memory-arguments":1,"fstPair-cpu-arguments":80436,"fstPair-memory-arguments":32,"headList-cpu-arguments":43249,"headList-memory-arguments":32,"iData-cpu-arguments":1e3,"iData-memory-arguments":32,"ifThenElse-cpu-arguments":80556,"ifThenElse-memory-arguments":1,"indexByteString-cpu-arguments":57667,"indexByteString-memory-arguments":4,"lengthOfByteString-cpu-arguments":1e3,"lengthOfByteString-memory-arguments":10,"lessThanByteString-cpu-arguments-intercept":197145,"lessThanByteString-cpu-arguments-slope":156,"lessThanByteString-memory-arguments":1,"lessThanEqualsByteString-cpu-arguments-intercept":197145,"lessThanEqualsByteString-cpu-arguments-slope":156,"lessThanEqualsByteString-memory-arguments":1,"lessThanEqualsInteger-cpu-arguments-intercept":204924,"lessThanEqualsInteger-cpu-arguments-slope":473,"lessThanEqualsInteger-memory-arguments":1,"lessThanInteger-cpu-arguments-intercept":208896,"lessThanInteger-cpu-arguments-slope":511,"lessThanInteger-memory-arguments":1,"listData-cpu-arguments":52467,"listData-memory-arguments":32,"mapData-cpu-arguments":64832,"mapData-memory-arguments":32,"mkCons-cpu-arguments":65493,"mkCons-memory-arguments":32,"mkNilData-cpu-arguments":22558,"mkNilData-memory-arguments":32,"mkNilPairData-cpu-arguments":16563,"mkNilPairData-memory-arguments":32,"mkPairData-cpu-arguments":76511,"mkPairData-memory-arguments":32,"modInteger-cpu-arguments-constant":196500,"modInteger-cpu-arguments-model-arguments-intercept":453240,"modInteger-cpu-arguments-model-arguments-slope":220,"modInteger-memory-arguments-intercept":0,"modInteger-memory-arguments-minimum":1,"modInteger-memory-arguments-slope":1,"multiplyInteger-cpu-arguments-intercept":69522,"multiplyInteger-cpu-arguments-slope":11687,"multiplyInteger-memory-arguments-intercept":0,"multiplyInteger-memory-arguments-slope":1,"nullList-cpu-arguments":60091,"nullList-memory-arguments":32,"quotientInteger-cpu-arguments-constant":196500,"quotientInteger-cpu-arguments-model-arguments-intercept":453240,"quotientInteger-cpu-arguments-model-arguments-slope":220,"quotientInteger-memory-arguments-intercept":0,"quotientInteger-memory-arguments-minimum":1,"quotientInteger-memory-arguments-slope":1,"remainderInteger-cpu-arguments-constant":196500,"remainderInteger-cpu-arguments-model-arguments-intercept":453240,"remainderInteger-cpu-arguments-model-arguments-slope":220,"remainderInteger-memory-arguments-intercept":0,"remainderInteger-memory-arguments-minimum":1,"remainderInteger-memory-arguments-slope":1,"serialiseData-cpu-arguments-intercept":1159724,"serialiseData-cpu-arguments-slope":392670,"serialiseData-memory-arguments-intercept":0,"serialiseData-memory-arguments-slope":2,"sha2_256-cpu-arguments-intercept":806990,"sha2_256-cpu-arguments-slope":30482,"sha2_256-memory-arguments":4,"sha3_256-cpu-arguments-intercept":1927926,"sha3_256-cpu-arguments-slope":82523,"sha3_256-memory-arguments":4,"sliceByteString-cpu-arguments-intercept":265318,"sliceByteString-cpu-arguments-slope":0,"sliceByteString-memory-arguments-intercept":4,"sliceByteString-memory-arguments-slope":0,"sndPair-cpu-arguments":85931,"sndPair-memory-arguments":32,"subtractInteger-cpu-arguments-intercept":205665,"subtractInteger-cpu-arguments-slope":812,"subtractInteger-memory-arguments-intercept":1,"subtractInteger-memory-arguments-slope":1,"tailList-cpu-arguments":41182,"tailList-memory-arguments":32,"trace-cpu-arguments":212342,"trace-memory-arguments":32,"unBData-cpu-arguments":31220,"unBData-memory-arguments":32,"unConstrData-cpu-arguments":32696,"unConstrData-memory-arguments":32,"unIData-cpu-arguments":43357,"unIData-memory-arguments":32,"unListData-cpu-arguments":32247,"unListData-memory-arguments":32,"unMapData-cpu-arguments":38314,"unMapData-memory-arguments":32,"verifyEcdsaSecp256k1Signature-cpu-arguments":2e10,"verifyEcdsaSecp256k1Signature-memory-arguments":2e10,"verifyEd25519Signature-cpu-arguments-intercept":9462713,"verifyEd25519Signature-cpu-arguments-slope":1021,"verifyEd25519Signature-memory-arguments":10,"verifySchnorrSecp256k1Signature-cpu-arguments-intercept":2e10,"verifySchnorrSecp256k1Signature-cpu-arguments-slope":0,"verifySchnorrSecp256k1Signature-memory-arguments":2e10}},executionUnitPrices:{priceMemory:.0577,priceSteps:721e-7},maxBlockBodySize:90112,maxBlockExecutionUnits:{memory:62e6,steps:4e10},maxBlockHeaderSize:1100,maxCollateralInputs:3,maxTxExecutionUnits:{memory:14e6,steps:1e10},maxTxSize:16384,maxValueSize:5e3,minPoolCost:34e7,monetaryExpansion:.003,poolPledgeInfluence:.3,poolRetireMaxEpoch:18,protocolVersion:{major:7,minor:0},stakeAddressDeposit:2e6,stakePoolDeposit:5e8,stakePoolTargetNum:500,treasuryCut:.2,txFeeFixed:155381,txFeePerByte:44,utxoCostPerByte:4310},latestTip:{epoch:29,hash:"0de380c16222470e4cf4f7cce8af9a7b54d63e5aa4228520df9f2d252a0efcb5",slot:11192926,time:1666876126e3}};export class SimpleWallet{#$r;#kr;#ur;constructor(t,e){this.#$r=t,this.#kr=e,this.#ur=this.#kr.derivePubKey()}get privateKey(){return this.#kr}get pubKey(){return this.#ur}get pubKeyHash(){return this.#ur.pubKeyHash}get address(){return Address.fromPubKeyHash(this.pubKeyHash)}async isMainnet(){return!1}get rewardAddresses(){throw new Error("not yet implemented")}get usedAddresses(){return new Promise(((t,e)=>{t([this.address])}))}get unusedAddresses(){return new Promise(((t,e)=>{t([])}))}get utxos(){return new Promise(((t,e)=>{t(this.#$r.getUtxos(this.address))}))}get collateral(){return new Promise(((t,e)=>{t([])}))}async signData(t,e){throw new Error("not yet implemented")}async signTx(t){return[this.#kr.sign(t.bodyHash)]}async submitTx(t){return await this.#$r.submitTx(t)}}class GenesisTx{#Br;#rr;#M;#U;constructor(t,e,n,r){this.#Br=t,this.#rr=e,this.#M=n,this.#U=r}id(){let t=bigIntToBytes(BigInt(this.#Br));return t.length<32&&(t=new Array(32-t.length).fill(0).concat(t)),new TxId(t)}consumes(t){return!1}collectUtxos(t,e){return eq(this.#rr.bytes,t.bytes)?((e=e.slice()).push(new TxInput(new TxOutputId(this.id(),0),new TxOutput(this.#rr,new Value(this.#M,this.#U)))),e):e}getUtxo(t){return this.id().eq(t.txId)&&0==t.utxoIdx?new TxInput(new TxOutputId(this.id(),0),new TxOutput(this.#rr,new Value(this.#M,this.#U))):null}dump(){console.log("GENESIS TX"),console.log(`id: ${this.#Br.toString()},\naddress: ${this.#rr.toBech32()},\nlovelace: ${this.#M.toString()},\nassets: ${JSON.stringify(this.#U.dump(),void 0,"    ")}`)}}class RegularTx{#Ar;constructor(t){this.#Ar=t}id(){return this.#Ar.id()}consumes(t){return this.#Ar.body.inputs.some((e=>e.eq(t)))}collectUtxos(t,e){e=e.filter((t=>!this.consumes(t)));return this.#Ar.body.outputs.forEach(((n,r)=>{eq(n.address.bytes,t.bytes)&&e.push(new TxInput(new TxOutputId(this.id(),r),n))})),e}getUtxo(t){if(!t.txId.eq(this.id()))return null;let e=null;return this.#Ar.body.outputs.forEach(((n,r)=>{r==t.utxoIdx&&(e=new TxInput(t,n))})),e}dump(){console.log("REGULAR TX"),console.log(JSON.stringify(this.#Ar.dump(),void 0,"  "))}}export class NetworkEmulator{#Dn;#Mr;#Ur;#Nr;#Lr;constructor(t=0){this.#Dn=0n,this.#Mr=Crypto.mulberry32(t),this.#Ur=[],this.#Nr=[],this.#Lr=[]}get currentSlot(){return this.#Dn}initNetworkParams(t){const e=Object.assign({},t.raw);return e.latestTip={epoch:0,hash:"",slot:0,time:0},new NetworkParams(e,(()=>this.#Dn))}createWallet(t=0n,e=new Assets([])){const n=new SimpleWallet(this,Bip32PrivateKey.random(this.#Mr));return this.createUtxo(n,t,e),n}createUtxo(t,e,n=new Assets([])){if(0n!=e||!n.isZero()){const r=new GenesisTx(this.#Ur.length,t.address,e,n);this.#Ur.push(r),this.#Nr.push(r)}}tick(t){assert(t>0,`nSlots must be > 0, got ${t.toString()}`),this.#Nr.length>0&&(this.#Lr.push(this.#Nr),this.#Nr=[]),this.#Dn+=t}async getParameters(){return this.initNetworkParams(new NetworkParams(rawNetworkEmulatorParams))}warnMempool(){this.#Nr.length>0&&console.error("Warning: mempool not empty (hint: use 'network.tick()')")}async getUtxo(t){this.warnMempool();for(let e of this.#Lr)for(let n of e){const e=n.getUtxo(t);if(e)return e}throw new Error(`utxo with id ${t.toString()} doesn't exist`)}async getUtxos(t){this.warnMempool();let e=[];for(let n of this.#Lr)for(let r of n)e=r.collectUtxos(t,e);return e}dump(){console.log(`${this.#Lr.length} BLOCKS`),this.#Lr.forEach(((t,e)=>{console.log(`${t.length} TXs in BLOCK ${e}`);for(let e of t)e.dump()}))}isConsumed(t){return this.#Lr.some((e=>e.some((e=>e.consumes(t)))))||this.#Nr.some((e=>e.consumes(t)))}async submitTx(t){return this.warnMempool(),assert(t.isValid(this.#Dn),"tx invalid (not finalized or slot out of range)"),assert(t.body.inputs.every((t=>!this.isConsumed(t))),"input already consumed before"),this.#Nr.push(new RegularTx(t)),t.id()}}class TxChainWallet{#b;#Vr;constructor(t,e){this.#b=t,this.#Vr=e}async isMainnet(){return this.#b.isMainnet()}async signData(t,e){return this.#b.signData(t,e)}async signTx(t){return this.#b.signTx(t)}async submitTx(t){return this.#Vr.submitTx(t)}get rewardAddresses(){return this.#b.rewardAddresses}get unusedAddresses(){return this.#b.unusedAddresses}get usedAddresses(){return this.#b.usedAddresses}async filterUtxos(t){const e=await this.usedAddresses,n=await this.unusedAddresses,r=e.concat(n);return await this.#Vr.getUtxosInternal(t,r)}get collateral(){return new Promise(((t,e)=>{this.#b.collateral.then((e=>{this.filterUtxos(e).then((e=>{t(e)}))}))}))}get utxos(){return new Promise(((t,e)=>{this.#b.utxos.then((e=>{this.filterUtxos(e).then((e=>{t(e)}))}))}))}}export class TxChain{#$r;#Or;constructor(t){this.#$r=t,this.#Or=[]}async submitTx(t){const e=await this.#$r.submitTx(t);return this.#Or.push(new RegularTx(t)),e}async getParameters(){return this.#$r.getParameters()}async getUtxo(t){for(let e=0;e<this.#Or.length;e++){const n=this.#Or[e].getUtxo(t);if(n)return n}return this.#$r.getUtxo(t)}async getUtxosInternal(t,e){for(let n of this.#Or)e.forEach((e=>{t=n.collectUtxos(e,t)}));return t}async getUtxos(t){let e=await this.#$r.getUtxos(t);return this.getUtxosInternal(e,[t])}asWallet(t){return new TxChainWallet(t,this)}}export class NetworkSlice{#Gt;#vr;constructor(t,e){this.#Gt=t,this.#vr=e}static async init(t,e){const n=[t.getParameters(),...e.map((e=>t.getUtxos(e)))],r=await Promise.all(n),[s,...a]=r,i={};return e.forEach(((t,e)=>{i[t.toBech32()]=a[e]})),new NetworkSlice(s,i)}toJson(){const t={};for(let e in this.#vr)t[e]=this.#vr[e].map((t=>bytesToHex(t.toFullCbor())));return{params:this.#Gt.raw,utxos:t}}static fromJson(t){const e=new NetworkParams(t.params),n={};for(let e in t.utxos)n[e]=t.utxos[e].map((t=>TxInput.fromFullCbor(t)));return new NetworkSlice(e,n)}async getParameters(){return this.#Gt}async getUtxo(t){for(let e of Object.values(this.#vr))for(let n of e)if(n.outputId.eq(t))return n;throw new Error(`utxo ${t.toString()} not found`)}async getUtxos(t){const e=t.toBech32();return e in this.#vr?this.#vr[e]:[]}async submitTx(t){throw new Error("can't submit tx through network slice")}}export class FuzzyTest{#Hr;#qr;#zr;#jr;#Wr;#Gr;constructor(t=0,e=100,n=!1,r=!1){console.log("starting fuzzy testing  with seed",t),this.#Hr=t,this.#qr=Crypto.rand(t),this.#zr=e,this.#jr=n,this.#Gr=new NetworkParams(rawNetworkEmulatorParams),this.#Wr=r}reset(){this.#qr=Crypto.rand(this.#Hr)}newRand(){let t=1e6*this.#qr();return Crypto.rand(t)}rawInt(t=-1e7,e=1e7){let n=this.newRand();return function(){return BigInt(Math.floor(n()*(e-t))+t)}}int(t=-1e7,e=1e7){let n=this.rawInt(t,e);return function(){return new IntData(n())}}real(t=-1e3,e=1e3){let n=this.newRand();return function(){return new IntData(BigInt(Math.floor(1e6*(n()*(e-t)+t))))}}string(t=0,e=64){let n=this.newRand();return function(){let r=Math.round(n()*(e-t))+t;r<0&&(r=0);let s=[];for(let t=0;t<r;t++)s.push(String.fromCodePoint(Math.round(1112064*n())));return ByteArrayData.fromString(s.join(""))}}ascii(t=0,e=64){let n=this.newRand();return function(){let r=Math.round(n()*(e-t))+t;r<0&&(r=0);let s=[];for(let t=0;t<r;t++)s.push(String.fromCharCode(Math.round(94*n()+32)));return ByteArrayData.fromString(s.join(""))}}asciiBytes(t=0,e=64){let n=this.newRand();return function(){let r=Math.round(n()*(e-t))+t;r<0&&(r=0);let s=[];for(let t=0;t<r;t++)s.push(Math.floor(94*n()+32));return new ByteArrayData(s)}}utf8Bytes(t=0,e=64){return this.string(t,e)}rawBytes(t=0,e=64){let n=this.newRand();return function(){let r=Math.round(n()*(e-t))+t;r<0&&(r=0);let s=[];for(let t=0;t<r;t++)s.push(Math.floor(256*n()));return s}}bytes(t=0,e=64){let n=this.rawBytes(t,e);return function(){let t=n();return new ByteArrayData(t)}}rawBool(){let t=this.newRand();return function(){return t()>=.5}}bool(){let t=this.rawBool();return function(){return new ConstrData(t()?1:0,[])}}option(t,e=.5){let n=this.newRand();return function(){return n()<e?new ConstrData(1,[]):new ConstrData(0,[t()])}}list(t,e=0,n=10){let r=this.newRand();return e<0&&(e=0),n<0&&(n=0),function(){let s=Math.round(r()*(n-e))+e;s<0&&(s=0);let a=[];for(let e=0;e<s;e++)a.push(t());return new ListData(a)}}map(t,e,n=0,r=10){let s=this.newRand();return n<0&&(n=0),r<0&&(r=0),function(){let a=Math.round(s()*(r-n))+n;a<0&&(a=0);let i=[];for(let n=0;n<a;n++)i.push([t(),e()]);return new MapData(i)}}object(...t){return function(){let e=t.map((t=>t()));return new ConstrData(0,e)}}constr(t,...e){return function(){const n=e.map((t=>t())),r="number"==typeof t?t:Math.round(100*t());return new ConstrData(r,n)}}async test(t,e,n,r=this.#zr,s=!1){let a=extractScriptPurposeAndName(e);if(null===a)throw new Error("failed to get script purpose and name");{const[i,o]=a,_=Program.new(e),l=_.compile(s),u={mem:0n,cpu:0n};let c=0;for(let e=0;e<r;e++){let e=t.map((t=>new UplcDataValue(Site.dummy(),t())));const r={mem:0n,cpu:0n};try{let t=await l.run(e,{...DEFAULT_UPLC_RTE_CALLBACKS,onPrint:this.#Wr?async t=>{console.log(t)}:async t=>{},onIncrCost:(t,e,n)=>{r.mem=r.mem+n.mem,r.cpu=r.cpu+n.cpu}},this.#Gr),a=n(e,t,s);if(t instanceof RuntimeError||(u.mem+=r.mem,u.cpu+=r.cpu,c+=1),"boolean"==typeof a){if(!a)throw console.log(_.dumpIR(s,!0)),new Error(`property test '${o}' failed (info: (${e.map((t=>t.toString())).join(", ")}) => ${t.toString()})`)}else for(let n in a)if(!a[n])throw console.log(_.dumpIR(s,!0)),new Error(`property test '${o}:${n}' failed (info: (${e.map((t=>t.toString())).join(", ")}) => ${t.toString()})`)}catch(t){throw console.log("UNSIMPLIFIED:",_.dumpIR(!1,!0)),console.log("SIMPLIFIED:",_.dumpIR(!0,!0)),t}}console.log(`property tests for '${o}' succeeded${s?" (simplified)":""} (${l.calcSize()} bytes, ${c>0?u.mem/BigInt(c):"N/A"} mem, ${c>0?u.cpu/BigInt(c):"N/A"} cpu)`)}!s&&this.#jr&&await this.test(t,e,n,r,!0)}async testParams(t,e,n,r,s=this.#zr,a=!1){let i=Program.new(n),o=extractScriptPurposeAndName(n);if(null===o)throw new Error("failed to get script purpose and name");{let[_,l]=o;for(let o=0;o<s;o++){for(let e in t)i.changeParamSafe(e,t[e]());let s=e.map((t=>i.evalParam(t)));i=Program.new(n);let o=i.compile(a),_=await o.run(s,{...DEFAULT_UPLC_RTE_CALLBACKS,onPrint:this.#Wr?async t=>{console.log(t)}:async t=>{}}),u=r(s,_,a);if("boolean"==typeof u){if(!u)throw console.log(i.dumpIR(a,!0)),new Error(`property test '${l}' failed (info: (${s.map((t=>t.toString())).join(", ")}) => ${_.toString()})`)}else for(let t in u)if(!u[t])throw console.log(i.dumpIR(a,!0)),new Error(`property test '${l}:${t}' failed (info: (${s.map((t=>t.toString())).join(", ")}) => ${_.toString()})`)}console.log(`property tests for '${l}' succeeded${a?" (simplified)":""}`)}!a&&this.#jr&&await this.testParams(t,e,n,r,s,!0)}}export async function jsToUplcInternal(t,e,n){if("List"==t.type&&"itemType"in t){if(!Array.isArray(e))throw new Error(`expected Array, got '${e}'`);const r=e.map((e=>jsToUplcInternal(t.itemType,e,n)));return new ListData(await Promise.all(r))}if("Map"==t.type&&"keyType"in t&&"valueType"in t){if(!Array.isArray(e))throw new Error(`expected Array, got '${e}'`);const r=e.map((r=>{if(!Array.isArray(r))throw new Error(`expected Array of Arrays, got '${e}'`);const[s,a]=r;if(!s||!a)throw new Error(`expected Array of Array[2], got '${e}'`);return[jsToUplcInternal(t.keyType,s,n),jsToUplcInternal(t.valueType,a,n)]})),s=await Promise.all(r.map((t=>t[0]))),a=await Promise.all(r.map((t=>t[1])));return new MapData(s.map(((t,e)=>[t,a[e]])))}if("Option"==t.type&&"someType"in t)return null===e?new ConstrData(1,[]):new ConstrData(0,[await jsToUplcInternal(t.someType,e,n)]);if("Struct"==t.type&&"fieldTypes"in t){const r=t.fieldTypes.map((t=>{const r=t.name,s=e[r];if(void 0===s)throw new Error(`field ${r} not found in '${e}'`);return jsToUplcInternal(t,s,n)}));return 1==r.length?r[0]:new ListData(await Promise.all(r))}if("Enum"==t.type&&"variantTypes"in t){const r=Object.keys(e);if(1!=r.length)throw new Error("expected a single key for enum");const s=r[0],a=t.variantTypes.findIndex((t=>t.name==s));if(-1==a)throw new Error(`invalid variant ${s}`);const i=t.variantTypes[a].fieldTypes.map((t=>{const r=t.name,a=e[s][r];if(void 0===a)throw new Error(`field ${r} not found in '${e[s]}'`);return jsToUplcInternal(t,a,n)}));return new ConstrData(a,await Promise.all(i))}{const r=builtinTypes[t.type];if(!r)throw new Error(`${t.type} isn't a valid builtin type`);return r.jsToUplc(e,n)}}export function jsToUplc(t,e,n){return jsToUplcInternal(t,e,n)}async function uplcToJsInternal(t,e,n){if("List"==t.type&&"itemType"in t)return await Promise.all(e.list.map((e=>uplcToJsInternal(t.itemType,e,n))));if("Map"==t.type&&"keyType"in t&&"valueType"in t){const r=e.map.map((([e,r])=>[uplcToJsInternal(t.keyType,e,n),uplcToJsInternal(t.valueType,r,n)])),s=await Promise.all(r.map((t=>t[0]))),a=await Promise.all(r.map((t=>t[1])));return s.map(((t,e)=>[t,a[e]]))}if("Option"==t.type&&"someType"in t){if(1==e.index)return assert(0==e.fields.length,"not an Option ConstrData"),null;if(0==e.index)return assert(1==e.fields.length,"not an Option ConstrData"),uplcToJsInternal(t.someType,e.fields[0],n);throw new Error("not an Option ConstrData")}if("Struct"==t.type&&"fieldTypes"in t){const r={},s=1==t.fieldTypes.length?[e]:e.list;for(let e=0;e<s.length;e++){const a=s[e],i=t.fieldTypes[e];if(!i)throw new Error("field out-of-range");r[i.name]=await uplcToJsInternal(i,a,n)}return r}if("Enum"==t.type&&"variantTypes"in t){const r=e.index,s=t.variantTypes[r];if(!s)throw new Error("constr index out-of-range");const a={},i=e.fields;for(let t=0;t<i.length;t++){const e=i[t],r=s.fieldTypes[t];if(!r)throw new Error("field out-of-range");a[r.name]=await uplcToJsInternal(r,e,n)}return{[s.name]:a}}{const r=builtinTypes[t.type];if(!r)throw new Error(`${t.type} isn't a valid builtin type`);return r.uplcToJs(e,n)}}export function uplcToJs(t,e,n){return uplcToJsInternal(t,e,n)}